
\section{Registro}

\subsection{Interfaz}

\sexc{registro}
$\textbf{usa}$ {nat, dato, campo, conjTrie, string, itConj}
\generos{reg, itReg}




\subsubsection*{Operaciones}
%%%%%% observadores basicos %%%%%%
\operacion{nReg}{}{res:reg}
{true}
{res $\igobs$ $\emptyset$}
{Crea un registro nuevo,vacio}
{O(1)}
{No tiene Aliasing}



%%%%%%%%%%%%%%%%%%%%%%% Otras Operaciones %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\operacion{campos}{in r: reg}{res : itConj(campo)}
 {true}
 {$res \igobs alias(res, claves(r))$}
 {Devuelve un conjunto de campos que son claves del registro ingresado por parametro}
 {O($1$)}
 {Se devuelve un iterador al conjunto, hay aliasing}

\operacion{borrar?}{in crit: reg, in r: reg}{res : bool}
 {$\#$campos(crit) = 1}
 {$res \igobs borrar?(crit, r)$}
 {Devuelve true si y solo si todos los campos de crit pertenecen a campos de r.}
 {O($1$)} 
 {}

\operacion{agCampos}{in/out  $r_1$: reg, in  $r_2$: reg}{}
 {$ r_1 \igobs r1_0 $}
 {$r_1 \igobs agregarCampos(r1_0, r2) $}
 {agrega los datos de los campos faltantes de r2 a los campos de r1}
 {O($1$)} 
 {}
 
 \operacion{copiarCampos}{in/out  $r_1$: reg, in  cc: conj(campo), in $r_2$: reg}{}
{$r1 \igobs r1_0 \land  cc \in campos(r_2) $}
{$r1 \igobs copiarCampos(cc, r1_0, r2)$}
{copia los datos que se encuentran en los campos de r2 a r1}
{O($1$)}
{}%

\operacion{coincideAlguno}{in  $r_1$: reg, in cc: conj(campo), in  $r_2$: reg}{res : bool}
 {cc $\subseteq campos(r_1)\cap$ campos($r_2$)}
 {$res \igobs coincideAlguno(r_1, r_2)$}
 {Devuelve true si y solo si alguno de los campos(dato) de cc pertenece a r1 y r2}
 {O($1$)}
 {}
 
\operacion{coincidenTodos}{in $r_1$: reg, in cc: conj(campo), in $r_2$: reg}{res : bool }
 {cc $\subseteq campos(r_1) \cap$ campos($r_2$)}
 {$res \igobs coincidenTodos(r_1, cc, r_2) $}
 {Devuelve ture si y solo si todos los campos(dato) de cc pertenecen a r1 y r2}
 {O($1$) } 
 {}
 
\operacion{enTodos}{in c: campo, in cr: conj(registro)}{res : bool}
 {true}
 {$res \igobs enTodos(c,cr)$}
 {Devuelve true si y solo si campo c pertenece a los campos de cada uno de los registros cr}
 {O($\#(cr)$)}
 {}

\operacion{unirRegistros}{in c: campo, in $r_1$:reg, in $r_2$: reg}{res:registro}
{$c \pertenece campos(r_1) \land c \pertenece (campos(r_2))$}
{$res \igobs combinarTodos(c,r_1,ag( \emptyset , r_2))) )$}
{Devuelve el registro que combina los valores de $r_1$ y $r_2$ }
{O($1$)}
{$r_1$ y $r_2$ son tomados por referencia}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\subsection{Representación}

\serc{DiccString(campo, dato)}


\subsubsection*{Invariante de representación}
\rep{Dicc}{d}{true}


\subsubsection*{Función de abstracción}
\abs{DiccTrie}{reg}{d}{r}{\IF vacía?($d$.claves) THEN vacío ELSE definir(prim($d$).claves, prim($d$).significado, Abs(fin($d$))) FI}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\subsection{Algoritmos}

\algoritmo{campos}{in r: reg}{res: Conj(campo)}{
  \State cn $\larr$ vacio() \complejidad{O(1)}
  \State it $\larr$ crearItDicc(r)
  \While {haySiguiente(it)} \complejidad{O(1)}
          \State agregar(cn, clave.siguiente(it)) \complejidad{O(1)}
          \State avanzar(it) \complejidad{O(1)}
 \EndWhile
  \State res $\larr$ cn \complejidad{O(1)}
}{O(1)}


\algoritmo{borrar?}{in crit: reg in r: reg}{res: bool}{
  \State cc $\larr$ crit.campos \complejidad{O(1)}
  \State res $\larr$ coincidenTodos(crit, cc, r): \complejidad{O(1)}
}{O(1)}

 
 
\algoritmo{agregarCampos}{in $r_1$: reg in $r_2$: reg}{res:}{
    \State cc $\larr$ $r_2$.campos / campos($r_1$) \complejidad{O(#(campos($r_1$))+#(campos($r_2$)))}
    \State res $\larr$ copiarCampos(cc,$r_2,r_1$) \complejidad{O()}
}{O(1)}

 
  \algoritmo{copiarCampos}{in cc: conj(campo) in/out r1: reg, in r2: reg}{}{
    \State  itcc $\larr$ crearItConj(cc) \complejidad{O(1)}
    \While {haySiguiente(itcc)} \complejidad{O(1)}
                    \State definir(r1, siguiente(itcc), obtener) \complejidad{O(long())}
                    \State avanzar(itcc) \complejiad{O(1)}
    \EndWhile
 }{O(1)}
 
   \algoritmo{coincideAlguno}{in r1: reg in cc: conj(campo) in r2: reg}{res:bool}{
   \State res $\larr$ false \complejidad {O(1)}
          \If {$\not$ vacio?(cc)}  \complejidad {O(1)}
              \State itcc $\larr$ crearItConj(cc) \complejidad {O(1)}
   \While {haySiguiente(ittcc)} \complejidadd {O(1)}
          \If {obtener(siguiente(itcc),$r_1$) == obtener(siguiente(itcc),r2)}
                  \State res $\larr$  true \complejidad {O(1)}
           \EndIf
          \State avanzar(itcc) \complejidad {O(1)}
    \EndWhile
 }{O(1)}
 
    \algoritmo{coincidenTodos}{in r1: reg in cc: conj(campo) in r2: reg}{res:bool}{
    \State res $\larr$ true \complejidad {O(1)}
    \State itcc $\larr$ crearItConj(cc) \complejidad {O(1)}
    \While {haySiguiente(itcc) $\land$ res} \complejidadd {O(1)}
          \If { $\not$(obtener(siguiente(itcc)\, r1) == obtener(siguiente(itcr)\, r2))}
                  \State res $\larr$  false \complejidad {O(1)}
           \EndIf
          \State avanzar(itcc)\complejidad {O(1)}
    \EndWhile
 }{O(1)}
 
    \algoritmo{enTodos}{in c:campo in cr: conj(reg)}{res:bool}{
    \State res $\larr$ True \complejidad{O(1)}
    \State itcr $\larr$  CrearItConj(cr) \complejidad{O($\#$(cr))}
    \State \While {haySiguiente(itcr) $\land$ res} \complejidad{O($\#$(cr))}
                \If { $\not$ pertenece(c,siguiente(itcr))} \complejidad{O(1)}
                    \State res $\larr$ false \complejidad{O(1)}
                \EndIf
    \EndWhile   
 }{O($\#$(cr))}
 
  \algoritmo{combinarTodos}{in c: campo in r1: reg in cr: conj(reg)}{}{
    \State itcr $\larr$  CrearItConjDic(cr) \complejidad{O($\#$(cr))}
    \State \While {haySiguiente(itcr) $\land$ res} \complejidad{O($\#$(cr))}
                \If {obtener(c,siguiente(itcr) == obtener(c,r)} \complejidad{O(1)}
                    \State agregarCampos(r, siguiente(itcr)) \complejidad{O(1)}
                \EndIf
    \EndWhile   
 }{O($\#$(cr))}
 
   \algoritmo{unirRegistros}{in c: campo in $r_1$: reg in $r_2$: reg}{res: reg}{
    \State $res$ \larr nReg() \coplejidad{O(1)}
    \State agregarCampos($res, r_1$) \complejidad{O(1)}
    \State agregarCampos($res, r_2$) \complejidad{O(1)}
 }{O($\#$(cr))}
     

 