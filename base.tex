
%\section{Pos es tupla(x:Nat, y:Nat)}

%\section{Tipo es Bool}

\section{NombreTabla es String}

\section{Base de Datos}

\subsection{Interfaz}

\sexc{Base}
$\textbf{usa}$  
\generos{nat, string, tabla, regisro, campo, dato}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Operaciones}


%%%%%% observadores basicos %%%%%%
%
\operacion{tablas}{in b: base }{res : ItConjString(NombreTabla)}
 {true}
 {$res \igobs nombre(t)$}
 {Devuelve el nombre de la tabla ingresada por parametro.}
 {O($1$)}
 {Se retorna res por copia, por ser un tipo basico.}

\operacion{dameTabla}{in t: string, in b: base }{res : tabla}
 {true}
 {$res \igobs dameTabla(t,b)$}
 {Devuelve la tabla correspondiente al nombre ingresado por parametro.}
 {O($1$)}
 {Se devuelve la tabla correspondiente por referencia.}

\operacion{hayJoin?}{in t1: string, in t2: string, in t: base }{res : bool}
 {true}
 {$res \igobs indices(t)$}
 {Devuelve un conjunto de los indices de la tabla ingresada por parametro.}
 {O($1$)}
 {Se devuelve res por referencia y no es modificable.}
 
\operacion{campoJoin}{in t1: string, in t2: string, in t: base }{res : itConjTrie(campo)}
 {true}
 {$res \igobs campos(t)$}
 {Devuelve un conjunto a los campos de la tabla ingresada por parametro.}
 {O($1$)}
 {Se devuelve res por referencia.}

% %%%%%% generadores %%%%%%%
 
 \operacion{nuevaDB}{}{res : base}
 {$True$}
 {$res \igobs nuevaDB()$}
 {Crea una base sin tablas.}
 {O($1$)}
 {}

 \operacion{agregarTabla}{in t: tabla, in b: base}{}
 {$b\_0$=b $\land$ nombre(t)$\notin$ tablas(b) $\land$ Vacio?(t.registros)}
 {agregarTabla(t\,$b\_0$)}
 {Agrega una tabla a la base de datos.}
 {O($1$)}
 {Agrega tabla por referencia.} 
 
 \operacion{insertarEntrada}{in reg: registro, in t: string, in b: base}{}
 {$b\_0$=b $\land$ t$\in$tablas(b) $\yluego$ puedoInsertar?(dameTabla(t)\, reg)}
 {insertarEntrada(r\,t \,$b\_0$)}
 {Inserta el registro a la tabla t.}
 {O($T$)}
 {} 
 
  \operacion{borrar}{in cr: registro, in t: string, in b: base}{}
 {$b\_0$=b $\land$ t$\in$tablas(b) $\land$ \#(DiccClaves(cr))=1}
 {borrar(cr\, t\, $b\_0$)}
 {Borra los registros que cumplan el criterio cr pasado por parametro.}
 {O($T + Log(n)$)}
 {} 	

  \operacion{generarVistaJoin}{in t1: string, in t2: string, in c: campo, in b: base}{}
 {b\_0=b $\land$ t1$\sqsupset$t2 $\land$ \{t1, t2\}$\subseteq$tablas(b) $\yluego$ \\Pertenece?(Campos(dameTabla(t1, b)), c) $\land$ Pertenece?(Campos(dameTabla(t1, b)), c) $\land$ \\$\neg$hayJoin?(t1, t2, b)}
 {generarVistaJoin(cr, t, $b\_0$)}
 {Borra los registros que cumplan el criterio cr pasado por parametro.}
 {O($calcular$)}
 {} 	

   \operacion{borrarJoin}{in t1: string, in t2: string, in b: base}{}
 {$b\_0$=b $\land$ hayJoin?(t1\, t2\, b)}
 {borrarJoin(t1\, t2\, $b\_0$)}
 {Borra correspondiente a los nombres de tablas, pasados por parametro.}
 {O($calcular$)}
 {}

%%%%%%% Otras Operaciones %%%%%%%%%%%

 \operacion{registros}{in t: string, in b: base}{res: conj(registro)}
 {t$\in$tablas(b)}
 {$res \igobs registros(t\, b)$}
 {Retorna el conjunto de registros correspondientes al nombre de tabla pasado por parametro}
 {O(1)}
 {Se retorna el conjunto de registros por referencia.} 


 \operacion{vistaJoin}{in t1: string, in t2: string, in b: base}{res: conj(registro)}
 {\{t1\, t2\}$\subseteq$tablas(b) $\land$ hayJoin?(t1\,t2\,b)}
 {$res \igobs vistaJoin(t1\, t2\, b)$}
 {Retorna el conjunto de registros correspondientes al nombre de tabla pasado por parametro}
 {O($calcular$)}
 {Se retorna el conjunto de registros por referencia.} 

 \operacion{cantidadDeAccesos}{in t: string, in b: base}{res: nat}
 {t$\in$tablas(b)}
 {$res \igobs cantidadDeAccesos(t\,b)$}
 {Retorna la cantidad de modificaciones correspondientes al nombre de tabla pasado por parametro.}
 {O(1)}
 {Se retorna res por referencia.} 

 \operacion{tablaMaxima}{in b: base}{res: string}
 {$\neg\emptyset$?(tablas(b))}
 {$res \igobs tablaMaxima(t\,b)$}
 {Retorna el nombre de la tabla con la mayor cantidad de modificaciones.}
 {O(1)}
 {Se retorna el nombre de la tabla por referencia.} 
  
 \operacion{encontrarMaximo}{in t: string, in ct: conj(string), in b: base}{res: string}
 {\{t\}$\cup$ct $\subseteq$tablas(b)}
 {$res \igobs tablaMaxima(t\,b)$}
 {Retorna ...}
 {O($calcular$)}
 {Se retorna el nombre de la tabla por referencia.}
  
 \operacion{buscar}{in criterio: registro, in t: string, in b: base}{res: conj(registro)}
 {t$\in$tablas(b)}
 {$res \igobs tablaMaxima(t\,b)$}
 {Retorna ...}
 {O($calcular$)}
 {Se retorna el nombre de la tabla por referencia.}
  
 
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Representación}

\serc{Base}
{
\donde{estr}{
\tupla{TablaMaxima: Tmax, Tablas: DiccTrie(NombreTabla; info\_tabla)}}
		\donde{info\_tabla}{\tupla{TActual: tabla, Joins: DiccTrie(NombreTabla; info\_join)}}
      	\donde{info\_join}{\tupla{
      								Rcambios: Cola(DatoCambio),
      								campoJ: campo, 
      								campoT: tipo,
      								JoinS: DiccTrie(string; itConj(registro)),
      								JoinN: DiccNat(nat; itConj(registro)),
      								JoinC: Conj(registro)}}
		\donde{Tmax}{\tupla{NomTabla: NombreTabla, $\#$Modif: Nat}}
		\donde{DatoCambio}{\tupla{Reg: Registro, NomOrigen: NombreTabla, Accion: Bool}}
}

\subsubsection*{Invariante de representación}

\begin{enumerate}
  \item El Nombre de la tabla es un String acotado.
  \item Indices es un arreglo de tamaño 2, que aloja el Indice correspondiente segun el orden de creacion.
  \item Para toda Dato que es clave en Indice, su significado llamemoslo sign esta incluido en Registros.
  \item 

\end{enumerate}


\subsubsection*{Función de abstracción}
%\abs{sistema}{CampusSeguro}{s}{cs}
%$s.campus \igobs campus(cs)$ $\land$ \\
%$s.estudiantes \igobs estudiantes(cs)$ $\land$ \\
%$s.hippies \igobs hippies(cs)$ $\land$ \\
%$s.agentes \igobs agentes(cs)$ $\land$ \\
%$((\paratodo{nombre}{n}) s.hippies.definido(n) \impluego s.hippies.obtener(n) \igobs posEstYHippie(n,cs)$ $\lor$ \\
%$(\paratodo{nombre}{n}) s.estudiantes.definido(n) \impluego s.estudiantes.obtener(n) \igobs posEstYHippie(n,cs))$ \\
%$(\paratodo{placa}{pl}) s.agentes.definido(pl) \impluego s.estudiantes.obtener(pl).pos \igobs posAgente(pl,cs))$ \\
%$(\paratodo{placa}{pl}) s.agentes.definido(pl) \impluego s.estudiantes.obtener(pl).cantSanciones \igobs cantSanciones(pl,cs))$ \\
%$(\paratodo{placa}{pl}) s.agentes.definido(pl) \impluego s.estudiantes.obtener(pl).cantCapturas \igobs cantCapturas(pl,cs))$ \\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\subsection{Algoritmos}

\algoritmo{tablas}{in b: estr}{res: ConjTrie(string)}{
  \State $res \larr DiccClaves(b.tablas) $ \complejidad{O(1)}
}{O(1)}

\algoritmo{dameTabla}{in t: string, in b: estr}{res: tabla}{
  \State $info \larr Significado(b.tablas, t) $ \complejidad{O(1)}
  \State $res \larr info.TActual $ \complejidad{O(1)}
}{O(1)}

\algoritmo{hayJoin?}{in t1: string, in t2: string, in b: estr}{res: bool}{
	\State   res $\larr$Definido?(Obtener(b, t1).Joins,t2) $\larr$ Definido?(Obtener(b, t2).Joins,t1)
}{O(1)}

\algoritmo{campoJoin}{in t1: string, in t2: string, in b: estr}{res: campo}{
		\State res$\larr$ Obtener(Obtener(b, t1).Joins, t2).campoJ
}{O(1)}

%%%%%%%%%%%%% generadores %%%%%%%%%%%%%
\algoritmo{nuevaDB}{}{res: estr)}{ 
	\State String s
	\State Nat n $\larr$ 0
	\State TablaMaxima $\larr$ $< s, 0 >$
  	\State res $\larr$ $\langle TablaMaxima, vacio()\rangle$  \complejidad{O(1)} 
}{O(1)}

\algoritmo{agregarTabla}{in t: tabla, in/out b: estr}{}{
	\State	info\_tabla $\larr$ $\langle cantidadDeAccesos(t), t, vacio()\rangle$  \complejidad{O(1) por ref}
	\State	Definir(b.tablas, nombre(t), info\_tabla)								 \complejidad{O(1)}
}{O(1)}

\algoritmo{insertarEntrada}{in reg: registro, in t: string, in/out b: estr}{}{
	\State	Obtenemos la tabla es O(1) porque su nombre esta acotado.
	\State	info\_tabla infoT $\larr$	Obtener(b.tablas, t).TActual		\complejidad{O(1) Por referencia}
	\State	Agrego el registro a la tabla. \complejidad{O(1)}
	\State	Tabla T $\larr$ infoT.TActual \complejidad{O(1)}
	\State	agregarRegistro(reg, T)								\complejidad{O(L+Log(n))}
	\State	Ahora si hay Joins actualizo la informacion temporal de cada Join.
	\If{$\neg$Vacio?(infoT.Joins)} \complejidad{O(1)}
				\State	ItConjString(String) itNomTab $\larr$ CrearIt(Claves(infoT.Joins))\complejidad{O(1)}
				\While{HaySiguiente?(itNomTab)}								\complejidad{O(W)}
					\State	info\_join infoJ $\larr$ Obtener(infoT.Joins, Siguiente(NomTab)) \complejidad{O(1)}
					\State	Encolar(infoJ.Rcambios, $\langle reg, Siguiente(NomTab),  true\rangle$) \complejidad{O(1)}
					\State	Encolar es O(L) porque se copia un registro con su cantidad de campos acotada
					\State	y los valores string copiarlos tiene costo O(L), siendo L el valor string mas largo.
					\State	Avanzar(itClaves)\complejidad{O(1)}
				\EndWhile
	\EndIf
	\If{CantidadDeAccesos(T) $\>$b.TablaMaxima.\#Modif}
			\State	b.TablaMaxima.NomTabla $\larr$ Copiar(Nombre(T)) \complejidad{O(L)}
			\State	b.TablaMaxima.\#Modif $\larr$ Copiar(CantidadDeAccesos(T))\complejidad{O(1)}
	\EndIf
	\State W la cant de tablas en la base
}{O(W) }

\algoritmo{borrar}{in cr: registro, in t: string, in/out b: estr}{}{
	\State info\_tabla infoT $\larr$	Obtener(b.tablas, t).TActual		\complejidad{O(1) por ref}
	\State	 Tabla T $\larr$ infoT.TActual \complejidad{O(1) por ref}
	\State NombreTabla NomTab $\larr$ NombreTabla(T)
	\State La eliminacion en primera etapa depende de si hay
	\State	 joins con la tabla pasada por parametro
	\If{$\neg\emptyset$?(Claves(infoT.Joins))} \complejidad{O(1)}
			\State Creo el iterador, para navegar los nombres de tablas con los que tiene Join
			\State itNom $\larr$ CrearIt(Claves(infoT.Joins)) \complejidad{O(1)}
			\While{HaySiguiente?(itNom)} \complejidad{O(Cant de tablas)}
					\State info\_join infoJ $\larr$ Siguiente(itNom) \complejidad{O(1)}
					\State Verifico si el Join esta creado en base al 
					\State campo del cr pasado por parametro.
					\If{infoJ.campoJ=DameUno(Campos(cr))} \complejidad{O(1)}
							\State	Entonces solo actualizo la cola temporal del join
							\State	Registro reg $\larr$ Buscar(cr, T) \complejidad{O(L + Log(n))}
							\State	Encolar(infoJ.Rcambios, $\langle reg, Siguiente(itNom),  False\rangle$)\complejidad{O(L)}
					\Else
							\State	Si el campo del criterio de borrado, es distinto que el campo del Join.
							\State	Primero busco que registros coinciden con el criterio
							\State	en el peor caso con complejidad O(cantidad de registros de t) sin indices.
							\State	Conj(Registro) cjc $\larr$ Buscar(cr, T)\complejidad{O(L + Log(n))}
																						% Coincidencias(cr, Registros(r))
							\State	ItConj(Registro) itReg $\larr$ CrearIt(cjc)
							\State	Luego agrego estos registros a la cola temporal de cambios del join
							\While{HaySiguiente?(itReg)}
									\State	Encolar(infoJ.Rcambios, $\langle Siguiente(itReg), NomTab,  False\rangle$) \complejidad{O(L)}
									\State Avanzar(itReg)\complejidad{O(1)}
							\EndWhile
					\EndIf
			\EndWhile
	\EndIf
	\State	Habiendo actualizado las colas temporales de los joins con los 
	\State registros que cumplen con el criterio de borrado
	\State de los joins correspondientes.
	\State	Elimino del conjunto de registros, aquellos que cumplen el criterio de borrado.
	\State	Siendo n la cantidad de registros de t y T la cantidad de tablas en la base
	\State	En peor caso con costo O(n)
	\State	borrarRegistro(r, $T\_$actual)						\complejidad{O(T*L + n)}
	\If{CantidadDeAccesos(T) $\>$b.TablaMaxima.\#Modif}
			\State	b.TablaMaxima.NomTabla $\larr$ Copiar(Nombre(T)) \complejidad{O(L)}
			\State	b.TablaMaxima.\#Modif $\larr$ Copiar(CantidadDeAccesos(T))\complejidad{O(1)}
	\EndIf
}{O(T + Log(n))}

\algoritmo{generarVistaJoin}{in t1: string, in t2: string, in c: campo, in/out b: estr}{}{
	\State	Cola(DatoCambio) Rcambio $vacia()$
	\State	Campo campoJ $\larr$
	\State	Tipo campoT $\larr$ tipoCampo(c, Ta1)
	\State	DiccTrie(string; itConj(registro))  JoinS $\larr$ Vacio()
	\State	DiccNat(nat; itConj(registro)) JoinN  $\larr$ Vacio()
	\State	Conj(Registro) JoinC $\larr$ vacio() \complejidad{O(1)}
      								
	\State	Tabla Ta1 $\larr$	Obtener(b.tablas, t1).Tactual		\complejidad{O(1)}
	\State	Tabla Ta2 $\larr$	Obtener(b.tablas, t2).Tactual		\complejidad{O(1)}
	\State	Nat n $\larr$Cardinal(Registros(Ta1))\complejidad{O(1)}
	\State	Nat m $\larr$Cardinal(Registros(Ta2))\complejidad{O(1)}
	\State	Conj(dato) cjd1$\larr$dameColumna(c, Registros(Ta1)) \complejidad{O(nLog(n))}
	\State	Conj(dato) cjd2$\larr$dameColumna(c, Registros(Ta2)) \complejidad{O(mLog(m))}
	\State	Ahora busco la interseccion de estos datos entre los conjuntos cjd1 y cjd2
	\State	ItConj(dato) itcjd1 $\larr$ CrearIt(cjd1) \complejidad{O(1)}
	\State	DiccString(String, bool) ds $\larr$ vacio() \complejidad{O(1)}
	\State	DiccNat(Nat, bool) dn $\larr$ vacio()\complejidad{O(1)}
	\State	Conj(Dato) cjD $\larr$ vacio()
	\State	Cargo los valores de t1 en un dicc que depende del tipo del campo c
	\If{$\neg$campoT} \complejidad{O(1)}
		\State El tipo del campo es string
		\While{HaySiguiente?(itcjd1)} \complejidad{O(n)}
			\State Sabemos que el dameColumna no tiene valores repetidos
	     	\State Definir(ds, ValorString(Siguiente(itcjd1)), true)\complejidad{O(1)}
			\State Avanzar(itcjd1)\complejidad{O(1)}
		\EndWhile	
		\State	ItConj(dato) itcjd2 $\larr$ CrearIt(cjd2) \complejidad{O(1)}	
		\State	Ahora buscamos la interseccion
		\While{HaySiguiente?(itcjd2)} \complejidad{O(m)}
			\State Sabemos que el dameColumna no tiene valores repetidos
			\State Bool Def $\larr$ Definido?(ds, ValorString(Siguiente(itcjd2)))\complejidad{O(1)}
			\If{Def}
				AgregarRapido(cjD, Siguiente(itcjd2))\complejidad{O(1)}
		     \EndIf
			\State	Avanzar(itcjd1)\complejidad{O(1)}
		\EndWhile	
	\Else
		\State El tipo del campo es nat
		\While{HaySiguiente?(itcjd1)} \complejidad{O(n*log(n))}
			\State Sabemos que el dameColumna no tiene valores repetidos
	     	\State Definir(dn, ValorNat(Siguiente(itcjd1)), true)\complejidad{O(Log(n))}
			\State Avanzar(itcjd1)\complejidad{O(1)}
		\EndWhile	
		\State	ItConj(dato) itcjd2 $\larr$ CrearIt(cjd2) \complejidad{O(1)}	
		\State	Ahora buscamos la interseccion
		\While{HaySiguiente?(itcjd2)} \complejidad{O(m*Log(n))}
			\State Sabemos que el dameColumna no tiene valores repetidos
			\State Bool Def $\larr$ Definido?(dn, ValorString(Siguiente(itcjd2)))\complejidad{O(log(n))}
			\If{Def}
				AgregarRapido(cjD,Siguiente(itcjd2))\complejidad{O(1)}
		     \EndIf
			\State	Avanzar(itcjd2)\complejidad{O(1)}
		\EndWhile
	\EndIf
	\State Si hay algun valor en la interseccion, con esos valores hago el join.
	\If{$\neg$Vacio?(cjD)}\complejidad{O(1)}
		\State Caso Strings
		\State its $\larr$ CrearIt(cjD) \complejidad{O(1)}
		\While{HaySiguiente?(its)} \complejidad{O((n+m)*(L+Log(n*m)))}
			\State	Registro regModelo $\larr$ Definir(vacio(), c, Siguiente(its))
			\State	Como el campo es clave en ambas tablas
			\State	Si en ambas tablas hay indice en base a c y la complejidad es 
			\State	O(L+Log(n*m)) sino es O(cardinal de registros de la tabla)
			\State	Asumimos que es el mejor caso para la complejidad.
			\State Registro r1 Siguiente(cj1) $\larr$ BuscarEnTabla(regModelo, ta1)\complejidad{O(L+Log(n*m))}
			\State Registro r2 Siguiente(cj1) $\larr$ BuscarEnTabla(regModelo, ta1)\complejidad{O(L+Log(n*m))}
			\If{$\neg$campoT}
				\State itConj(Registro) itnuevo AgregarRapido(JoinC, UnirRegistros(r1, r2))\complejidad{O(1)}
				\State Definir(JoinS, ValorString(Siguiente(its)), itnuevo)\complejidad{O(1)}
			\Else
				\State itConj(Registro) itnuevo AgregarRapido(JoinC, UnirRegistros(r1, r2))\complejidad{O(1)}
				\State Definir(JoinN, ValorNat(Siguiente(its), itnuevo)\complejidad{O(Log(n+m))}
			\EndIf
			\State Avanzar(its)\complejidad{O(1)}
		\EndWhile
	\EndIf
	\State info\_join $\larr$ $<Rcambios, campoJ, campoT, JoinS, JoinN, JoinC>$\complejidad{O(1)}
	\State Definir(Ta1.Joins, t2, info\_join)\complejidad{O(1)}
	\State Definir(Ta2.Joins, t1, info\_join)\complejidad{O(1)}
}{O(1)}
%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%
%	% Vemos si existe un indice en ambas tablas para c
%	\If{Pertenece?(Indices(T\_actual1), c) $\land$ Pertenece?(Indices(T\_actual1), c)} \complejidad{O(1)}
%			\State	ind1 $\larr$ Obtener(T\_actual1.Indices, c)  \complejidad{O(calcular)}
%			\If{tipoCampo(T\_actual1, c)} \complejidad{O(1)}
%					\State	ConjNat(Nat) cjNat $\larr$ vacio() \complejidad{O(1)}
%					\State	itvalores $\larr$ CrearIt(ind1.PorNat.DiccClaves) 
%					\While{HaySiguiente(itvalores)}
%							\State	Registro r $\larr$ Obtener(ind1.PorNat, Siguiente(itvalores))
%							\State	Nat n $\larr$ ValorNat(Obtener(r, c))
%							\If{$\neg$ Pertenece?(cjNat, n)}
%									\State	AgregarRapido(cjNat, r)
%							\EndIf
%							\State	Avanzar(itvalores)
%					\EndWhile
%					\State	ind2 $\larr$ Obtener(T\_actual2.Indices, c)		
%					\State	itvalores $\larr$ CrearItConjNat(ind2.PorNat.DiccClaves)
%					\While{HaySiguiente(itvalores)}
%							\State	Registro r $\larr$ Obtener(ind2.PorNat, Siguiente(itvalores))
%							\State	Nat n $\larr$ ValorNat(Obtener(r, c))
%							\If{$\neg$ Pertenece?(cjNat, n)}
%									\State	AgregarRapido(cjNat, r)
%							\EndIf
%							\State	Avanzar(itvalores)
%					\EndWhile
%%					\While{HaySiguiente(itvalores)}
%%							\State	r1 $\larr$ Obtener(ind1.PorNat, Siguiente(itvalores))
%%							\State	r2	$\larr$ Obtener(ind2.PorNat, Siguiente(itvalores))
%%							\State	cj1 $\larr$ AgregarRapido(vacio(), r1)
%%							\State	cj2 $\larr$ AgregarRapido(vacio(), r2)
%%							\State	nuevor $\larr$ combinarRegistros(c, cj1, cj2)
%%							\State	AgregarRapido(Join,DameUno(nuevor))
%%							\State	Avanzar(itvalores)
%%					\EndWhile
%			\Else
%					\State	itvalores $\larr$ CrearItConjString(ind1.PorString.DiccClaves)
%					\While{HaySiguiente(itvalores)}
%							\State	r1 $\larr$ Obtener(ind1.PorString, Siguiente(itvalores))
%							\State	r2	$\larr$ Obtener(ind2.PorString, Siguiente(itvalores))
%							\State	cj1 $\larr$ AgregarRapido(vacio(), r1)
%							\State	cj2 $\larr$ AgregarRapido(vacio(), r2)
%							\State	nuevor $\larr$ combinarRegistros(c, cj1, cj2)
%							\State	AgregarRapido(Join, DameUno(nuevor))
%							\State	Avanzar(itvalores)
%					\EndWhile
%			\EndIf
%	\Else
%			\State	cjr1 $\larr$ T\_actual1.registros
%			\State	cjr2 $\larr$ T\_actual1.registros
%			\State	Join$\larr$combinarRegistros(c, cjr1,cjr2)
%	\EndIf
%	\State info\_join $\larr$ $\langle 0, vacio(), vacio(), c, tipoCampo(T\_actual1, c), Join\rangle$
%	\State Definir(b.Joins,	$\langle t1, t2\rangle$ , info\_join)


\algoritmo{borrarJoin}{in t1: string, in t2: string, in/out b: estr}{}{
	\State Tabla tab1 $\larr$ DameTabla(t1, b)
	\State Tabla tab2 $\larr$ DameTabla(t2, b)
	\State Borrar(tab1.Joins, t2)
	\State Borrar(tab2.Joins, t1)
}{O(1)}


% \operacion{buscar}{in criterio: registro, in t: string, in b: base}{res: conj(registro)}
% {t$\in$tablas(b)}
% {$res \igobs tablaMaxima(t\,b)$}
% {Retorna ...}
% {O($calcular$)}
% {Se retorna el nombre de la tabla por referencia.}
\algoritmo{buscar}{in criterio: registro, in t: string, in b: base}{res: conj(ItConj(registro))}{
	\State	Busco los datos de la tabla.
	\State	info\_tabla infot $\larr$ Significado(b.tablas, t) \complejidad{O(1) por ref}
	\State	Tabla tab $\larr$ infot.TActual \complejidad{O(1) por ref}
	\State	res $\larr$ BuscarEnTabla(criterio, tab) 
}{O(1)}





\algoritmo{registros}{in t: string, in b: base}{res: Conj(registros)}{
  \State $info \larr Significado(b.tablas, t) $ \complejidad{O(1)}
  \State $tab \larr info.TActual $ \complejidad{O(1)}
  \State $res \larr registros(tab) $ \complejidad{O(1)}
}{O(1)}


\algoritmo{vistaJoin}{in t1: string, in t2: string, in/out b: estr}{}{
	\State	info$\_$tabla	infot1 $\larr$ Significado(b.Tablas, t1)\complejidad{O(1) por ref}
	\State	Tabla	tab1 $\larr$ infot1.TActual	\complejidad{O(1) por ref}
	\State	info$\_$tabla	infot2 $\larr$ Significado(b.Tablas, t1)\complejidad{O(1) por ref}
	\State	Tabla	tab2 $\larr$ infot2.TActual	\complejidad{O(1) por ref}
	\State	info$\_$join	infoj $\larr$ Significado(infot1.Joins, t2) \complejidad{O(1) por ref}
	\State	Campo c $\larr$ infoj.campoJ \complejidad{O(1) por ref}
	\If{$\neg$EsVacia?(infoj.Rcambios)} \complejidad{O(1)}
		\State	Hubo cambios desde la generacion del join o del ultimo vistaJoin
		\While{$\neg$EsVacia?(infoj.Rcambios)}
				\State	DatoCambio data $\larr$ Proximo(infoj.Rcambios) \complejidad{O(1)}
				\State	Desencolar(infoj.Rcambios) \complejidad{O(1) por ref}
				\State	Registro r $\larr$ data.Reg \complejidad{O(1) por ref}
				\If{data.Accion}
					\State 	La accion es agregar un registro al join
					\State 	Para hacer esto necesito saber a que tabla se agrego el registro
					\State 	NombreTabla NomTorigen $\larr$ data.NomOrigen \complejidad{O(1) por ref}
					\State 	Sabiendo la tabla de origen, necesito identificar la otra tabla para ver si
					\State 	hay un registro con el mismo valor para el campo del join.
					\State	Armo un registro auxiliar regModelo con el campo
					\State	Dicc(campo,dato) regModelo $\larr$ vacio()
					\State	Definir(regModelo, c, Significado(r, c))
					\State	Si hay indice en la tabla para el campo c y ademas es campo clave
					\State	BuscarEnTabla(tab, regModelo) tiene complejidad O(L) u O(Log(n))
					\State	dependiendo del tipo del campo c.
					\State	Si no hay indice para el campo c entonces BuscarEnTabla(tab, regModelo)
					\State	tiene complejidad O(m) siendo m la cant de registros en tab.
					\State 	Registro rotro $\larr$ vacio()
					\If{NomTorigen=t1}
						\State	Entonces el otro registro lo tengo que buscar en t2
						\State	Registro rotro $\larr$ Siguiente(BuscarEnTabla(tab2, regModelo))
					\Else
						\State	Entonces el otro registro lo tengo que buscar en t1
						\State	Registro rotro $\larr$ Siguiente(BuscarEnTabla(tab1, regModelo))
					\EndIf
					\If{$\neg$Vacio?(rotro)}
						\State Si habia un registro que cumplia con lo pedido
						\State	Registro rnuevo $\larr$ UnirRegistros(r, rotro)
						\If{info$\_$join.campoT}
							\State	El tipo del campo es Natural.
							\State	itConj(registro) itnew $\larr$ AgregarRapido(info$\_$join.JoinC, rnuevo)
							\State	Definir(info$\_$join.JoinN, key, itnew)
						\Else
							\State	El tipo del campo es String.
							\State	itConj(registro) itnew $\larr$ AgregarRapido(info$\_$join.JoinC, rnuevo)
							\State	Definir(info$\_$join.JoinS, key, itnew)
						\EndIf
					\EndIf
				\Else	CasoBorrado
					\If{info$\_$join.campoT}
						\State	El tipo del campo es Natural.
						\State	itConj(registro) itcjr $\larr$ Significado(info$\_$join.JoinN, key)
						\State	Borrar(info$\_$join.JoinN, key)
						\State	EliminarSiguiente(itcjr)
					\Else
						\State	El tipo del campo es String.
						\State	itConj(registro) itcjr $\larr$ Significado(info$\_$join.JoinN, key)
						\State	Borrar(info$\_$join.JoinS, key)
						\State	EliminarSiguiente(itcjr)
					\EndIf
				\EndIf
		\EndWhile
	\EndIf
	\State res $\larr$ info$\_$join.JoinC
}{O(Tamaño(infoj.Rcambios)*)}

\algoritmo{cantidadDeAccesos}{in t: string, in b: base}{res: nat}{
  \State $info \larr Significado(b.tablas, t) $ \complejidad{O(1)}
  \State $tab \larr info.TActual $ \complejidad{O(1)}
  \State $res \larr cantidadDeAcccesos(tab) $ \complejidad{O(1)}
}{O(1)}

\algoritmo{tablaMaxima}{in b: base}{res: string}{
  \State $res \larr b.TablaMaxima.NomTabla $ \complejidad{O(1)}  
}{O(1)}
