
%\section{Pos es tupla(x:Nat, y:Nat)}

%\section{Tipo es Bool}

\section{NombreTabla es String}

\section{Base de Datos}

\subsection{Interfaz}

\sexc{Base}
$\textbf{usa}$  
\generos{nat, string, tabla, regisro, campo, dato}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Operaciones}


%%%%%% observadores basicos %%%%%%

\operacion{tablas}{in b: base }{res : ItConjString(NombreTabla)}
 {true}
 {$res \igobs nombre(t)$}
 {Devuelve el nombre de la tabla ingresada por parametro.}
 {O($1$)}
 {Se retorna res por copia, por ser un tipo basico.}

\operacion{dameTabla}{in b: base }{res : tabla}
 {true}
 {$res \igobs claves(t)$}
 {Devuelve un conjunto de campos que son claves en la tabla ingresada por parametro.}
 {O($1$)}
 {Se devuelve un iterador al conjunto claves por referencia.}
 
\operacion{hayJoin?}{in t1: string, in t2: string, in t: base }{res : bool}
 {true}
 {$res \igobs indices(t)$}
 {Devuelve un conjunto de los indices de la tabla ingresada por parametro.}
 {O($calcular$)}
 {Se devuelve res por referencia y no es modificable.}
 
\operacion{campoJoin}{in t1: string, in t2: string, in t: base }{res : itConjTrie(campo)}
 {true}
 {$res \igobs campos(t)$}
 {Devuelve un conjunto a los campos de la tabla ingresada por parametro.}
 {O($1$)}
 {Se devuelve res por referencia.}

% %%%%%% generadores %%%%%%%
 
 \operacion{nuevaDB}{}{res : base}
 {$True$}
 {$res \igobs nuevaDB()$}
 {Crea una base sin tablas.}
 {O($calcular$)}
 {}

 \operacion{agregarTabla}{in t: tabla, in b: base}{}
 {$b\_0$=b $\land$ nombre(t)$\notin$ tablas(b) $\land$ Vacio?(t.registros)}
 {agregarTabla(t\,$b\_0$)}
 {Agrega una tabla a la base de datos.}
 {O($calcular$)}
 {Agrega tabla por referencia.} 
 
 \operacion{insertarEntrada}{in reg: registro, in t: string, in b: base}{}
 {$b\_0$=b $\land$ t$\in$tablas(b) $\yluego$ puedoInsertar?(dameTabla(t)\, reg)}
 {insertarEntrada(r\,t \,$b\_0$)}
 {Inserta el registro a la tabla que corresponde al string pasado por parametro.}
 {O($calcular$)}
 {} 
 
  \operacion{borrar}{in cr: registro, in t: string, in b: base}{}
 {$b\_0$=b $\land$ t$\in$tablas(b) $\land$ \#(cr.DiccClaves)}
 {borrar(cr\, t\, $b\_0$)}
 {Borra los registros que cumplan el criterio cr pasado por parametro.}
 {O($calcular$)}
 {} 	

  \operacion{generarVistaJoin}{in t1: string, in t2: string, in c: campo, in b: base}{}
 {b\_0=b $\land$ t1$\sqsupset$t2 $\land$ \{t1, t2\}$\subseteq$tablas(b) $\yluego$ (c$\in$dameTabla(t1, b).diccClaves $\land$ c$\in$dameTabla(t2, b).diccClaves $\land$ $\neg$hayJoin?(t1, t2, b)}
 {generarVistaJoin(cr, t, $b\_0$)}
 {Borra los registros que cumplan el criterio cr pasado por parametro.}
 {O($calcular$)}
 {} 	
 
   \operacion{borrarJoin}{in t1: string, in t2: string, in b: base}{}
 {$b\_0$=b $\land$ hayJoin?(t1\, t2\, b)}
 {borrarJoin(t1\, t2\, $b\_0$)}
 {Borra correspondiente a los nombres de tablas, pasados por parametro.}
 {O($calcular$)}
 {}

%%%%%%% Otras Operaciones %%%%%%%%%%%

 \operacion{registros}{in t: string, in b: base}{res: conj(registro)}
 {t$\in$tablas(b)}
 {$res \igobs registros(t\, b)$}
 {Retorna el conjunto de registros correspondientes al nombre de tabla pasado por parametro}
 {O($calcular$)}
 {Se retorna el conjunto de registros por referencia.} 


 \operacion{vistaJoin}{in t1: string, in t2: string, in b: base}{res: conj(registro)}
 {\{t1\, t2\}$\subseteq$tablas(b) $\land$ hayJoin?(t1\,t2\,b)}
 {$res \igobs vistaJoin(t1\, t2\, b)$}
 {Retorna el conjunto de registros correspondientes al nombre de tabla pasado por parametro}
 {O($calcular$)}
 {Se retorna el conjunto de registros por referencia.} 

 \operacion{cantidadDeAccesos}{in t: string, in b: base}{res: nat}
 {t$\in$tablas(b)}
 {$res \igobs cantidadDeAccesos(t\,b)$}
 {Retorna la cantidad de modificaciones correspondientes al nombre de tabla pasado por parametro.}
 {O($calcular$)}
 {Se retorna res por referencia.} 

 \operacion{tablaMaxima}{in b: base}{res: string}
 {$\neg\emptyset$?(tablas(b))}
 {$res \igobs tablaMaxima(t\,b)$}
 {Retorna el nombre de la tabla con la mayor cantidad de modificaciones.}
 {O($calcular$)}
 {Se retorna el nombre de la tabla por referencia.} 
  
 \operacion{encontrarMaximo}{in t: string, in ct: conj(string), in b: base}{res: string}
 {\{t\}$\cup$ct $\subseteq$tablas(b)}
 {$res \igobs tablaMaxima(t\,b)$}
 {Retorna ...}
 {O($calcular$)}
 {Se retorna el nombre de la tabla por referencia.}
  
 \operacion{buscar}{in criterio: registro, in t: string, in b: base}{res: conj(registro)}
 {t$\in$tablas(b)}
 {$res \igobs tablaMaxima(t\,b)$}
 {Retorna ...}
 {O($calcular$)}
 {Se retorna el nombre de la tabla por referencia.}
  
 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Representación}

\serc{Base}
{
\donde{estr}{
\tupla{TablaMaxima: Tmax, Tablas: DiccTrie(NombreTabla; info\_tabla)}}
		\donde{info\_tabla}{\tupla{TActual: tabla, Joins: DiccTrie(NombreTabla; info\_join)}}
      	\donde{info\_join}{\tupla{
      								Rcambios: Cola(DatoCambio),
      								campoJ: campo, 
      								campoT: tipo,
      								JoinS: DiccTrie(string; itConj(registro)),
      								JoinN: DiccNat(nat; itConj(registro)),
      								JoinC: Conj(registro)}}
		\donde{Tmax}{\tupla{NomTabla: NombreTabla, $\#$Modif: Nat}}
		\donde{DatoCambio}{\tupla{Reg: Registro, NomOrigen: NombreTabla, Accion: Bool}}
}

\subsubsection*{Invariante de representación}

\begin{enumerate}
  \item El Nombre de la tabla es un String acotado.
  \item Indices es un arreglo de tamaño 2, que aloja el Indice correspondiente segun el orden de creacion.
  \item Para toda Dato que es clave en Indice, su significado llamemoslo sign esta incluido en Registros.
  \item 

\end{enumerate}


\subsubsection*{Función de abstracción}
%\abs{sistema}{CampusSeguro}{s}{cs}
%$s.campus \igobs campus(cs)$ $\land$ \\
%$s.estudiantes \igobs estudiantes(cs)$ $\land$ \\
%$s.hippies \igobs hippies(cs)$ $\land$ \\
%$s.agentes \igobs agentes(cs)$ $\land$ \\
%$((\paratodo{nombre}{n}) s.hippies.definido(n) \impluego s.hippies.obtener(n) \igobs posEstYHippie(n,cs)$ $\lor$ \\
%$(\paratodo{nombre}{n}) s.estudiantes.definido(n) \impluego s.estudiantes.obtener(n) \igobs posEstYHippie(n,cs))$ \\
%$(\paratodo{placa}{pl}) s.agentes.definido(pl) \impluego s.estudiantes.obtener(pl).pos \igobs posAgente(pl,cs))$ \\
%$(\paratodo{placa}{pl}) s.agentes.definido(pl) \impluego s.estudiantes.obtener(pl).cantSanciones \igobs cantSanciones(pl,cs))$ \\
%$(\paratodo{placa}{pl}) s.agentes.definido(pl) \impluego s.estudiantes.obtener(pl).cantCapturas \igobs cantCapturas(pl,cs))$ \\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\subsection{Algoritmos}

\algoritmo{tablas}{in b: estr}{res: ConjTrie(string)}{
  \State $res \larr b.tablas.DiccClaves $ \complejidad{O(1)}
}{O(1)}

\algoritmo{hayJoin?}{in t1: string, in t2: string, in b: estr}{res: bool}{
	\State   res $\larr$Definido?(Obtener(b, t1).Joins,t2) $\larr$ Definido?(Obtener(b, t2).Joins,t1)
}{O(1)}

\algoritmo{campoJoin}{in t1: string, in t2: string, in b: estr}{res: campo}{
		\State res$\larr$ Obtener(Obtener(b, t1).Joins, t2).campoJ
}{O(1)}

%%%%%%%%%%%%% generadores %%%%%%%%%%%%%
\algoritmo{nuevaDB}{}{res: estr)}{ 
	\State String s
	\State Nat n $\larr$ 0
  	\State res $\larr$ $\langle \langle s, 0 \rangle, vacio()\rangle$  \complejidad{O(1)} 
}{O(1)}

\algoritmo{agregarTabla}{in t: tabla, in/out b: estr}{}{
	\State	info\_tabla $\larr$ $\langle t.cantidadDeAccesos, t, vacio()\rangle$  \complejidad{O(1)}
	\State	Definir(b.tablas, nombre(t), info\_tabla)								 \complejidad{O(1)}
}{O(1)}

\algoritmo{insertarEntrada}{in reg: registro, in t: string, in/out b: estr}{}{
	\State	Obtenemos la tabla es O(1) porque su nombre esta acotado.
	\State	info\_tabla infoT $\larr$	Obtener(b.tablas, t).TActual		\complejidad{O(1) Por referencia}
	\State	Agrego el registro a la tabla. \complejidad{O(1)}
	\State	Tabla T $\larr$ infoT.TActual \complejidad{O(1)}
	\State	agregarRegistro(reg, T)								\complejidad{O(1)}
	\State	Ahora si hay Joins actualizo la informacion temporal de cada Join.
	\If{$\neg\emptyset$?(infoT.Joins)} \complejidad{O(1)}
				\State	ItConjString(String) itNomTab $\larr$ CrearIt(Claves(infoT.Joins))\complejidad{O(1)}
				\While{HaySiguiente?(itNomTab)}								\complejidad{O(1)}
					\State	info\_join infoJ $\larr$ Obtener(infoT.Joins, Siguiente(NomTab)) \complejidad{O(1)}
					\State	Encolar(infoJ.Rcambios, $\langle reg, Siguiente(NomTab),  true\rangle$) \complejidad{O(L)}
					\State	Encolar es O(L) porque se copia un registro con su cantidad de campos acotada
					\State	y los valores string copiarlos tiene costo O(L), siendo L el valor string mas largo.
					\State	Avanzar(itClaves)\complejidad{O(1)}
				\EndWhile
	\EndIf
	\If{CantidadDeAccesos(T) $\>$b.TablaMaxima.\#Modif}
			\State	b.TablaMaxima.NomTabla $\larr$ Copiar(Nombre(T)) \complejidad{O(L)}
			\State	b.TablaMaxima.\#Modif $\larr$ Copiar(CantidadDeAccesos(T))\complejidad{O(1)}
	\EndIf
}{O(T*L + Log(n)) siendo n la cantidad de registros en t.}














\algoritmo{borrar}{in cr: registro, in t: string, in/out b: estr}{}{
	\State info\_tabla infoT $\larr$	Obtener(b.tablas, t).TActual		\complejidad{O(1) por ref}
	\State	 Tabla T $\larr$ infoT.TActual \complejidad{O(1) por ref}
	\State NombreTabla NomTab $\larr$ NombreTabla(T)

	\State La eliminacion en primera etapa depende de si hay
	\State	 joins con la tabla pasada por parametro
	\If{$\neg\emptyset$?(Claves(infoT.Joins))} \complejidad{O(1)}
			\State Creo el iterador, para navegar los nombres de tablas con los que tiene Join
			\State itNom $\larr$ CrearIt(Claves(infoT.Joins)) \complejidad{O(1)}
			\While{HaySiguiente?(itNom)} \complejidad{O(Cant de tablas)}
					\State info\_join infoJ $\larr$ Siguiente(itNom) \complejidad{O(1)}
					\State Verifico si el Join esta creado en base al 
					\State campo del cr pasado por parametro.
					\If{infoJ.campoJ=DameUno(Campos(cr))} \complejidad{O(1)}
							\State	Entonces solo actualizo la cola temporal del join
							\State	Registro reg $\larr$ Buscar(cr, T) \complejidad{O(L + Log(n))}
							\State	Encolar(infoJ.Rcambios, $\langle reg, Siguiente(itNom),  False\rangle$)\complejidad{O(L)}
					\Else
							\State	Si el campo del criterio de borrado, es distinto que el campo del Join.
							\State	Primero busco que registros coinciden con el criterio
							\State	en el peor caso con complejidad O(cantidad de registros de t) sin indices.
							\State	Conj(Registro) cjc $\larr$ Buscar(cr, T)\complejidad{O(L + Log(n))}
																						% Coincidencias(cr, Registros(r))
							\State	ItConj(Registro) itReg $\larr$ CrearIt(cjc)
							\State	Luego agrego estos registros a la cola temporal de cambios del join
							\While{HaySiguiente?(itReg)}
									\State	Encolar(infoJ.Rcambios, $\langle Siguiente(itReg), NomTab,  False\rangle$) \complejidad{O(L)}
									\State Avanzar(itReg)\complejidad{O(1)}
							\EndWhile
					\EndIf
			\EndWhile
	\EndIf
	\State	Habiendo actualizado las colas temporales de los joins con los 
	\State registros que cumplen con el criterio de borrado
	\State de los joins correspondientes.
	\State	Elimino del conjunto de registros, aquellos que cumplen el criterio de borrado.
	\State	Siendo n la cantidad de registros de t y T la cantidad de tablas en la base
	\State	En peor caso con costo O(n)
	\State	borrarRegistro(r, $T\_$actual)						\complejidad{O(T*L + n)}
	\If{CantidadDeAccesos(T) $\>$b.TablaMaxima.\#Modif}
			\State	b.TablaMaxima.NomTabla $\larr$ Copiar(Nombre(T)) \complejidad{O(L)}
			\State	b.TablaMaxima.\#Modif $\larr$ Copiar(CantidadDeAccesos(T))\complejidad{O(1)}
	\EndIf
}{O(T*L + n)}

\algoritmo{generarVistaJoin}{in t1: string, in t2: string, in c: campo, in/out b: estr}{}{
	\State	Join $\larr$ vacio()
	\State	T\_actual1 $\larr$	Obtener(b.tablas, t1).Tactual		\complejidad{O(1)}
	\State	T\_actual2 $\larr$	Obtener(b.tablas, t2).Tactual		\complejidad{O(1)}
	% Vemos si existe un indice en ambas tablas para c
	\If{Pertenece?(Indices(T\_actual1), c) $\land$ Pertenece?(Indices(T\_actual1), c)} \complejidad{O(1)}
			\State	ind1 $\larr$ Obtener(T\_actual1.Indices, c)  \complejidad{O(calcular)}
			\If{tipoCampo(T\_actual1, c)}
					\State	ConjNat(Nat) cjNat $\larr$ vacio()
					\State	itvalores $\larr$ CrearItConjNat(ind1.PorNat.DiccClaves)
					\While{HaySiguiente(itvalores)}
							\State	Registro r $\larr$ Obtener(ind1.PorNat, Siguiente(itvalores))
							\State	Nat n $\larr$ ValorNat(Obtener(r, c))
							\If{$\neg$ Pertenece?(cjNat, n)}
									\State	AgregarRapido(cjNat, r)
							\EndIf
							\State	Avanzar(itvalores)
					\EndWhile
					\State	ind2 $\larr$ Obtener(T\_actual2.Indices, c)		
					\State	itvalores $\larr$ CrearItConjNat(ind2.PorNat.DiccClaves)
					\While{HaySiguiente(itvalores)}
							\State	Registro r $\larr$ Obtener(ind2.PorNat, Siguiente(itvalores))
							\State	Nat n $\larr$ ValorNat(Obtener(r, c))
							\If{$\neg$ Pertenece?(cjNat, n)}
									\State	AgregarRapido(cjNat, r)
							\EndIf
							\State	Avanzar(itvalores)
					\EndWhile
%					\While{HaySiguiente(itvalores)}
%							\State	r1 $\larr$ Obtener(ind1.PorNat, Siguiente(itvalores))
%							\State	r2	$\larr$ Obtener(ind2.PorNat, Siguiente(itvalores))
%							\State	cj1 $\larr$ AgregarRapido(vacio(), r1)
%							\State	cj2 $\larr$ AgregarRapido(vacio(), r2)
%							\State	nuevor $\larr$ combinarRegistros(c, cj1, cj2)
%							\State	AgregarRapido(Join,DameUno(nuevor))
%							\State	Avanzar(itvalores)
%					\EndWhile
			\Else
					\State	itvalores $\larr$ CrearItConjString(ind1.PorString.DiccClaves)
					\While{HaySiguiente(itvalores)}
							\State	r1 $\larr$ Obtener(ind1.PorString, Siguiente(itvalores))
							\State	r2	$\larr$ Obtener(ind2.PorString, Siguiente(itvalores))
							\State	cj1 $\larr$ AgregarRapido(vacio(), r1)
							\State	cj2 $\larr$ AgregarRapido(vacio(), r2)
							\State	nuevor $\larr$ combinarRegistros(c, cj1, cj2)
							\State	AgregarRapido(Join, DameUno(nuevor))
							\State	Avanzar(itvalores)
					\EndWhile
			\EndIf
	\Else
			\State	cjr1 $\larr$ T\_actual1.registros
			\State	cjr2 $\larr$ T\_actual1.registros
			\State	Join$\larr$combinarRegistros(c, cjr1,cjr2)
	\EndIf
	\State info\_join $\larr$ $\langle 0, vacio(), vacio(), c, tipoCampo(T\_actual1, c), Join\rangle$
	\State Definir(b.Joins,	$\langle t1, t2\rangle$ , info\_join)

}{O(1)}

\algoritmo{borrarJoin}{in t1: string, in t2: string, in/out b: estr}{}{
	\If{Pertenece?(b.Joins, $\langle t1, t2\rangle$  )}
			\State	Borrar(b.Joins, $\langle t1, t2\rangle$ )
	\Else
			\If{Pertenece?(b.Joins, $\langle t2, t1\rangle$ )}
					\State	Borrar(b.Joins, $\langle t2, t1\rangle$)
			\EndIf
	\EndIf
}{O(1)}


% \operacion{buscar}{in criterio: registro, in t: string, in b: base}{res: conj(registro)}
% {t$\in$tablas(b)}
% {$res \igobs tablaMaxima(t\,b)$}
% {Retorna ...}
% {O($calcular$)}
% {Se retorna el nombre de la tabla por referencia.}
\algoritmo{buscar}{in criterio: registro, in t: string, in b: base}{res: conj(ItConj(registro))}{
	\State	Busco los datos de la tabla.
	\State	info\_tabla infot $\larr$ Significado(b.tablas, t) \complejidad{O(1) por ref}
	\State	Tabla tab $\larr$ infot.TActual \complejidad{O(1) por ref}
	\State	res $\larr$ BuscarEnTabla(criterio, tab) 
}{O(1)}

\newpage
\algoritmo{vistaJoin}{in t1: string, in t2: string, in/out b: estr}{}{
	\State	info$\_$tabla	infot1 $\larr$ Significado(b.Tablas, t1)\complejidad{O(1) por ref}
	\State	Tabla	tab1 $\larr$ infot1.TActual	\complejidad{O(1) por ref}
	\State	info$\_$tabla	infot2 $\larr$ Significado(b.Tablas, t1)\complejidad{O(1) por ref}
	\State	Tabla	tab2 $\larr$ infot2.TActual	\complejidad{O(1) por ref}
	\State	info$\_$join	infoj $\larr$ Significado(infot1.Joins, t2) \complejidad{O(1) por ref}
	\State	Campo c $\larr$ infoj.campoJ \complejidad{O(1) por ref}
	\If{$\neg$EsVacia?(infoj.Rcambios)} \complejidad{O(1)}
		\State	Hubo cambios desde la generacion del join o del ultimo vistaJoin
		\While{$\neg$EsVacia?(infoj.Rcambios)}
				\State	DatoCambio data $\larr$ Proximo(infoj.Rcambios) \complejidad{O(1)}
				\State	Desencolar(infoj.Rcambios) \complejidad{O(1) por ref}
				\State	Registro r $\larr$ data.Reg \complejidad{O(1) por ref}
				\If{data.Accion}
					\State 	Si es True entonces la accion es agregar un registro al join
					\State 	Para hacer esto necesito saber a que tabla se agrego el registro
					\State 	NombreTabla NomTorigen $\larr$ data.NomOrigen \complejidad{O(1) por ref}
					\State 	Sabiendo la tabla de origen, necesito identificar la otra tabla para ver si
					\State 	hay un registro con el mismo valor para el campo del join.
					\State	Armo un registro auxiliar regModelo con el campo
					\State	Dicc(campo,dato) regModelo $\larr$ vacio()
					\State	Definir(regModelo, c, Significado(r, c))
					\State	Si hay indice en la tabla para el campo c y ademas es campo clave
					\State	BuscarEnTabla(tab2, regModelo) tiene complejidad O(L) u O(Log(n))
					\State	dependiendo del tipo del campo c.
					\State	Si no hay indice para el campo c entonces BuscarEnTabla(tab2, regModelo)
					\State	tiene complejidad O(n+m)
					\If{NomTorigen=t1}
						\State	Entonces el otro registro lo tengo que buscar en t2
						\State	Registro rotro $\larr$ Siguiente(BuscarEnTabla(tab2, regModelo))
					\Else
						\State	Entonces el otro registro lo tengo que buscar en t1
						\State	Registro rotro $\larr$ Siguiente(BuscarEnTabla(tab1, regModelo))
					\EndIf
					\State	Registro rnuevo $\larr$ UnirRegistros(r, rotro)
					\If{info$\_$join.campoT}
						\State	El tipo del campo es Natural.
						\State	itConj(registro) itnew $\larr$ AgregarRapido(info$\_$join.JoinC, rnuevo)
						\State	Definir(info$\_$join.JoinN, key, itnew)
					\Else
						\State	El tipo del campo es String.
						\State	itConj(registro) itnew $\larr$ AgregarRapido(info$\_$join.JoinC, rnuevo)
						\State	Definir(info$\_$join.JoinS, key, itnew)
					\EndIf
				\Else	CasoBorrado
					\If{info$\_$join.campoT}
						\State	El tipo del campo es Natural.
						\State	itConj(registro) itcjr $\larr$ Significado(info$\_$join.JoinN, key)
						\State	Borrar(info$\_$join.JoinN, key)
						\State	EliminarSiguiente(itcjr)
					\Else
						\State	El tipo del campo es String.
						\State	itConj(registro) itcjr $\larr$ Significado(info$\_$join.JoinN, key)
						\State	Borrar(info$\_$join.JoinS, key)
						\State	EliminarSiguiente(itcjr)
					\EndIf
				\EndIf
		\EndWhile
	\EndIf
	\State res $\larr$ info$\_$join.JoinC
}{O(1)}
%	
%	
%	
%	
%		\State	Hubo cambios desde la generacion del join o del ultimo vistaJoin
%		\State	DatoCambio data $\larr$ Proximo(infoj.Rcambios) \complejidad{O(1)}
%		\State	Desencolar(infoj.Rcambios) \complejidad{O(1) por ref}
%		\State	Registro r $\larr$ data.Reg \complejidad{O(1) por ref}
%		\State	NombreTabla NomTorigen $\larr$ data.NomOrigen \complejidad{O(1) por ref}
%		\State	Bool valAccion $\larr$ data.Accion \complejidad{O(1) por ref}
%		\State	Si data.Accion es True entonces es un agregado de reg,
%		\State	caso contrario si data.Accion es False es un borrado de reg.
%		\If{infoj.campoT} 
%			\State	Caso Natural
%				\State	Dicc(Nat, itConj(registro)) d $\larr$ info$\_$join.JoinN\complejidad{O(1) por ref}
%				\State	Nat key $\larr$ ValorNat(Obtener(r, c))\complejidad{O(Log(n)) por ref}
%				\If{valAccion}
%					\State	Caso agrego un registro que no figura en el join
%					\State	Entonces como se que hay un Indice por ambas tablas,
%					\State	tengo que buscar el registro con el mismo valor de campo clave
%					\State	en la otra tabla.
%					\State	Pregunto que en que tabla tengo que hacer la busqueda. 
%					\State	Armo un registro auxiliar regAux con el campo
%					\State	Dicc(campo,dato) regModelo $\larr$ vacio()
%					\State	Definir(regModelo, c, Significado(r, c))
%						\If{NomTorigen=t1}
%							\State	Entonces el otro registro lo tengo que buscar en t2
%							\If{Pertenece?(Indices(tab1), c) $\land$ Pertenece?(Indices(tab2), c)} \complejidad{O(1)}
%									\State	Registro rotro $\larr$ Siguiente(BuscarEnTabla(tab2, regModelo))
%						\Else
%								\State	Entonces el otro registro lo tengo que buscar en t1
%								\State	Registro rotro $\larr$ Siguiente(BuscarEnTabla(tab1, regModelo)
%						\EndIf
%					\State	Registro rnuevo $\larr$ UnirRegistros(r, regModelo)
%					\State	itConj(registro) itnew $\larr$ AgregarRapido(info$\_$join.JoinC, rnuevo)
%					\State	Definir(info$\_$join.JoinN, key, itnew)
%				\Else	CasoBorrado
%					\State	itConj(registro) itcjr $\larr$ Significado(info$\_$join.JoinN, key)
%					\State	Borrar(info$\_$join.JoinN, key)
%					\State	EliminarSiguiente(itcjr)
%				\EndIf
%			\EndIf
%		\Else
%			\State	Caso String
%			\If{$\neg$EsVacia?(infoj.Rcambios)} \complejidad{O(1)}
%				\State	Hubo cambios desde la generacion del join o del ultimo vistaJoin
%				\State	DatoCambio data $\larr$ Proximo(infoj.Rcambios) \complejidad{O(1)}
%				\State	Desencolar(infoj.Rcambios) \complejidad{O(1) por ref}
%				\State	Registro r $\larr$ data.Reg \complejidad{O(1) por ref}
%				\State	NombreTabla NomTorigen $\larr$ data.NomOrigen \complejidad{O(1) por ref}
%				\State	Bool valAccion $\larr$ data.Accion \complejidad{O(1) por ref}
%				\State	Si data.Accion es True entonces es un agregado de reg,
%				\State	caso contrario si data.Accion es False es un borrado de reg.
%				\State	Dicc(Nat, itConj(registro)) d $\larr$ info$\_$join.JoinN\complejidad{O(1) por ref}
%				\State	String key $\larr$ ValorString(Obtener(r, c))\complejidad{O(L) por ref}
%				\If{valAccion} Caso Agregar
%					\State	Caso agrego un registro que no figura en el join
%					\State	Entonces como se que hay un Indice por ambas tablas,
%					\State	tengo que buscar el registro con el mismo valor de campo clave
%					\State	en la otra tabla.
%					\State	Armo un registro auxiliar regAux con el campo
%					\State	Registro regModelo $\larr$ vacio()
%					\State	Definir(regModelo, c, Significado(r, c))
%					\State	Pregunto que en que tabla tengo que hacer la busqueda. 
%					\If{NomTorigen=t1}
%						\State	Entonces el otro registro lo tengo que buscar en t2
%						\State	Registro rotro $\larr$ Siguiente(BuscarEnTabla(tab2, regModelo))
%					\Else
%						\State	Entonces el otro registro lo tengo que buscar en t1
%						\State	Registro rotro $\larr$ Siguiente(BuscarEnTabla(tab1, regModelo)
%					\EndIf
%					\State	Registro rnuevo $\larr$ UnirRegistros(r, regModelo)
%					\State	itConj(registro) itnew $\larr$ AgregarRapido(info$\_$join.JoinC, rnuevo)
%					\State	Definir(info$\_$join.JoinS, key, itnew)
%				\Else	CasoBorrado
%					\State	itConj(registro) itcjr $\larr$ Significado(info$\_$join.JoinS, key)
%					\State	Borrar(info$\_$join.JoinS, key)
%					\State	EliminarSiguiente(itcjr)
%				\EndIf
%			\EndIf
%		\EndIf
%	\Else
%		\State	Caso: No se cuenta con la existencia de indices en ambas tablas, en base al campo del join
%		\State	Entonces hay que recorrer todo el 
%		\State	Hubo cambios desde la generacion del join o del ultimo vistaJoin
%		\State	DatoCambio data $\larr$ Proximo(infoj.Rcambios) \complejidad{O(1)}
%		\State	Desencolar(infoj.Rcambios) \complejidad{O(1) por ref}
%		\State	Registro r $\larr$ data.Reg \complejidad{O(1) por ref}
%		\State	NombreTabla NomTorigen $\larr$ data.NomOrigen \complejidad{O(1) por ref}
%		\State	Bool valAccion $\larr$ data.Accion \complejidad{O(1) por ref}
%		\State	Si data.Accion es True entonces es un agregado de reg,
%		\State	caso contrario si data.Accion es False es un borrado de reg.
%		\State	Dicc(Nat, itConj(registro)) d $\larr$ info$\_$join.JoinN\complejidad{O(1) por ref}
%		\State	String key $\larr$ ValorString(Obtener(r, c))\complejidad{O(Log(n)) por ref}
%		\If{valAccion}
%		
%	\EndIf


%\algoritmo{campos}{in t:tab}{res:itConjTrie(campo)}{
%  \State $res \larr CrearItConjTrie(t.Campos.ClavesDicc)$ \complejidad{O(1)}
%}{O(1)} % en otras operaciones tiene q figurar ese conjunto
%
%\algoritmo{tipoCampo}{in c:campo, in t:tab}{res:Tipo}{
%  \State $res \larr Significado(t.Campos,c)$ \complejidad{O(1)}
%}{O(1)}
%
% \algoritmo{registros}{in t:tab}{res:itConj(registro)}{
%    \State $res \larr CrearItConj( t.registros )$ \complejidad{$\theta$(L+ log(n))}
% }{$\theta$(L+ log(n))}
%
%  \algoritmo{cantDeAccesos}{in t:tab}{res:nat}{
%    \State $res \larr t.cantDeAccesos$ \complejidad{$\theta$(1)}
% }{$\theta$(1)}
%
%  \algoritmo{puedoInsertar?}{in r:registro, in t:tab}{res:bool}{
%    \State res $\larr$ campatible(r,t) $\land$ $\neg$hayCoincidencia(r,claves(r),registros(t))  \complejidad{$\theta$(L+log(n))}
% }{$\theta$(L+log(n))}
%
%
%  \algoritmo{compatible}{in r:registro, int t:tab}{res:bool}{
%      \State res $\larr$ campatible(r,t) $\yluego$ mismosTipos(r,t)  \complejidad{$\theta$(1)}
% }{O($1$)}
%
%
%  \algoritmo{puedeIndexar}{in c:campo, in t:tab}{res:bool}{
%      \State res  $\larr $ Definido?(t.campos,c) $\yluego \neg$ Esta?(c,t.Indices.IndicesL) $\land$ \\ (long(t.Indices.IndicesL)=0 $\lor$ (long(t.Indices.IndicesL)$<$2 $\land$ \\ (tipoCampo(c,t)!=tipoCampo(t.Indices.IndicesL.primero,t))))    \complejidad{$\theta$(1)} %funcion axuliar hayIndiceC?(c,t)
% }{O(calcular)}
% 
%
%  \algoritmo{combinarRegistros}{in c:campo, in cr1:Conj(registro), in cr2:Conj(registro)}{res:Conj(registros)}{
%  	\State	res $\larr$ vacio();
%	\State	itcr1 $\larr$ CrearItConjTrie(cr1)
%  	\State 	\While{HaySiguiente(itcr1)}
%				\State	AgregarRapido(res, combinarTodos(c,Siguiente(itcr1),cr2));	%combinarTodos deberia hacer por copia asi no afecta el original.
%				\State	Avanzar(itcr1);
%	\State 	\EndWhile   
% }{O(calcular)}
% 
%   \algoritmo{hayCoincidencia}{in r:registro, in cc:ConjTrie(campo), in cr:Conj(registro)}{res:bool}{
%  	\State	itcr $\larr$ CrearItConj(cr);
%    \State	res $\larr$ false;
%  	\State 	\While{HaySiguiente(itcr)}
%				\State	res $\larr$ 	coincideAlguno(r,cc,Siguiente(itcr)) $\lor$res;
%				\State	Avanzar(itcr);
%	\State 	\EndWhile   
% }{O(calcular)}
%
% \algoritmo{coincidencias}{in crit:registro, in cr:Conj(registro)}{res:itConj(registro)}{
%  	\State 	res $\larr$ CrearItConj(vacio());
%  	\State 	\While{HaySiguiente(cr)}
%				\State	\If {coincidenTodos(crit,campos(crit),Siguiente(cr))} 
%								\State	AgregarAtras(res,Siguiente) 
%				\State	\EndIf				
%				\State	Avanzar(cr);
%	\State	\EndWhile   
% }{O(calcular)}
% 
%  \algoritmo{minimo}{in c:campo, in t:tab}{res:dato}{
%  	\State 	res $\larr$ min( dameColumna(  c, t.registros  );
% }{O(calcular)}
% 
%   \algoritmo{maximo}{in c:campo, in t:tab}{res:dato}{
%  	\State 	res $\larr$ max( dameColumna(  c,  t.registros  );
% }{O(calcular)}
% 
%    \algoritmo{dameColumna}{in c:campo, in cr:Conj(registro)}{res:itConj(dato)}{
%  	\State 	itcr $\larr$ CrearItConj(cr);
%  	\State 	res $\larr$ CrearItConj(vacio());
%  	\State 	\While{HaySiguiente(itcr)}
%				\State	\If {Definido?(Siguiente(itcr),c)} 
%								\State	AgregarAtras(res,Obtener(Siguiente(itcr), c)) ;
%				\State	\EndIf				
%				\State	Avanzar(itcr);
%	\State	\EndWhile     	
% }{O(calcular)}
% 
%    \algoritmo{mismosTipos}{in r:registro, in t:tab}{res:bool}{
%  	\State 	res $\larr$ True;
%  	\State 	itconjClaves $\larr$ CrearItConj(claves(r)); 
%  	\State 	\While{HaySiguiente(itconjClaves)}
%					\State	res $\larr$ res$\land$(tipo?(Obtener(r,Siguiente(itconjClaves))) = tipoCampo(Siguiente(itconjClaves)),t)	;
%					\State	Avanzar(cr);
%	\State	\EndWhile     	
% }{O(calcular)}
%
%
%  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\subsection{Algoritmos operaciones auxiliares}
%\algoritmo{agregarEstudiante}{in/out campus:campusSeguro, in pos:pos, in nombre:nombre}{}{
%    \State $campus.campus[pos.x][pos.y].hayEst \larr True$ \complejidad{O(1)}
%    \State $campus.campus[pos.x][pos.y].estudiante \larr definir(campus.estudiantes, nombre, pos)$ \complejidad{O(long(nombre))}
%}{O(long(nombre))}
%
%\algoritmo{agregarHippie}{in/out campus:campusSeguro, in pos:pos, in nombre:nombre}{}{
%    \State $campus.campus[pos.x][pos.y].hayHippie \larr True$ \complejidad{O(1)}
%    \State $campus.campus[pos.x][pos.y].hippie \larr definir(campus.hippies, nombre, pos)$ \complejidad{O(long(nombre))}
%}{O(long(nombre))}
%
%
% \algoritmo{sancionarAgentesVecinos}{in/out campus:campusSeguro, in pos:pos}{}{
%    % Sancionar VECINOS
%    \State $vecinos \larr campus.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
%    \If {$campus.atrapadoPorAgente?(pos)$} 
%       \While {$i < vecinos.tamanio()$}  \complejidad{O(1)}
%           \If {$campus.campus[vecinos[i].x][vecinos[i].y].hayAgente?$}
%               \State $campus.sancionarAgente(vecinos[i].agente)$ \complejidad{O(1)}
%           \EndIf
%           \State $i++$
%       \EndWhile
%    \EndIf
% }{O(1)}
%
%\algoritmo{sancionarAgentesEncerrandoEstVecinos}{in/out campus:campusSeguro, in pos:pos}{}{
%   \State $vecinos \larr campus.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
%   \State $i \larr 0$
%   \While {$i < vecinos.tamanio$} \complejidad{O(1)}
%      \If {$campus.campus[vecinos[i].x][vecinos[i].y].hayEst$ $\land$ $atrapadoPorAgente?(campus,pos)$}  \complejidad{O(1)}
%          \State $sancionarAgentesVecinos(campus,pos)$ \complejidad{O(1)}
%      \EndIf
%      \State $i++$
%    \EndWhile
%}{O(1)}
%
%\algoritmo{sancionarAgente}{in/out campus:campusSeguro, in/out agente:itDiccRapido}{}{
%    \State $campus.conKSanciones.ocurrioSancion \larr True$ \complejidad{O(1)}
%    \State $agente.siguiente.cantSanciones + 1$ \complejidad{O(1)}
%    \State $agente.siguiente.miUbicacion.eliminarSiguiente()$ \complejidad{O(1)}
%    \State // El iterador mismas apunta a la posicion correspondiente del agente dentro de la lista ordenada por cantSanciones
%    \State // Como la lista en el peor caso puede contener a todos los agentes con igual cant de sanciones
%    \State // la mayor cantidad posible de iteraciones del ciclo es 4
%    \While {$agente.siguiente.mismcampus.haySiguiente()$ \\$\land$ $agente.siguiente.mismas.siguiente.cantSanciones < agente.siguiente.cantSanciones$}
%      \State $agente.siguiente.mismas.avanzar()$ \complejidad{O(1)}
%    \EndWhile
%    \State // Si no hay siguiente o  si la cantidad de sanciones del siguiente es menor que la del agente, entonces, 
%    \State // creo un conMismasBucket, lo inserto como siguiente y me guardo el iterador en miUbicacion
%    \State // Sino, agrego el agente al conj de agentes del siguiente y me guardo el iterador en miUbicacion
%    \If {$\neg(agente.siguiente.mismas.haySiguiente)$ $\lor$
%        \\$(agente.siguiente.mismas.haySiguiente \land$\\$agente.siguiente.cantSanciones=agente.siguiente.mismas.cantSanciones)$} \complejidad{O(1)}
%      \State $nConMismasB \larr nuevaTupla(CrearNuevoDiccLineal(), agente.siguiente.cantSanciones)$
%      \State $agente.siguiente.mismas \larr agente.siguiente.mismas.agregarComoSiguiente(nConMismasB)$ \complejidad{O(1)}
%      \State $agente.siguiente.miUbicacion$ $\larr$
%      \State $agente.siguiente.mismas.siguiente.agentes.agregarComoSiguiente(agente.siguiente.pl)$ \complejidad{O(1)}
%    \Else 
%      \State $agente.siguiente.mismas.siguiente.agentes.agregarComoSiguiente(agente.siguiente.pl)$ \complejidad{O(1)}
%    \EndIf
%}{O(1)}
%
% \algoritmo{atrapadoPorAgente?}{in campus:campusSeguro, in pos:pos}{res:bool}{
%    \State $vecinos \larr campus.campusEstatico.vecinos(pos)$
%    \State $alMenos1Agente \larr False$ \complejidad{O(1)}
%    \State $i \larr 0$
%    \If {$\neg(encerrado?(pos, campus.campusEstatico.vecinos(pos)))$}
%      \State $return$ $false$
%    \EndIf
%    \State // Veo si hay algun agente alrededor
%     \While {$i<vecinos.tamanio()$} \complejidad{O(1)}
%       \If {$as.campus[vecinos[i].x][vecinos[i].y].hayAgente?$}
%          \State $return$ $true$            
%        \EndIf
%        \State $i++$ \complejidad{O(1)}
%    \EndWhile
% }{O(1)}
%
% \algoritmo{hippificarEstudiantesVecinos}{in/out campus:campusSeguro, in pos:pos}{}{
%    \State $vecinos \larr campus.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
%    \State $i \larr 0$ \complejidad{O(1)}
%    \While {$i<vecinos.tamanio()$} \complejidad{O(long(nombre))}
%        \If {$estAHippie?(campus,vecinos[i])$}
%            \State $hippificar(campus,vecinos[i])$ \complejidad{O(long(nombre))}
%        \EndIf
%        \State $i++$ \complejidad{O(1)}
%    \EndWhile
% }{O(long(nombre))}
%
%\algoritmo{hippificar}{in/out campus:campusSeguro, in pos:pos}{}{
%    \State // PRE: La posicion esta en el tablero y hay estudiante en la posicion
%    \State $as.campus[pos.x][pos.y].hayHippie \larr True$ \complejidad{O(1)}
%    \State $as.campus[pos.x][pos.y].hippie.agregarComoSiguiente(nombre, pos)$ \complejidad{O(long(nombreEstudiante))}
%    \State $as.campus[pos.x][pos.y].hayEst \larr False$ \complejidad{O(1)}
%    \State $as.campus[pos.x][pos.y].estudiante.eliminarSiguiente()$ \complejidad{O(long(nombreEstudiante))}
%}{O(long(nombre))}
%
% \algoritmo{estAHippie?}{in campus:campusSeguro, in pos:pos}{res:bool}{
%    \If {$\neg(encerrado?(pos,vecinos))$}
%      \State $return$ $false$ \complejidad{O(1)}
%    \EndIf
%    \State $i$ $\larr$ $0$ \complejidad{O(1)}
%    \State $cantHippies$ $\larr$ $0$ \complejidad{O(1)}
%    \State $vecinos \larr campus.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
%    \While {$i < vecinos.tamanio()$}
%      \If {$campus[vecinos[i].x][vecinos[i].y].hayHippie$}
%        \State $cantHippies++$ \complejidad{O(1)}
%      \EndIf
%      \State $i++$
%    \EndWhile
%    \State $return$ $cantHippies \ge 2$ \complejidad{O(1)}
% }{O(1)}
%
%\algoritmo{hippieAEst?}{in campus:campusSeguro, in pos:pos}{res:bool}{
%  \State $i$ $\larr$ $0$ \complejidad{O(1)}
%  \State $vecinos \larr campus.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
%  \While {$i < vecinos.tamanio()$} \complejidad{O(1)}
%      \If {$\neg(as.campus[vecinos[i].x][vecinos[i].y].hayEst?)$}
%        \State $return$ $False$ \complejidad{O(1)}
%      \EndIf
%  \EndWhile
%  \State $return$ $True$
%}{O(1)}
%
% \algoritmo{encerrado?}{in campus:campusSeguro, in pos:pos}{}{
%    \State $vecinos \larr vecinos(as.campusEstatico, pos)$ \complejidad{O(1)}
%    \State $i \larr vecinos.tamanio()$ \complejidad{O(1)}
%    \While {$i<vecinos.tamanio()$} \complejidad{O(1)}
%       \If {$\neg(campus.campus[vecinos[i].x][vecinos[i].y].hayAgente?$ $\lor$
%             \\$campus.campus[vecinos[i].x][vecinos[i].y].hayEst?$ $\lor$
%             \\$campus.campus[vecinos[i].x][vecinos[i].y].hayHippie?$ $\lor$
%             \\$campus.campus[vecinos[i].x][vecinos[i].y].hayObst?)$} \complejidad{O(1)}
%              \State $return$ $false$ \complejidad{O(1)}
%        \EndIf
%        \State $i++$ \complejidad{O(1)}
%    \EndWhile
%    \State $return true$
% }{O(1)}
%
% \algoritmo{aplicarHippiesVecinos}{in/out campus:campusSeguro, in pos:pos}{}{
%    \State $vecinos \larr campus.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
%    \State $i \larr 0$ \complejidad{O(1)}
%    \While {$i < vecinos.tamanio()$} \complejidad{O(long(nombre))}
%       \State aplicarHippie(campus, pos) \complejidad{O(long(nombre))}
%    \EndWhile
% }{O(long(nombre))}
%
% \algoritmo{aplicarHippie}{in/out campus:campusSeguro, in pos:pos}{}{
%    \State // PRE: pos valida y hayHippie en campus.campus[pos.x][pos.y]
%    \If {$campus.campus[pos.x][pos.y].hayHippie$}
%      \If {$as.hippieAEst(pos)$} \complejidad{O(1)}
%          \State $campus:campusSeguro.campus[pos.x][pos.y].hayHippie \larr False$ \complejidad{O(1)}
%          \State $campus:campusSeguro.campus[pos.x][pos.y].hayEst \larr True$ \complejidad{O(1)}
%          \State $as.campus[pos.x][pos.y].estudiante \larr CrearIt(campus.hippies)$ \complejidad{O(1)}
%          \State $campus.campus[pos.x][pos.y].estudiante.$
%          \State $agregarComoSiguiente(campus.campus[pos.x][pos.y].estudiante.nombre)$ \complejidad{O(long(nombre))}
%          \State $campus.campus[pos.x][pos.y].hippie.eliminarSiguiente()$ \complejidad{O(long(nombre))}
%      \Else
%        \If {$campus.campus[pos.x][pos.y].hayHippie?$ $\land$ $atrapadoPorAgente(pos)$}
%            \State $vecinos \larr campus.campusSeguro.vecinos(pos)$ \complejidad{O(1)}
%            \State $i \larr 0$ \complejidad{O(1)}
%            \While {$i < vecinos.tamanio()$} \complejidad{O(1)}
%                \State $posAct \larr vecinos[pos.x][pos.y]$ \complejidad{O(1)}
%                \State $info$ $\larr$ $campus.campus[vecinos[i].x][vecinos[i].y]$ \complejidad{O(1)}
%                \If {$posAct.hayAgente$}
%                    \State $info.agente.siguiente.cantCapturas++$ \complejidad{O(1)}
%                    \State // Actualizar mas vigilante
%                    \If {$campus.masVigilante.siguienteSignificado().cantCapturas < $\\$info.agente.siguienteSignificado().cantCapturas$}
%                        \State $campus.masVigilante \larr info.agente$ \complejidad{O(1)}
%                    \Else
%                        \If{$campus.masVigilante.siguienteSignificado().cantCapturas = $\\$info.agente.siguienteSignificado().cantCapturas$\\
%                            $\land campus.masVigilante.siguienteClave() < info.agente.siguienteClave()$} \complejidad{O(1)}
%                              \State $campus.masVigilante \larr info.agente$ \complejidad{O(1)}
%                        \EndIf
%                    \EndIf
%                \EndIf
%                \State $i++$
%            \EndWhile
%            \State $campus.campus[pos.x][pos.y].hayHippie? = False$ \complejidad{O(1)}
%            \State $campus.campus[pos.x][pos.y].hippie.eliminarSiguiente()$ \complejidad{O(long(nombre))}
%        \EndIf
%      \EndIf
%    \EndIf
% }{O(long(nombre))}
%
% \algoritmo{proxPosHippie}{in/out campus:campusSeguro, in nombre:string}{res:pos}{
%    \State // PRE: El nombre es un hippie y el hippie no esta encerrado
%    \State $posHippie \larr campus.hippies.obtener(nombre)$ \complejidad{O(long(nombre))}
%    \If {$campus.estudiantes.tamanio()>0$}
%      \State // Retorna de las posiciones mas cercanas, la que esta mas cerca del (0,0)
%      \State $proxPos \larr aPosMasCercana(campus.campusEstatico,posHippie,campus.estudiantes.significados)$ \complejidad{O($N_e$)}
%    \Else
%        \State // Retorna el ingreso mas cercan, en caso de empate, el de abajo
%        \State $proxPos \larr aIngresoMasCercano(campus.campusEstatico,posHippie)$ \complejidad{$O(1)$}
%    \EndIf
%    \State $res \larr proxPos$ \complejidad{O(1)}
% }{O($N_e$)}
%
%  \algoritmo{proxPosAgente}{in/out campus:campusSeguro, in posAgente:pos}{res:pos}{
%    \State // PRE: En la posicion hay un agente que se puede mover
%    \If {$campus.hippies.tamanio()>0$}
%      \State // Retorna de las posiciones mas cercanas, la que esta mas cerca del (0,0)
%      \State $proxPos \larr aPosMasCercana(campus.campusEstatico,posAgente,campus.hippies.significados)$ \complejidad{O($N_h$)}
%    \Else
%        \State // Retorna el ingreso mas cercano, en caso de empate, el de abajo
%        \State $proxPos \larr aIngresoMasCercano(campus.campusEstatico,posAgente)$ \complejidad{$O(1)$}
%    \EndIf
%    \State $res \larr proxPos$ \complejidad{O(1)}
% }{O($N_h$)}
%
%
% \algoritmo{aIngresoMasCercano}{in p:pos, cs: campusSeguro}{res:pos}{
%	\If{$p.Y\leq c.alto/2$}
%		\If{$PosValida(cs.campus,<p.X,p.Y-1>)\land \lnot HayAlgo(cs,<p.X,p.Y-1>)$}
%			\State $res \larr <p.X,p.Y-1>$
%		\Else
%			\If{$PosValida/c,<p.X+1,p.Y>)\land \lnot HayAlgo(c,<p.X+1,p.Y>)$}
%				\State $res \larr <p.X+1,p.Y>$
%			\Else
%				\If{$PosValida/c,<p.X-1,p.Y>)\land \lnot HayAlgo(c,<p.X-1,p.Y>)$}
%					\State $res \larr <p.X-1,p.Y>$
%				\Else
%					\State $res \larr <p.X,p.Y+1>$
%				\EndIf
%			\EndIf
%		\EndIf
%	\Else
%		\If{$PosValida(cs.campus,<p.X,p.Y+1>)\land \lnot HayAlgo(cs,<p.X,p.Y+1>)$}
%			\State $res \larr <p.X,p.Y-1>$
%		\Else
%			\If{$PosValida/c,<p.X+1,p.Y>)\land \lnot HayAlgo(c,<p.X+1,p.Y>)$}
%				\State $res \larr <p.X+1,p.Y>$
%			\Else
%				\If{$PosValida/c,<p.X-1,p.Y>)\land \lnot HayAlgo(c,<p.X-1,p.Y>)$}
%					\State $res \larr <p.X-1,p.Y>$
%				\Else
%					\State $res \larr <p.X,p.Y-1>$
%				\EndIf
%			\EndIf
%		\EndIf
%	\EndIf
%}
%{O($1$)}
%
% \algoritmo{ibusquedaBinariaPorSanciones}{in ar:arreglo(val:nat otr: $\alpha$>), in sanc:nat}{res:$<\alpha , bool>$)}{
% 	\State $res.\pi_2 \larr false$
%	\State $min \larr 0$
%	\State $max \larr |ar|$
%    \While {$max-min>1$} \complejidad{O(log($|ar|$))}
%       \State $med \larr (max-min)/2$
%       \If {$ar[med].val \leq sanc$}
%       		\State $min \larr med$
%       \Else
%       		\State $max \larr med$
%       	\EndIf
%    \EndWhile
%    \If {$ar[min].val = sanc$}
%    	\State $res \larr <ar[min].otr, true>$
%    \EndIf
% }{O(log($|ar|$)}