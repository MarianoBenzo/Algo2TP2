
%\section{Pos es tupla(x:Nat, y:Nat)}

%\section{Placa es Nat}

%\section{Nombre es String}

\section{Tabla}

\subsection{Interfaz}

\sexc{tabla, DiccString(string, alfha),} {DiccNat(nat, beta),}{Nat, String, Dato, Campo, Tipo, Registro, ConjString, ConjNat.}

\generos{tabla}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Operaciones}


%%%%%% observadores basicos %%%%%%

\operacion{nombre}{in t: tab }{res : string}
 {true}
 {$res \igobs nombre(t)$}
 {Devuelve el nombre de la tabla ingresada por parametro.}
 {O($1$)}
 {Se retorna res por copia, por ser un tipo basico.}

\operacion{claves}{in t: tab }{res : Conj(campo)}
 {true}
 {$res \igobs claves(t)$}
 {Devuelve un conjunto de campos clave en la tabla ingresada por parametro.}
 {O($1$)}
 {Se devuelve res por referencia, no es modificable.}
 
\operacion{indices}{in t: tab }{res : ConjString(campo)}
 {true}
 {$res \igobs indices(t)$}
 {Devuelve un conjunto campos con los que se crearon los indices.}
 {O($1$)}
 {Se devuelve res por referencia, no es modificable.}
 
\operacion{campos}{in t: tab }{res : ConjString(campo)}
 {true}
 {$res \igobs campos(t)$}
 {Devuelve un conjunto de todos los campos de la tabla.}
 {O($1$)}
 {Se devuelve res por referencia, no es modificable.}

\operacion{tipoCampo}{in c: campo,in t: tab }{res : tipo}
 {c $\in$ campos(t)}
 {$res \igobs tipoCampo(t)$}
 {Devuelve el tipo del campo c en la tabla.}
 {O($1$)}
 {Se devuelve res por referencia, no es modificable.}
 
\operacion{registros}{in t: tab }{res : itConj(registro)}
 {true}
 {$res \igobs registros(t)$}
 {Devuelve un conjunto a los registros de la tabla.}
 {O($1$) }
 {Se devuelve res referencia.}

 
\operacion{cantidadDeAcccesos}{in t: tab }{res : nat}
 {true}
 {$res \igobs cantidadDeAccesos(t)$}
 {Devuelve la cantidad de modificaciones de la tabla ingresada por parametro.}
 {O($1$)}
 {Se devuelve res por copia.}

 
 %%%%%% generadores %%%%%%%
 
 \operacion{nuevaTabla}{in nombre: string, in claves: conjString(campo), in columnas: registro }{res : tab}
 {$\neg\emptyset$?(claves) $\land$ claves$\subseteq$campos(columnas)}
 {$res \igobs nuevaTabla(t)$}
 {Crea una tabla sin registros.}
 {O($1$)}
 {}

 \operacion{agregarRegistro}{in r: registro, in/out t: tab}{}
 {t\_0=t $\land$ campos(r)$\igobs$campos(t) $\land$ puedorInsertar?(r,t)}
 {agregarRegistro(r,t\_0)}
 {Agrega un registro a la tabla pasada por parametro.}
 {O($Log(n)$)}
 {Agrega el registro r por referencia.} 
 
 \operacion{borrarRegistro}{in crit: registro, in/out t: tab}{}
 {t\_0=t $\land$ $\#$(campos(r))=1 $\yluego$ Siguiente(CrearIt(campos(crit)))$\in$claves(t)}
 {borrarRegistro(r,t\_0)}
 {Borra los registros que cumplan el criterio pasado por parametro.}
 {O($n$)}
 {} 
 
  \operacion{indexar}{in crit: registro, in/out t: tab}{}
 {t\_0=t $\land$ puedeIndexar(c,t)}
 {indexar(c,t\_0)}
 {Crea un indice en base al campo de crit.}
 {O($n$)}
 {} 	
 
%%%%%% Otras Operaciones %%%%%%%%%%%

 \operacion{puedoInsertar?}{in r: registro, in t: tab}{res:bool}
 {$true$}
 {$res \igobs puedoInsertar?(r,t)$}
 {Informa si el registro pasado por parametro no tiene valores repetidos con respectos a los registros existentes, para los campos clave en la tabla pasada por parametro.}
 {O($n$)}
 {Retorna res por referencia, no es modificable.} 
 
  \operacion{compatible}{in r: registro, in t: tab}{res:bool}
 {$true$}
 {$res \igobs compatible(r,t)$}
 {Informa si el registro pasado por parametro tiene correspondecia en los tipos de los campos de tabla pasada por parametro.}
 {O($1$)}
 {Retorna res por referencia, no es modificable.} 
 
  \operacion{minimo}{in c: campo, in t: tab}{res:dato}
 {$\neg\emptyset$?(registro(t)) $\land$ c$\in$indices(t)}
 {$res \igobs minimo(c,t)$}
 {Retorna el minimo entre los valores de la tabla para el campo c.}
 {O($L+Log(n)$)}
 {Retorna res por referencia.}
  
  \operacion{maximo}{in c: campo, in t: tab}{res:dato}
 {$\neg\emptyset$?(registro(t)) $\land$ c$\in$indices(t)}
 {$res \igobs maximo(c,t)$}
 {Retorna el maximo entre los valores de la tabla para el campo c.}
 {O($L+Log(n)$)}
 {Retorna res por referencia.} 

  \operacion{puedeIndexar}{in c: campo, in t: tab}{res:bool}
 {$True$}
 {$res \igobs puedeIndexar(c,t)$}
 {Informa si se puede crear un nuevo indice.}
 {O($1$)}
 {Retorna res por referencia, no es modificable.}

  \operacion{coincidencias}{in r: registro, in cj: Conj(registro)}{res: Conj(ItConj(registro))}
 {$True$}
 {$res \igobs coincidencias(r,cj)$}
 {Devuelve el conjunto de registros de la tabla, que coinciden con los valores de r.}
 {O($Cardinal(cj)$)}
 {Retorna res por referencia.} 

  \operacion{hayCoincidencia}{in r: registro,in cjc: Conj(campo), in cjr: Conj(registro)}{res:bool}
 {$True$}
 {$res \igobs hayCoincidencia(r,cjc,cjr)$}
 {Retorna true si algun registro del conjunto cjr, coincide con r en todos los valores de los campos de cjc.}
 {O($Cardinal(cjr)$)}
 {Retorna res por referencia, no es modificable.} 


 \operacion{combinarRegistros}{in c: campo,in cj1: Conj(registro), in cj2: Conj(registro)}{$\hfill \hfill \hfill \hfill \hfill \hfill \hfill$
 res: conj(registro)}
 {$True$}
 {$res \igobs combinarRegistros(c,cj1,cj2)$}
 {Combina los valores de los registros para el campo dado por parametro.}
 {O($Cardinal(cj1)+Cardinal(cj2)$)}
 {Retorna res por referencia, es modificable.}

  \operacion{dameColumna}{in c: campo, in cj: Conj(registro)}{res: Conj(dato)}
 {$True$}
 {$res \igobs dameColumna(c,cj1,cj2)$}
 {Reune en un conjunto los valores del campo pasado por parametro.}
 {O($\#cr *log(\#cr) + (\#cr *long(k)) $)}
 {Retorna res por referencia, no es modificable.} 

  \operacion{mismosTipos}{in r: registro,in t: tab}{res: bool}
 {campos(r)$\subseteq$campos(t)}
 {$res \igobs mismosTipos(r,t)$}
 {Compara los tipos correspondientes a los campos del registro y la tabla.}
 {O($1$)}
 {Retorna res por referencia, no es modificable.} 
\newpage
 %%%%%%% AUXILIARES
 \operacion{BuscarEnTabla}{in c: campo,in t: tab}{res: Conj(ItConj(registro))}
 {c$\subseteq$campos(t)}
 {$res \igobs BuscarEnTabla(c, t)$}
 {}
 {O($O(L+Log(n))$)}
 {Retorna res por referencia, es modificable.} 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Representación}

\serc{Tabla}
{\donde{tab}
{ 
\tupla{
  		Nombre: NombreTabla,
		Registros: Conj(Registro),
		Campos: \mbox{DiccString(Campo,Tipo)},
		Claves: \mbox{Conj(Campo)},
		IndiceS: \tupla{CampoI: campo, EnUso: bool, Indice: DiccString(\mbox{string, Conj(ItConj(Registro)))}, Min: Dato, Max: Dato},
		IndiceN: \tupla{CampoI: campo, EnUso: bool, Indice: DiccNat(\mbox{nat, Conj(ItConj(Registro)))}, Min: Dato, Max: Dato},
		RelacionInd: \tupla{CampoR: campo, ConsultaN: DiccNat(\mbox{nat, Acceso)}), ConsultaS: DiccString(\mbox{string, Acceso)})}
		,\#Accesos: Nat}
		\donde{Acesso}{$<$S: ItConj(ItConj(Registro)),N: ItConj(ItConj(Registro))$>$}
}
}

\subsubsection*{Invariante de representación}

\begin{enumerate}
% $Las claves estan en los campos.$
\item	t.Claves esta inclido o es igual a t.Campos.
% 
\item	t.Nombre es un string acotado.
% Los campos de cada registro es igual a los campos de la tabla.
\item	Para todo registro r de t.Registros, entonces Campos(r) es igual al t.Campos.
% Los campos de cada registro, tienen el mismo tipo que los campos de la tabla.
\item	Para todo registro r de t.Registros y para todo campo c de Campos(r), entonces \\
Tipo?(Significado(r,c)) es igual Significado(t.Campos, c).

% Si el indice esta EnUso y tiene un campo que pertenece a t.Campos, para toda clave c de t.IndiceS.Indice, el significado de Significado(t.IndiceS.Indice, c) esta incluido en t.Registro.
\item	Si t.IndiceS.EnUso es true y t.IndiceS.CampoI pertenece a t.Campos, para todo string d, \\
si Definido?(t.IndiceS.Indice, d) es true, entonces para todo itConj(registro) it que pertenece a \\
el conj(ItConj(registro)) cj Significado(t.IndiceS.Indice, d), registro r $\larr$Siguiente(it), \\
r pertenece a t.Registros.

% Todo registro de la tabla pertenece a algun significado de t.IndiceS.Indice
\item	Si t.IndiceS.EnUso es true y t.IndiceS.CampoI pertenece a t.Campos, \\
entonces para todo registro R de t.Registros entonces \\
Definido?(t.IndiceS.Indice, Significado(r, t.IndiceS.CampoI)) es true, \\
entonces algun ItConj(registro) it que pertenece a \\
Conj(itConj()) cj Significado(t.IndiceS.Indice, Significado(r, t.IndiceS.CampoI)) entonces Siguiente(it)=R.

% Si el indice esta EnUso y tiene un campo que pertenece a t.Campos, para toda clave c de t.IndiceS.Indice, el significado de Significado(t.IndiceS.Indice, c) esta incluido en t.Registro.
\item	Si t.IndiceN.EnUso es true y t.IndiceN.CampoI pertenece a t.Campos, para todo string d, \\
si Definido?(t.IndiceN.Indice, d) es true, entonces para todo itConj(registro) it que pertenece a \\
el conj(ItConj(registro)) cj Significado(t.IndiceS.Indice, d), registro r $\larr$Siguiente(it), \\
r pertenece a t.Registros.

% Todo registro de la tabla pertenece a algun significado de t.IndiceS.Indice
\item	Si t.IndiceN.EnUso es true y t.IndiceN.CampoI pertenece a t.Campos, \\
entonces para todo registro R de t.Registros entonces \\
Definido?(t.IndiceN.Indice, Significado(r, t.IndiceN.CampoI)) es true, \\
entonces algun ItConj(registro) it que pertenece a \\
Conj(itConj()) cj Significado(t.IndiceN.Indice, Significado(r, t.IndiceN.CampoI)) entonces Siguiente(it)=R.


%		RelacionInd: \tupla{CampoR: campo, ConsultaN: DiccNat(\mbox{nat, Acceso)}),
%														  ConsultaS:DiccString(\mbox{string, Acceso)})}
%		\donde{Acesso}{< S: ItConj(ItConj(Registro)),N: ItConj(ItConj(Registro)) >}
\item El campo de e.RelacionInd.CampoR pertenece a t.claves
%		Caso String
\item Si t.IndiceS.EnUso es true y para todo string X, $\neg$tipoCampo(t.campo, e.RelacionInd.CampoR) \\y 
Definido?(t.RelacionInd.ConsultaS, X), tal que \\Acceso dataInd $\larr$Significado(t.RelacionInd.ConsultaN, Y), \\
y el registro R $\larr$Siguiente(Siguiente(dataInd.S)), entonces R pertenece a t.registros $\yluego$ \\
ValorString(Significado(R, t.RelacionInd.campoR))=Y
\item Si t.IndiceN.EnUso es true y para todo nat Y, $\neg$tipoCampo(t.campo, e.RelacionInd.CampoR) \\y Definido?(t.RelacionInd.ConsultaN, Y), tal que el
\\Acceso dataInd $\larr$Significado(t.RelacionInd.ConsultaN, Y), \\
y el registro R $\larr$Siguiente(Siguiente(dataInd.N)), entonces R pertenece a t.registros $\yluego$ \\
ValorString(Significado(R, t.RelacionInd.campoR))=Y
%		Caso Natural
\item Si t.IndiceS.EnUso es true y para todo nat Y, tipoCampo(t.campo, e.RelacionInd.CampoR) \\y Definido?(t.RelacionInd.ConsultaN, Y), tal que el\\
 Acceso dataInd $\larr$Significado(t.RelacionInd.ConsultaN, Y), \\
 y el registro R $\larr$Siguiente(Siguiente(dataInd.S)), entonces R pertenece a t.registros $\yluego$ \\
 ValorString(Significado(R, t.RelacionInd.campoR))=Y
\item Si t.IndiceN.EnUso es true y para todo nat Y, tipoCampo(t.campo, e.RelacionInd.CampoR) \\y Definido?(t.RelacionInd.ConsultaN, Y), tal que el\\
 Acceso dataInd $\larr$Significado(t.RelacionInd.ConsultaN, Y), \\
 y el registro R $\larr$Siguiente(Siguiente(dataInd.N)), entonces R pertenece a t.registros $\yluego$ \\
 ValorString(Significado(R, t.RelacionInd.campoR))=Y

%		Cantidad de accesos
\item El valor de e.\#Accesos debe ser la cantidad de registros agregados, la cantidad de registros borrados
\end{enumerate}

\subsubsection*{Función de abstracción}
\abs{tab}{Tabla}{s}{t}
$s.Nombre \igobs nombre(t)$ $\land$ $s.Claves \igobs claves(t)$ $\land$ \\
$s.Indices \igobs indices(t)$ $\land$ 
$s.Registros \igobs registros(t)$ $\land$ 
$DiccClaves(s.Campos) \igobs campos(t)$ $\land$ 
$s.\#Accesos \igobs cantidadDeAccesos(t)$ $\land$ \\
$((\paratodo{campo}{c}) Definido?(s.Campos, c) \impluego Significado(s.Campos, c) \igobs tipoCampo(c, t))$ \\
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\subsection{Algoritmos}

\algoritmo{nombre}{in t:tab}{res:string}{
  \State $res \larr t.Nombre$ \complejidad{O(1) por ref}
}{O(1) por ref}

\algoritmo{claves}{in t:tab}{res:Conj(campo)}{
  \State res $\larr$ t.Claves \complejidad{O(1) por ref}
}{O(1) por ref}

\algoritmo{indices}{in t:tab}{res:ConjString(campo)}{
  \State	ConjString(campo) res $\larr$ vacio();\complejidad{O(1) por ref}
  \If{t.IndiceS.EnUso}\complejidad{O(1) por ref}
		\State AgregarRapido(res, t.IndiceS.CampoI) \complejidad{O(1) por ref}
  \EndIf
  \If{t.IndiceN.EnUso}\complejidad{O(1) por ref}
		\State AgregarRapido(res, t.IndiceN.CampoI) \complejidad{O(1) por ref}
  \EndIf
}{O(1) por ref}

\algoritmo{campos}{in t:tab}{res:ConjString(campo)}{
  \State $res \larr DiccClaves(t.Campos)$ \complejidad{O(1) por ref}
}{O(1) por ref} % en otras operaciones tiene q figurar ese conjunto

\algoritmo{tipoCampo}{in c:campo, in t:tab}{res:Tipo}{
  \State $res \larr Significado(t.Campos, c)$ \complejidad{O(1) por ref}
}{O(1) por ref}

 \algoritmo{registros}{in t:tab}{res:Conj(registro)}{
    \State $res \larr t.registros $ \complejidad{O(1) por ref}
	\State Se retorna el conjunto por referencia
 }{O(1) por ref }

  \algoritmo{cantDeAccesos}{in t:tab}{res:nat}{
    \State $res \larr t.cantDeAccesos$ \complejidad{O(1) por ref}
 }{O(1) por ref}
 
 %%%%%%%%%%%%% generadores
 
\newpage
\algoritmo{nuevaTabla}{in nombre: string, in claves: conj(campo), in columnas: registro}{res: tab}{
	\State Conj(registro) Registros $\larr$ Vacio() \complejidad{O(1) por ref}
	\State DiccString(campo, tipo) Campos $\larr$ Vacio() \complejidad{O(1) por ref}
	\State Campo c $\larr$Siguiente(CrearIt(claves))
	\State Dato d $\larr$ Obtener(columnas, Siguiente(CrearIt(claves)))
	\State IndiceS $\larr <  c, False, Vacio(), d, d  >$ 		\complejidad{O(1) por ref}
	\State IndiceN $\larr <  c, False, Vacio(), d, d  >$ 		\complejidad{O(1) por ref}
	\State \#Acessos $\larr$ 0 \complejidad{O(1) por ref}
	\State RelacionInd $\larr$ $< c, Vacio(), Vacio() >$
	\State res $   \larr <  nombre, Registros, Campos, claves, IndiceS, IndiceN, RelacionInd, 0  >$\complejidad{O(1) por ref}
	%Agrego los campos al diccString
	\State itcampos $\larr$ crearIt(Campos(columnas)) 				\complejidad{O(\# de campos)}
	\While{HaySiguiente(itcampos)}										\complejidad{O(\# de campos)}
					\State	Dato valor $\larr$ Significado(columnas, Siguiente(itcampos)) \complejidad{O(L)}
					\State	Definir(res.Campos, Siguiente(itcampos), Tipo?(valor)) \complejidad{O(1) por ref}
					\State	Avanzar(itcampos) \complejidad{O(1) por ref}
	\EndWhile 
	\State Donde L es la longitud del valor string mas largo.
 }{O((\#(campos(columnas))*L) }
 
\newpage
\algoritmo{agregarRegistro}{in r: registro, in/out t: tab}{}{
	\State Para poder acceder al registro en el conj en O(1) por ref, guardo el iterador al elemento
    \State itConj(Registro) nuevo $\larr$ AgregarRapido(t.Registros,r)	\complejidad{O(1) por ref}
    \State t.\#Accesos++																	\complejidad{O(1) por ref}
	\State Este registro debe ser indexado, si algun indice esta en uso.
	\If{t.IndiceS.EnUso $\land$ t.IndiceN.EnUso}
		\State Dato valorS	$\larr$	Significado(r, t.IndiceS.CampoI) \complejidad{O(L)}
		\State Dato valorN	$\larr$	Significado(r, t.IndiceN.CampoI) \complejidad{O(Log(n))}		
		\State Bool DefinidoS $\larr$Definido?(t.IndiceS.Indice, ValorString(valorS))\complejidad{O(1)}
		\State Bool DefinidoN $\larr$Definido?(t.IndiceN.Indice, ValorNat(valorN))\complejidad{O(Log(n))}
		\If{$\neg$DefinidoS $\land$ $\neg$DefinidoN} \complejidad{O(1)}
			\State Ambos no estan definidos
			\State cjS $\larr$ vacio()\complejidad{O(1) por ref}
			\State cjN $\larr$ vacio()\complejidad{O(1) por ref}
			\State newS $\larr$AgregarRapido(cjS, nuevo)		 \complejidad{O(1) por ref}	
			\State newN $\larr$AgregarRapido(cjN, nuevo)			\complejidad{O(1) por ref}
			\State Definir(t.IndiceS.Indice, ValorString(valorS), cjS)\complejidad{O(1) por ref}
			\State Definir(t.IndiceN.Indice, ValorString(valorN), cjN)\complejidad{O(Log(n)) por ref}
		\Else
			\If{DefinidoS $\land$ $\neg$DefinidoN}\complejidad{O(1)}
				\State cjS $\larr$ Significado(t.IndiceS.Indice, ValorString(valorS)) \complejidad{O(1)}
				\State cjN $\larr$ vacio()\complejidad{O(1)}
				\State newS $\larr$AgregarRapido(cjS, nuevo)			 \complejidad{O(1)}
				\State newN $\larr$AgregarRapido(cjN, nuevo)			\complejidad{O(1)}
				\State Definir(t.IndiceN.Indice, ValorNat(valorN), cjN)\complejidad{O(Log(n)) por ref}
			\Else
				\If{$\neg$DefinidoS $\land$ DefinidoN}\complejidad{O(1)}
					\State cjN $\larr$ Significado(t.IndiceN.Indice, ValorNat(valorN)) \complejidad{O(Log(n))}
					\State cjS $\larr$ vacio() \complejidad{O(1)}
					\State newS $\larr$AgregarRapido(cjS, nuevo)		\complejidad{O(1)}	
					\State newN $\larr$AgregarRapido(cjN, nuevo)			\complejidad{O(1)}
					\State Definir(t.IndiceS.Indice, ValorString(valorS), cjS) \complejidad{O(1) por ref}
				\Else
					\State Caso en que esta definido en los dos indices
					\State cjN $\larr$ Significado(t.IndiceN.Indice, ValorNat(valorN)) \complejidad{O(Log(n))}
					\State cjS $\larr$ Significado(t.IndiceS.Indice, ValorString(valorS)) \complejidad{O(1)}
					\State newS $\larr$AgregarRapido(cjS, nuevo)			\complejidad{O(1) por ref}
					\State newN $\larr$AgregarRapido(cjN, nuevo)			\complejidad{O(Log(n)) por ref}
				\EndIf
			\EndIf
		\EndIf
		\If{t.IndiceS.Min $>$ valorS} \complejidad{O(L)}
			\State t.IndiceS.Min $\larr$ valorS\complejidad{O(1) por ref}
		\EndIf
		\If{valorS $>$ t.IndiceS.Max}\complejidad{O(L)}
			\State t.IndiceS.Max $\larr$ valorS\complejidad{O(1) por ref}
		\EndIf	
		\If{t.IndiceN.Min $>$ valorN} \complejidad{O(1) por ref}
			\State t.IndiceN.Min $\larr$ valorN\complejidad{O(1) por ref}
		\EndIf
		\If{valorN $>$ t.IndiceN.Max}\complejidad{O(1) por ref}
			\State t.IndiceN.Max $\larr$ valorN\complejidad{O(1) por ref}
		\EndIf	
	\Else
		\If{t.IndiceS.EnUso $\land$ $\neg$t.IndiceN.EnUso}
			\State Obtengo de r el valor del campo con el que se creo el indice.
			\State Dato valor	$\larr$	Significado(r, t.IndiceS.CampoI) \complejidad{O(L)}
			\State Bool Def $\larr$Definido?(t.IndiceS.Indice, ValorString(valor))
			\If{Def} \complejidad{O(1) por ref}
				\State	Si esta definido, entonces hay varios registros que cumplen
				\State	agrego el iterador al conjunto de que ya estaban.
				\State viejo $\larr$ Significado(t.IndiceS.Indice, ValorString(valor))\complejidad{O(L)}
				\State itConj(registro) newS $\larr$AgregarRapido(viejo, nuevo) \complejidad{O(L)}
				\State itConj(registro) newN $\larr$CrearIt(vacio())
			\Else
				\State Conj(Registro) viejo $\larr$ Vacio() \complejidad{O(1) por ref}
				\State itConj(registro) newS $\larr$AgregarRapido(viejo, nuevo)\complejidad{O(1) por ref}
				\State itConj(registro) newN $\larr$CrearIt(vacio())
				\State Definir(t.IndiceS.Indice, ValorString(valor), viejo) \complejidad{O(L)}
				\State Como ingresamos un nuevo valor, actualizamos el min y max
				\If{t.IndiceS.Min $>$ valor} \complejidad{O(L)}
					\State t.IndiceS.Min $\larr$ valor\complejidad{O(L)}
				\EndIf
				\If{valor $>$ t.IndiceS.Max}\complejidad{O(L)}
					\State t.IndiceS.Max $\larr$ valor\complejidad{O(L)}
				\EndIf
			\EndIf			
		\Else
			\If{$\neg$t.IndiceS.EnUso $\land$ t.IndiceN.EnUso}
				\State Obtengo de r el valor del campo con el que se creo el indice.
				\State Dato valor $\larr$ Significado(r, t.IndiceN.CampoI) \complejidad{O(L)}
				\State Bool Def $\larr$ Definido?(t.IndiceN.Indice, ValorNat(valor))\complejidad{O(log(n))}
				\If{Def} \complejidad{O(1) por ref}
					\State	Si esta definido, entonces hay varios registros que cumplen
					\State	agrego el iterador al conjunto de que ya estaban.
					\State viejo $\larr$ Significado(t.IndiceN.Indice, ValorNat(valor))\complejidad{O(L)}
					\State itConj(registro) newN $\larr$AgregarRapido(viejo, nuevo) \complejidad{O(L)}
					\State itConj(registro) newS $\larr$CrearIt(vacio())
				\Else
					\State Conj(Registro) viejo $\larr$ Vacio() \complejidad{O(1) por ref}
					\State itConj(registro) newN $\larr$AgregarRapido(viejo, nuevo)\complejidad{O(1) por ref}
					\State itConj(registro) newS $\larr$CrearIt(vacio())
					\State Definir(t.IndiceN.Indice, ValorNat(valor), viejo) \complejidad{O(L)}
					\State Como ingresamos un nuevo valor, actualizamos el min y max
					\If{t.IndiceN.Min $>$ valor} \complejidad{O(1) por ref}
						\State t.IndiceN.Min $\larr$ valor\complejidad{O(1) por ref}
					\EndIf
					\If{valor $>$ t.IndiceN.Max}\complejidad{O(1) por ref}
						\State t.IndiceN.Max $\larr$ valor\complejidad{O(1) por ref}
					\EndIf
				\EndIf
			\EndIf
		\EndIf
	\EndIf
	\State Bool BasadoEn $\larr$ Significado(t.campos, t.RelacionInd.CampoR)
	\If{BasadoEn}
		\State Es True entonces es un DiccNat
		\State Nat elem $\larr$ValorNat(Significado(r, t.RelacionInd.CampoR))
		\State Definir(t.RelacionInd.ConsultaN, elem, $< newS, newN >$)
	\Else
		\State Es False entonces es un DiccString
		\State String elem $\larr$ValorString(Significado(r, t.RelacionInd.CampoR))
		\State Definir(t.RelacionInd.ConsultaS, elem, $< newS, newN >$)
	\EndIf
}{O(L+Log(n))}
%	\If{t.IndiceS.EnUso}
%					\State Obtengo de r el valor del campo con el que se creo el indice.
%					\State Dato valor	$\larr$	Significado(r, t.IndiceS.CampoI) \complejidad{O(L)}
%					\State Bool Def $\larr$Definido?(t.IndiceS.Indice, ValorString(valor))
%					\If{Def} \complejidad{O(1) por ref}
%							\State	Si esta definido, entonces hay varios registros que cumplen
%							\State	agrego el iterador al conjunto de que ya estaban.
%							\State Conj($<$itConj(registro), itConj(registro)$>$) viejo
%							\State viejo $\larr$ Significado(t.IndiceS.Indice, valor)\complejidad{O(L)}
%							\State itConj(registro)AgregarRapido(viejo, nuevo) \complejidad{O(L)}
%					\Else
%							\State Conj(Registro) viejo $\larr$ Vacio() \complejidad{O(1) por ref}
%							\State AgregarRapido(viejo, nuevo)\complejidad{O(1) por ref}
%							\State Definir(t.IndiceS.Indice, ValorString(valor), viejo) \complejidad{O(L)}
%							\State Como ingresamos un nuevo valor, actualizamos el min y max
%							\If{t.IndiceS.Min $>$ valor} \complejidad{O(L)}
%								\State t.IndiceS.Min $\larr$ valor\complejidad{O(L)}
%							\EndIf
%							\If{valor $>$ t.IndiceS.Max}\complejidad{O(L)}
%								\State t.IndiceS.Max $\larr$ valor\complejidad{O(L)}
%							\EndIf
%					\EndIf
%	\State Donde L es la longitud del valor string agregado a t.IndiceS						
%	\EndIf
%	\If{t.IndiceN.EnUso}
%					\State Obtengo de r el valor del campo con el que se creo el indice.
%					\State Dato valor $\larr$ Significado(r, t.IndiceN.CampoI) \complejidad{O(L)}
%					\State Bool Def $\larr$ Definido?(t.IndiceN.Indice, ValorNat(valor))\complejidad{O(log(n))}
%					\If{Def} 
%							\State Conj(Registro) viejo $\larr$ Significado(t.IndiceN.Indice, ValorNat(valor))\complejidad{O(log(n))}									
%							\State AgregarRapido(viejo, nuevo) \complejidad{O(1) por ref}
%					\Else
%							\State Conj(Registro) viejo $\larr$ Vacio() \complejidad{O(1) por ref}
%							\State AgregarRapido(viejo, nuevo) \complejidad{O(1) por ref}
%							\State Definir(t.IndiceN.Indice, ValorNat(valor), viejo) \complejidad{O(Log(n))}
%							\State Como ingresamos un nuevo valor, actualizamos el min y max
%							\If{t.IndiceN.Min $>$ valor} \complejidad{O(1) por ref}
%								\State t.IndiceS.Min $\larr$ valor\complejidad{O(1) por ref}
%							\EndIf
%							\If{valor $>$ t.IndiceS.Max}\complejidad{O(1) por ref}
%								\State t.IndiceN.Max $\larr$ valor\complejidad{O(1) por ref}
%							\EndIf
%					\EndIf
%	\EndIf
%	\State Donde n es la cantidad de registros y L es la longitud maxima de un valor String.						
%	\State La complejidad depende del si hay o no indices, si ambos estan en uso. Si solo el
%	\State indice String esta en uso es O(L), si en cambio solo esta en uso el indice Natural
%	\State es O(Log(n)). Si ambos estan en uso es O(L+Log(n)) en peor caso.
%}{O(L+Log(n))}

%\newpage
%\algoritmo{borrarRegistro}{in crit: registro,in/out t: tab}{}{
%	\State	Campo c $\larr$ Siguiente(CrearIt(Campos(crit)))	\complejidad{O(1) por ref} %chequear
%	\State 	Dato valor $\larr$	Copiar(Significado(crit, c))			\complejidad{O(L)}
%	\State Sabemos que c esta incluido en claves(t) y crit tiene solo un campo.
%	\State Si hay un indice para el campo clave c, borrarRegistro es O(log(n)) u O(L) en peor caso.
%	\State Tenemos en cuenta que se borra en base a un campo clave, se borra solo un registro.
%	\If{t.IndiceS.EnUso $\lor$ t.IndiceN.EnUso}
%	\State Caso: Hay algun indice en uso.
%		\State Buscamos en la Relacion de Indices segun su campo.
%		\State Primero necesito saber en base a que tipo de campo fue creado.
%		\State Tipo BasadoEn  $\larr$ Significado(t.campos, t.RelacionInd.CampoR)
%		\State Dato valorR $\larr$ Significado(r, t.RelacionInd.CampoR)
%		\If{t.IndiceS.CampoI=c $\lor$ t.IndiceN.CampoI=c}
%		\State Caso: Hay algun indice basado en el campo c de crit.
%			\If{t.IndiceS.CampoI=c $\yluego$ Definido?(t.IndiceS.Indice, ValorString(valor))}
%			\State Sabemos que c es un campo clave. Entonces eliminamos solo un reg.
%				\State ItConj(ItConj(registro)) itr $\larr$ CrearIt(Significado(t.IndiceS.Indice, ValorString(valor)))
%				\State Registro r $\larr$ Siguiente(Siguiente(itr))
%				\State Borro el registro de t.registro
%				\State EliminarSiguiente(Siguiente(itr))
%				\State	t.\#Accesos++
%				\State Borro la clave ValorString(valor) del indice
%				\State Borrar(t.IndiceS.Indice, ValorString(valor))
%				\State Hecho todo esto puede suceder que el Indice de Nat este en uso
%				\State Si esta en uso, el campo del indice no es c.
%				\If{t.IndiceN.EnUso}
%					\If{BasadoEn}
%						\State Caso Basado en un Nat
%						\State ItConj(ItConj(registro)) sig$\larr$CreaIt(CrearIt(vacio()))
%						\State sig $\larr$ Significado(t.RelacionInd.ConsultaN, ValorNat(valorR))
%						\State Elimino en el dicc de relacion de indice, la clave del registro.
%						\State Borrar(t.RelacionInd.ConsultaN, ValorNat(valorR))
%					\Else
%						\State Caso Basado en un String
%						\State ItConj(ItConj(registro)) sig$\larr$CreaIt(CrearIt(vacio()))
%						\State sig $\larr$ Significado(t.RelacionInd.ConsultaS, ValorString(valorR))
%						\State Elimino en el dicc de relacion de indice, la clave del registro.
%						\State Borrar(t.RelacionInd.ConsultaS, ValorString(valorR))
%					\EndIf
%					\State EliminarSiguiente(sig.N)
%					\If{$\neg$HaySiguiente?(sig.N)}
%						\State No hay otro registro para este valorR en el Indice
%						\State entonces lo elimino.
%						\State Dato valorInd $\larr$ Significado(r, t.IndiceN.campoI)
%						\State Borrar(t.IndiceN.Indice, ValorNat(valorInd))
%					\EndIf
%				\Else
%					\State Si no esta en uso, solo tengo que eliminar la relacion de indices.
%					\If{BasadoEn}
%						\State Caso Basado en un Nat
%						\State Borrar(t.RelacionInd.ConsultaN, ValorNat(valorR))
%					\Else
%						\State Caso Basado en un String
%						\State Borrar(t.RelacionInd.ConsultaS, ValorString(valorR))
%					\EndIf
%				\EndIf
%			\Else
%				\If{t.IndiceN.CampoI=c $\yluego$ Definido?(t.IndiceN.Indice, ValorNat(valor))}
%					\State Entonces es el caso de t.IndiceN.CampoI=c.
%					\State Sabemos que c es un campo clave. Entonces eliminamos solo un reg.
%					\State ItConj(ItConj(registro)) itr $\larr$ CrearIt(Significado(t.IndiceN.Indice, ValorNat(valor)))
%					\State Registro r $\larr$ Siguiente(Siguiente(itr))
%					\State Borro el registro de t.registro
%					\State EliminarSiguiente(Siguiente(itr))
%					\State	t.\#Accesos++
%					\State Borro la clave ValorNat(valor) del indice
%					\State Borrar(t.IndiceN.Indice, ValorString(valor))
%					\State Hecho todo esto puede suceder que el Indice de String este en uso
%					\State Si esta en uso, el campo del indice no es c.
%					\If{t.IndiceN.EnUso}
%						\If{BasadoEn}
%							\State Caso Basado en un Nat
%							\State ItConj(ItConj(registro)) sig$\larr$CreaIt(CrearIt(vacio()))
%							\State sig $\larr$ Significado(t.RelacionInd.ConsultaN, ValorNat(valorR))
%							\State Elimino en el dicc de relacion de indice, la clave del registro.
%							\State Borrar(t.RelacionInd.ConsultaN, ValorNat(valorR))
%						\Else
%							\State Caso Basado en un String
%							\State ItConj(ItConj(registro)) sig$\larr$CreaIt(CrearIt(vacio()))
%							\State sig $\larr$ Significado(t.RelacionInd.ConsultaS, ValorString(valorR))
%							\State Elimino en el dicc de relacion de indice, la clave del registro.
%							\State Borrar(t.RelacionInd.ConsultaS, ValorString(valorR))
%						\EndIf
%						\State EliminarSiguiente(sig.S)
%						\If{$\neg$HaySiguiente?(sig.S)}
%							\State No hay otro registro para este valorR en el Indice
%							\State entonces lo elimino.
%							\State Dato valorInd $\larr$ Significado(r, t.IndiceS.campoI)
%							\State Borrar(t.IndiceS.Indice, ValorString(valorInd))
%						\EndIf
%					\Else
%						\State Si no esta en uso, solo tengo que eliminar la relacion de indices.
%						\If{BasadoEn}
%							\State Caso Basado en un Nat
%							\State Borrar(t.RelacionInd.ConsultaN, ValorNat(valorR))
%						\Else
%							\State Caso Basado en un String
%							\State Borrar(t.RelacionInd.ConsultaS, ValorString(valorR))
%						\EndIf
%					\EndIf
%				\EndIf
%			\EndIf
%		\Else
%			\State Hay algun indice, pero no esta basado en el campo c de crit
%			\State itConj(registro) cr $\larr$ CrearIt(t.registros)\complejidad{O(1) por ref}
%			\State Dato valorm $\larr$ Significado(Siguiente(cr), c)
%			\State Registro Delr $\larr$ Siguiente(cr)
%			\While{HaySiguiente(cr) $\land$ $\neg$(valorm=valor)}\complejidad{O(Cardinal(t.registros))}
%					\State Delr $\larr$ Siguiente(cr)
%					\State valorm $\larr$ Significado(Delr, c)		\complejidad{O(1) por ref}
%					\If{valorm=valor}
%						\State EliminarSiguiente(cr);									\complejidad{O(1) por ref}
%						\State Dado que el crit solo tiene un campo clave, siempre elimino solo un registro.
%						\State Ademas tengo que actualizar los indices, usando la relacion de indices
%						\If{t.IndiceS.EnUso $\lor$ t.IndiceN.EnUso}
%							\If{BasadoEn}
%								\State Caso basado en un campo nat
%								\State key$\larr$ ValorNat(Significado(Delr, t.RelacionInd.campoR))
%								\State dataindices $\larr$Significado(t.RelacionInd.ConsultaN, key)
%								\State Borrar(t.RelacionInd.ConsultaN, key)
%							\Else
%								\State Caso basado en un campo string
%								\State key$\larr$ ValorString(Significado(Delr, t.RelacionInd.campoR))
%								\State dataindices $\larr$Significado(t.RelacionInd.ConsultaS, key)
%								\State Borrar(t.RelacionInd.ConsultaS, key)
%							\EndIf						
%							\If{t.IndiceS.EnUso $\land$ t.IndiceN.EnUso}
%								\State EliminarSiguiente(dataindices.S)
%								\State EliminarSiguiente(dataindices.N)
%							\Else
%								\If{t.IndiceS.EnUso}
%									\State EliminarSiguiente(dataindices.S)
%								\Else
%									\If{t.IndiceN.EnUso}
%										\State EliminarSiguiente(dataindices.N)
%									\EndIf
%								\EndIf
%							\EndIf
%							\If{t.IndiceN.EnUso $\yluego$ $\neg$HaySiguiente?(dataindices.N)}
%								\State valN $\larr$ ValorNat(Significado(Delr, t.IndiceN.campoI))
%								\State Borrar(t.IndiceN.Indice, valN)
%							\EndIf
%							\If{t.IndiceS.EnUso $\yluego$ $\neg$HaySiguiente?(dataindices.S)}
%								\State valS $\larr$ ValorString(Significado(Delr, t.IndiceS.campoI))
%								\State Borrar(t.IndiceN.Indice, valN)
%							\EndIf
%						\EndIf
%					\EndIf
%					\State Avanzar(cr)													\complejidad{O(1) por ref}
%			\EndWhile
%		\EndIf	
%	\Else
%		\State No hay indices.
%		\State itConj(registro) cr $\larr$ CrearItConj(t.registros)\complejidad{O(1) por ref}
%		\While{HaySiguiente(cr)}\complejidad{O(Cardinal(t.registros))}
%			\State Registro Delr $\larr$ Siguiente(cr)
%			\State valorm $\larr$ Significado(Delr, c)		\complejidad{O(1) por ref}
%			\If{valorm=valor}
%				\State EliminarSiguiente(cr);									\complejidad{O(1) por ref}
%				\State Dado que el crit solo tiene un campo clave, siempre elimino solo un registro.
%			\EndIf
%			\State Avanzar(cr)													\complejidad{O(1) por ref}
%		\EndWhile
%	\EndIf
%	\State En el peor de los casos no hay indice y eliminar es complejidad O(n).
%	\State En caso de que haya algun indice basado en el campo del crit de borrado,
%	\State la complejidad es O(L) si es un campo string, y O(Log(n)) si es un campo nat.
%	\State Tambien puede suceder que exista algun indice, pero ninguno basado en el campo
%	\State del crit de borrado con costo O(n).
%	\State La actualizacion de los indices se ve soportada en el Diccionario t.RelacionInd
%	\State que nos permite acceder al iterador del conjunto almancenado en su significado,
%	\State dicho iterador contiene el iterador del registro dentro de t.registros que es un conj Linea.
%}{O(n)}
%	
%	
%	\If{t.IndiceS.EnUso $\yluego$ t.IndiceS.CampoI=c}
%		\State Caso en el que hay un indice String en uso
%		\State String S $\larr$ ValorString(valor) 
%		\If{Definido?(t.IndiceS.Indice, S)}				
%			\State Conj(itConj(registro)) cj $\larr$ Significado(t.IndiceS.Indice, S) \complejidad{O(L)}
%			\State ItConj(Conj(itConj(registro))) itcj $\larr$ CrearIt(cj) \complejidad{O(1) por ref}
%			\State itConj(registro) elem $\larr$ Siguiente(itcj)
%			\State Borro el registro del conjunto de t.registros
%			\State EliminarSiguiente(elem) \complejidad{O(1) por ref}
%			\State Borro la clave S que contiene el conjunto con el iterador al registro.
%			\State Borrar(t.IndiceS.Indice, S) \complejidad{O(L)}
%			\If{t.IndiceS.Min=valor}
%				\State t.IndiceS.Min$\larr$ Minimo(Claves(t.IndiceS))
%			\EndIf
%			\If{t.IndiceS.Max=valor}
%				\State t.IndiceS.Max$\larr$ Maximo(Claves(t.IndiceS))
%			\EndIf
%			\State Dado que el crit solo tiene un campo clave, siempre elimino un registro.
%			\State t.\#Accesos++
%		\EndIf
%	\EndIf
%	\State Caso en el que hay un indice de Naturales
%	\If{t.IndiceN.EnUso $\land$ t.IndiceN.CampoI=c}
%		\State Nat N $\larr$ ValorNat(valor)
%		\If{Definido?(t.IndiceN.Indice, valor)}
%				\State Conj(itConj(registro)) cj $\larr$ Significado(t.IndiceS.Indice, S) \complejidad{O(L)}
%				\State ItConj(Conj(itConj(registro))) itcj $\larr$ CrearIt(cj) \complejidad{O(1) por ref}
%				\State itConj(registro) elem $\larr$ Siguiente(itcj)
%				\State Borro el registro del conjunto de t.registros
%				\State EliminarSiguiente(elem) \complejidad{O(1) por ref}
%				\State Borro la clave S que contiene el conjunto con el iterador al registro.
%
%				\State	itConj(registro) itr $\larr$ Significado(t.IndiceN.Indice, valor)\complejidad{O(1) por ref}
%				% Borro el registro del indice,
%				\State	EliminarSiguiente(itr) \complejidad{O(1) por ref}
%				\State	Borrar(t.IndiceN.Indice, valor) \complejidad{O(1) por ref}
%				\If{t.IndiceN.Min=valor} \complejidad{O(1) por ref}
%					\State t.IndiceS.Min$\larr$ Minimo(Claves(t.IndiceN)) \complejidad{O(Log(n))}
%				\EndIf
%				\If{t.IndiceN.Max=valor} \complejidad{O(1) por ref}
%					\State t.IndiceS.Max$\larr$ Maximo(Claves(t.IndiceN))\complejidad{O(Log(n))}
%				\EndIf
%				\State Dado que el crit solo tiene un campo clave, siempre elimino un registro.
%				\State t.\#Accesos++
%		\EndIf
%	\EndIf
%		\Else
%			\State No hay indice para el campo clave de criterio pasado por parametro
%			\State itConj(registro) cr $\larr$ CrearItConj(t.registros)\complejidad{O(1) por ref}
%			\While{HaySiguiente(cr)}\complejidad{O(Cardinal(t.registros))}
%					\State valorR $\larr$ Significado(Siguiente(cr), c)		\complejidad{O(1) por ref}
%					\If{valorR=valor}
%						\State EliminarSiguiente(cr);									\complejidad{O(1) por ref}
%						\State Dado que el crit solo tiene un campo clave, siempre elimino solo un registro.
%						\State t.\#Accesos++
%					\EndIf
%					\State Avanzar(cr)													\complejidad{O(1) por ref}
%			\EndWhile
%			\State La complejidad de la operacion borrar depende de si hay o no indices
%			\State para el campo del crit pasado por parametro.
%			\State En caso de que exista dicho indice, en peor caso eliminar es O(Log(n)) u O(L)
%			\State siendo n la cantidad de registros de la tabla pasada por parametro y L
%			\State el valor string mas largo definido en la tabla.
%			\State En caso de no haber tal indice es O(n).			
%		\EndIf
%	\EndIf
%}{O(n)}

\newpage
\algoritmo{indexar}{in c: campo, in/out t: tab}{}{
	\If{tipoCampo(c,t.campos)}
		\State t.IndiceN.EnUso $\larr$ True
	\Else
		\State t.IndiceS.EnUso $\larr$ True
	\EndIf
	\State ItConj(ItConj(registro)) newS $\larr$CrearIt(CrearIt(Vacio()))
	\State ItConj(ItConj(registro)) newN $\larr$CrearIt(CrearIt(Vacio()))
	\State $<ItConj(ItConj(registro)),ItConj(ItConj(registro))>$ dataIndices
	\State Buscamos en la Relacion de Indices segun su campo.
	\State Primero necesito saber en base a que tipo de campo fue creado.
	\State Tipo BasadoEn  $\larr$ Significado(t.campos, t.RelacionInd.CampoR)
	\State itConj(registro) cr $\larr$ CrearItConj(t.registros)
	\While{HaySiguiente(cr)}
		\If{tipoCampo?(c,t)}
			\State	Caso Naturales
			\State 	Dato	valor $\larr$ Significado(Siguiente(cr), c)
			\State	Bool Definido $\larr$Definido?(t.IndiceN.Indice, ValorNat(valor))
			\State 	itConj(registro) itr $\larr$ Copiar(cr)
			\If{Definido}
				\State	Significa que para este valor del indice hay mas de un iterador de conj a reg
				\State	regviejos $\larr$ Significado(t.IndiceN.Indice, ValorNat(valor))
				\State	itConj(itConj(registro)) newN $\larr$ AgregarRapido(regviejos, itr)
			\Else
				\State 	Conj(itConj(registro)) nuevo $\larr$ Vacio()
				\State 	newN $\larr$ AgregarRapido(nuevo, itr)
				\State	Definir(t.IndiceN.Indice, ValorNat(valor), nuevo)
			\EndIf
		\Else
			\State	Caso Strings
			\State 	Dato	valor $\larr$ Significado(Siguiente(cr), c)
			\State	Bool Definido $\larr$Definido?(t.IndiceS.Indice, ValorString(valor))
			\State 	itConj(registro) itr $\larr$ cr
			\If{Definido}
				\State	Significa que para este valor del indice hay mas de un iterador de conj a reg
				\State	regviejos $\larr$ Significado(t.IndiceS.Indice, ValorString(valor))
				\State	itConj(itConj(registro)) newS $\larr$ AgregarRapido(regviejos, itr)
			\Else
				\State 	Conj(itConj(registro)) nuevo $\larr$ Vacio()
				\State 	newS $\larr$ AgregarRapido(nuevo, itr)
				\State	Definir(t.IndiceS.Indice, ValorString(valor), nuevo)
			\EndIf
		\EndIf
		\State Ahora actualizo la relacion de indices
		\State Dato valorR $\larr$ Significado(Siguiente(cr), t.RelacionInd.CampoR)
		\State Bool DefinidoR 
		\If{BasadoEn}
			\State La relacion de indices esta basada en un campo Natural
			\State DefinidoR $\larr$ Definido?(t.RelacionInd.ConsultaN, ValorNat(valorR))
		\Else
			\State La relacion de indices esta basada en un campo String
			\State DefinidoR $\larr$ Definido?(t.RelacionInd.ConsultaS, ValorString(valorR))
		\EndIf
		\If{DefinidoR}
			\State Significa que el otro indice esta en uso.
			\If{BasadoEn}
				\State La relacion de indices esta basada en un campo Natural
				\State dataIndices $\larr$ Significado(t.RelacionInd.ConsultaN, ValorNat(valorR))															\If{tipoCampo?(c,t.campos)}
					\State dataIndices.N $\larr$ newN					
				\Else
					\State dataIndices.S $\larr$ newS	
				\EndIf
			\Else
				\State La relacion de indices esta basada en un campo String
				\State dataIndices $\larr$ Significado(t.RelacionInd.ConsultaS, ValorString(valorR))
				\If{tipoCampo?(c,t)}
					\State dataIndices.N $\larr$ newN					
				\Else
					\State dataIndices.S $\larr$ newS	
				\EndIf
			\EndIf
		\Else
			\State Significa que el otro indice no esta en uso.
			\State dataIndices $\larr$ $<newS, newN>$
			\If{BasadoEn}
				\State Definir(t.RelacionInd.ConsultaN, ValorNat(valorR), dataIndices)
			\Else
				\State Definir(t.RelacionInd.ConsultaS, ValorString(valorR), dataIndices)
			\EndIf
		\EndIf
		\State	Avanzar(cr)	
	\EndWhile
}{O(1) por ref}	
	
	
%	\If{tipoCampo?(c,t)}
%			\While{HaySiguiente(cr)}
%						\State 	Dato	valor $\larr$ Significado(Siguiente(cr), c)
%						\State 	itConj(registro) itr $\larr$ CrearItConj(Siguiente(cr))
%						\If{Definido?(t.IndiceN.Indice, valor)}
%									\State	regviejos $\larr$ Significado(indC, valor)
%									\State	AgregarRapido(regviejos, itr)
%						\Else
%									\State 	conj(registro) nuevo $\larr$ Vacio()
%									\State 	AgregarRapido(nuevo, itr)
%									\State	DefinirRapido(t.IndiceN.Indice, valor, nuevo)
%						\EndIf
%						\State	Avanzar(cr)
%			\EndWhile
%	\EndIf
%	\If{$\neg$tipoCampo?(c,t)}
%			\While{HaySiguiente(cr)}
%						\State 	Dato	valor $\larr$ Significado(Siguiente(cr), c)
%						\State 	itConj(registro) itr $\larr$ CrearItConj(Siguiente(cr))
%						\If{Definido?(t.IndiceS.Indice, valor)}
%									\State	regviejos $\larr$ Significado(indC, valor)
%									\State	AgregarRapido(regviejos, itr)
%						\Else
%									\State 	conj(registro)	 nuevo $\larr$ Vacio()
%									\State 	AgregarRapido(nuevo, itr)
%									\State	DefinirRapido(t.IndiceN.Indice, valor, nuevo)
%						\EndIf
%						\State	Avanzar(cr)
%			\EndWhile	
%	\EndIf
%}{O(1) por ref}

  \algoritmo{puedoInsertar?}{in r:registro, in t:tab}{res:bool}{
    \State res $\larr$ campatible(r,t) $\land$ $\neg$hayCoincidencia( r, Campo(r), registros(t)  )  \complejidad{O(calcular))}
 }{O(calcular)}


  \algoritmo{compatible}{in r:registro, int t:tab}{res:bool}{
  		\State bool valor $\larr$ True
 		\If{Cardinal(campos(r))=Cardinal(DiccClaves(t.Campos))}
				  \State itcampos $\larr$ CrearItString(DiccClaves(t.Campos))
				  \While{valor $\land$ HaySiguiente(itcampos)} \complejidad{O(1) por ref}
				  			\State Campo c $\larr$ Siguiente(itcampos) \complejidad{O(1) por ref}
							\State valor $\larr$ Definido?(r, c) \complejidad{O(1) por ref}
				  \EndWhile
		\Else
					\State valor $	\larr$ False  \complejidad{O(1) por ref}
 		\EndIf
 		\State res $\larr$ valor  $\yluego$ mismosTipos(r,t)  \complejidad{O(1) por ref}	
 		\State El costo del While es O(1) por ref ya que la cantidad de campos de la tabla es acotado
 }{O($1$)}



 
  \algoritmo{minimo}{in c:campo, in t:tab}{res:dato}{
	\State	Si hay indice en el campo c, debe ser de complejidad O(1) por ref
	\If{t.IndiceS.EnUso $\land$ t.IndiceS.CampoI=c}
		\State	Sabemos que hay un indice string para el campo c
		\State	res $\larr$ t.IndiceS.Min \complejidad{O(Cardinal(t.registros))}
	\Else
		\If{t.IndiceN.EnUso $\land$ t.IndiceN.CampoI=c}
			\State	Sabemos que hay un indice string para el campo c
			\State	res $\larr$ t.IndiceN.Min\complejidad{O(Cardinal(t.registros))}
%		\Else
%			\State	Si no hay indice para este campo hay que buscar el valor en O(n)
%			\State	ItConj(Registro) itr $\larr$ t.Registros
%			\State	Dato min\_ $\larr$ Significado(Siguiente(itr), c)
%			\While{HaySiguiente?(itr)}
%				\State	Dato sig $\larr$ Significado(Siguiente(itr), c)
%				\If{sig$\geq$min\_}
%						\State	min\_$\larr$ Copiar(sig)
%				\EndIf
%				\State Avanzar(itr)
%			\EndWhile
		\EndIf
	\EndIf
%  	\State 	res $\larr$ min( dameColumna(  c, t.registros  ))\complejidad{O(Cardinal(t.registros))}
 }{O(1) por ref}
 
   \algoritmo{maximo}{in c:campo, in t:tab}{res:dato}{
	\State	Si hay indice en el campo c, debe ser de complejidad O(1) por ref
	\If{t.IndiceS.EnUso $\land$ t.IndiceS.CampoI=c}
		\State	Sabemos que hay un indice string para el campo c
		\State	res $\larr$ t.IndiceS.Max \complejidad{O(Cardinal(t.registros))}
	\Else
		\If{t.IndiceN.EnUso $\land$ t.IndiceN.CampoI=c}
			\State	Sabemos que hay un indice string para el campo c
			\State	res $\larr$ t.IndiceN.Max\complejidad{O(Cardinal(t.registros))}
%		\Else
%			\State	Si no hay indice para este campo hay que buscar el valor en O(n)
%			\State	ItConj(Registro) itr $\larr$ t.Registros
%			\State	Dato max\_ $\larr$ Significado(Siguiente(itr), c)
%			\While{HaySiguiente?(itr)}
%				\State	Dato sig $\larr$ Significado(Siguiente(itr), c)
%				\If{sig$\geq$max\_}
%						\State	max\_$\larr$ Copiar(sig)
%				\EndIf
%				\State Avanzar(itr)
%			\EndWhile
		\EndIf
	\EndIf
}{O(1) por ref}

  \algoritmo{puedeIndexar}{in c:campo, in t:tab}{res:bool}{
					\If{TipoCampo(c, t)}
							\State res $\larr$ $\neg$(t.IndiceN.EnUso)
					\Else
							\State res $\larr$ $\neg$(t.IndiceS.EnUso)
					\EndIf
 }{O(1) por ref}


\algoritmo{hayCoincidencia}{in r:registro, in cc:ConjString(campo), in cr:Conj(registro)}{res:bool}{
  	\State	itcr $\larr$ CrearItConj(cr)   \complejidad{O(1) por ref}  
    \State	res $\larr$ false                   \complejidad{O(1) por ref}  
  	\While{HaySiguiente(itcr)}		\complejidad{O(Cardinal(cr))}  
				\State	res $\larr$ 	coincideAlguno(r,cc,Siguiente(itcr)) $\lor$res \complejidad{O(1) por ref}  
				\State	Avanzar(itcr) 			\complejidad{O(1) por ref}  
	\EndWhile   
}{O(Cardinal(cr))}


%  \operacion{coincidencias}{in r: registro, in cj: Conj(registro)}{res: Conj(ItConj(registro))}
% {$True$}
% {$res \igobs coincidencias(r,cj)$}
% {Devuelve el conjunto de registros de la tabla, que coinciden con los valores de r.}
% {O($L+Log(n)$)}
% {Retorna res por referencia,.}

\algoritmo{coincidencias}{in crit:registro, in cr:Conj(registro)}{res:Conj(ItConj(registro))}{
 	\State Conj(registro) salida	$\larr$ Vacio() \complejidad{O(1) por ref}
	\State Debemos comparar todos los registros de cr.
	\State y agregarlos al conjunto de registros salida
  	\State 	itcr $\larr$ CrearItConj(cr)						
  	\While{HaySiguiente?(cr)}							\complejidad{O(Cardinal(cr))}
		\If {coincidenTodos(crit,campos(crit),Siguiente(itcr))}  \complejidad{O(1) por ref}
				\State	AgregarRapido(salida, CrearIt(Siguiente(itcr))) \complejidad{O(1) por ref}
				
				\State	AgregarRapido(salida, itcr) \complejidad{O(1) por ref}

		\EndIf				
		\State	Avanzar(itcr) \complejidad{O(1) por ref}
	\EndWhile   
	\State res $\larr$ salida\complejidad{O(1) por ref}
}{O(Cardinal(cr))}
 
%	\If{Cardinal(Indices(t))$\geq$1}
%	\State Si hay indice, obtengo los valores de crit para los campos de los indices que existan
%		\If{t.IndiceS.EnUso}
%				\State	vals $\larr$ Significado(crit, t.IndiceS.CampoI)
%				\State	Conj(registro) rind	$\larr$ Significado(t.IndiceS.Indice, vals)
%				\State	itrind $\larr$ CrearItConj(rind)
%				\While{HaySiguiente(itrind)}
%						\State r1 $\larr$ Siguiente(Siguiente(itcr))
%						\State Esta ultima linea, se debe a que estoy iterando, 
%						\State iteradores de conjunto al elemento
%						\If{coincidenTodos(r1,t.Claves,crit)}
%								\State AgregarRapido(salida, r1) 
%								\State Agrego por referencia.
%						\EndIf
%						\State Avanzar(itcr)
%				\EndWhile
%		\Else
%				\If{t.IndiceN.EnUso}
%						\State	valn $\larr$ Significado(crit, t.IndiceN.CampoI)
%						\State	Conj(registro) rind	$\larr$ Significado(t.IndiceN.Indice, valn)
%						\State	itrind $\larr$ CrearItConj(rind)
%						\While{HaySiguiente(itrind)}
%								\State r1 $\larr$ Siguiente(Siguiente(itcr))
%								\State Esta ultima linea, se debe a que estoy iterando, 
%								\State iteradores de conjunto al elemento
%								\If{coincidenTodos(r1,t.Claves,crit)}
%										\State AgregarRapido(salida, r1) 
%										\State Agrego por referencia.
%								\EndIf
%								\State Avanzar(itcr)
%						\EndWhile
%				\EndIf
%		\EndIf
%		\State Como buscamos los registros que tenga los mismo datos que crit,
%		\State los registros que cumplan dicho requerimiento. Si aparecen en uno
%		\State de los indices, en el otro tambien apareceran. Entonces solo comparo
%		\State los registros que tienen los mismos datos para los campos de los indices
%		\State correspondientes.
%	\EndIf


\algoritmo{combinarRegistros}{in c:campo, in cr1:Conj(registro), in cr2:Conj(registro)}{res:Conj(registros)}{
	\State	itcr1 $\larr$ CrearItConjString(cr1) \complejidad{O(1) por ref}  
%	\State	Se me ocurre hacer un DiccString o DiccNat, dependiendo de tipo sea el campo c, de manera que combinar todos sea complejidad O(Log(Cardinal(cr2))).
	\State	Lo malo es que combinarRegistros sera O(Cardinal(cr2)*Log(Cardinal(cr2)))
	\If{Cardinal(cr2)$\geq$1}\complejidad{O(1) por ref}  
		Registro rtemp $\larr$ Siguiente(CrearIt(cr2))\complejidad{O(1) por ref}  
		Tipo rac $\larr$ Tipo?(Significado(rtemp, c))\complejidad{O(1) por ref}  
		\If{rac} \complejidad{O(1) por ref}  
			\State	Caso Natural
			\State	DiccNat(Nat, Conj(registro)) d $\larr$ vacio() \complejidad{O(1) por ref}  
			\State	itcr2 $\larr$ CrearIt(cr2)\complejidad{O(1) por ref}  
			\While{HaySiguiente?(itcr2)}\complejidad{O(1) por ref}  
					\State Dato valor $\larr$ Obtener(Siguiente(itcr2), c) \complejidad{O(1) por ref}
					\If{Definido?(d, ValorNat(valor))}  \complejidad{O(Cardinal(cr2))}
						\State	cjViejo $\larr$ Significado(d, ValorNat(valor)) \complejidad{O(Cardinal(cr2))}
						\State	AgregarRapido(d, Siguiente(itcr2)) \complejidad{O(1) por ref}
					\Else
						\State	ConjNat(registro) cjNuevo $\larr$ vacio() \complejidad{O(1) por ref}
						\State	AgregarRapido(d, Siguiente(itcr2)) \complejidad{O(1) por ref}
						\State	Definir(d, ValorNat(valor), cjNuevo)\complejidad{O(Cardinal(cr2))}
					\EndIf
					\State	Avanzar(itcr2)\complejidad{O(1) por ref}
			\EndWhile
		\Else
			\State	Caso String
			\State	DiccString(String, Conj(registro)) d $\larr$ vacio() \complejidad{O(1) por ref}  
			\State	itcr2 $\larr$ CrearIt(cr2)\complejidad{O(1) por ref}  
			\While{HaySiguiente?(itcr2)}\complejidad{O(1) por ref}  
					\State Dato valor $\larr$ Obtener(Siguiente(itcr2), c) \complejidad{O(1) por ref}
					\If{Definido?(d, ValorString(valor))}  \complejidad{O(Cardinal(cr2))}
						\State	cjViejo $\larr$ Significado(d, ValorString(valor)) \complejidad{O(Cardinal(cr2))}
						\State	AgregarRapido(d, Siguiente(itcr2)) \complejidad{O(1) por ref}
					\Else
						\State	ConjString(registro) cjNuevo $\larr$ vacio() \complejidad{O(1) por ref}
						\State	AgregarRapido(d, Siguiente(itcr2)) \complejidad{O(1) por ref}
						\State	Definir(d, ValorString(valor), cjNuevo)\complejidad{O(Cardinal(cr2))}
					\EndIf
					\State	Avanzar(itcr2)\complejidad{O(1) por ref}
			\EndWhile
		\EndIf	
		\State itcr1 $\larr$ CrearIt(cr1) \complejidad{O(1) por ref} 
		\State res $\larr$ vacio()
	  	\While{HaySiguiente(itcr1)}         \complejidad{O(Cardinal(cr1))}
			\State	AgregarRapido(res, combinarTodos(c,Siguiente(itcr1),cr2)) \complejidad{O(Cardinal(cr2))}	
			\State	Avanzar(itcr1) 					\complejidad{O(1) por ref}  
		\EndWhile   
	\Else
		\State res $\larr$ vacio()
	\EndIf
}{O(Cardinal(cr1))}

 
\algoritmo{dameColumna}{in c:campo, in cr:Conj(registro)}{res:Conj(dato)}{
  	\State 	res $\larr$ vacio()				\complejidad{O(1)}
  	\State it $\larr$ CrearIt(cr) \complejidad{O(1)}
	\State	Tvalor $\larr$ Tipo?(Significado(Siguiente(it), c)) \complejidad{O(1)}		
	\If{Tvalor}
		\State DiccNat(nat,dato) bolsaN $\larr$ vacio \complejidad{O(1)}
		\While{haySiguiente(it)} \complejidad{O($\#cr$)}
			\State Definir(bolsaN, valorNat(Significado(Siguiente(it),c)), Significado(Siguiente(it),c)) \complejidad{O($log(\#cr)$)}
			
			\State avanzar(it) \complejidad{O(1)}
		\EndWhile
		\State itN $\larr$ diccClaves(bolsaN) \complejidad{O(1) por ref}
		\While{haySiguiente(itN)} \complejidad{O($\#cr$)}
			\State AgregarRapido(res, Significado(bolsaN, siguiente(itN)))  \complejidad{O($log(\#cr)$)}
			\State avanzar(itN)
		\EndWhile
	\Else
		\State DiccString(String,dato) bolsaS $\larr$ vacio() \complejidad{O(1)}
		\While{haySiguiente(it)} \complejidad{O($\#cr$)}
			\State Definir(bolsaS, valorString(Significado(Siguiente(it),c)), Significado(Siguiente(it),c)) \complejidad{O($long(k)$)}
			
			\State avanzar(it) \complejidad{O(1)}
		\EndWhile
		\State itS $\larr$ CrearIt(diccClaves(bolsaS)) \complejidad{O(1) por ref}
		\While{haySiguiente(itS)} \complejidad{O($\#cr$)}
			\State AgregarRapido(res, Significado(bolsaS, siguiente(itS)))  \complejidad{O($long(siguiente(itS))$)}
			\State avanzar(itS) \complejidad{O(1)}
		\EndWhile
	\EndIf
	
}{O($\#cr *log(\#cr) + (\#cr *long(k)) $)}
%\\
%\bullet En Particular, si el tipo asociado a c es Nat, entonces toma $O(\#cr *log(\#cr))$ mientras que si es String toma
%$O(\#cr *long(k))$ siendo k la palabra mas larga de la columna
%\\
%\bullet Al agregar a res es seguro que no hay repetidos por haber sido volcados al diccionario previamente, que en ambos casos no permiten claves repetidas. 
%\\
\algoritmo{mismosTipos}{in r:registro, in t:tab}{res:bool}{
  	\State 	valor $\larr$ True										\complejidad{O(1) por ref}
  	\State 	itconjClaves $\larr$ CrearIt(Campo(r)) \complejidad{O(1) por ref}
  	\While{valor $\yluego$ HaySiguiente?(itconjClaves)}				\complejidad{O(1) por ref}
  					\State	val1$\larr$ tipo?(Significado(r, Siguiente(itconjClaves))) \complejidad{O(1) por ref}
  					\State	val2$\larr$ tipoCampo(Siguiente(itconjClaves), t)	\complejidad{O(1) por ref}
					\State	valor $\larr$ (val1 = val2)	\complejidad{O(1) por ref}
					\State	Avanzar(cr);								\complejidad{O(1) por ref}
	\EndWhile     	
	\State	res $\larr$ valor
 }{O(1) por ref}


  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Algoritmos operaciones auxiliares}

\algoritmo{BuscarEnTabla}{in criterio: registro, in t: tab}{res: Conj(ItConj(registro))}{
	\State 	Primero busco que campos de r, estan en los campos de t y son del mismo tipo
	\State	itcampos $\larr$ DiccClaves(t.campos)
	\State	Bool Encontrado $\larr$ false
	\State	Campo EncontradoCampoInd
	\State	Conj(Campo) cj $\larr$ vacio()
	\While{HaySiguiente?(itcampos) $\land$ $\neg$Encontrado}
		\State Campo c $\larr$ Siguiente(itcampos)
		\State Bool Def $\larr$Definido?(criterio, c)
		\If{Def}
			\State bool valorD $\larr$ (Tipo?(Significado(criterio, c))=Significado(t.campos, c))
			\If{valorD}
				\State	El campo esta en ambos y es del mismo tipo, lo agrego al conj lineal
				\State	AgregarRapido(cj, c)
				\State	Vemos tambien si el campo c de criterio esta en los indices
				\State	Bool EncS $\larr$ (t.IndiceS.EnUso $\yluego$ t.IndiceS.CampoI=c)
				\State	Bool EncN $\larr$ (t.IndiceN.EnUso $\yluego$ t.IndiceN.CampoI=c)
				\State	Encontrado $\larr$ (EncS $\lor$ EncN)
				\If{Encontrado}
					\State	EncontradoCampoInd $\larr$ c
				\EndIf
			\EndIf
		\EndIf
		\State	Avanzar(itcri)
	\EndWhile	
	\State	Si Encontrado es true entonces uso indice, sino recorro todo los registros
	\If{Encontrado}
		\State Entonces hay un indice para EncontradoCampoInd
		\If{t.IndiceN.EnUso $\yluego$ t.IndiceN.CampoI=EncontradoCampoInd}
			\State	Caso Natural
			\State	Obtengo el valor nat del registro criterio
			\State	Nat valor $\larr$ ValorNat(Significado(criterio, EncontradoCampoInd))
			\State	Conj(itConj(registro)) res $\larr$ Significado(t.IndiceN.Indice, valor)
		\EndIf
		\If{$\neg$Significado(t.campos, EncontradoC)}
			\State	Caso String
			\State	Obtengo el valor nat del registro criterio
			\State	String valor $\larr$ ValorString(Significado(criterio, EncontradoCampoInd))
			\State	Conj(itConj(registro)) res $\larr$ Significado(t.IndiceS.Indice, valor)
		\EndIf
	\Else
		res $\larr$ Coincidencias(criterio, t.registros)
	\EndIf
	\State	La complejidad depende de si hay indice para algun campo de criterio,
	\State	en ese caso la complejidad es O(\#(Campos(t))+L + Log(n))
	\State	En caso contrario es O(\#(Campos(t))+\#(Registros(t)))
 }{O(1) por ref}
 