
%\section{Pos es tupla(x:Nat, y:Nat)}

%\section{Placa es Nat}

%\section{Nombre es String}

\section{Tabla}

\subsection{Interfaz}

\sexc{tabla}
$\textbf{usa}$  
\generos{}{DiccString(string, alfha),} {DiccNat(nat, beta),}{Nat, String, Dato, Campo, Tipo, Registro, ConjString, ConjNat.}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Operaciones}


%%%%%% observadores basicos %%%%%%

\operacion{nombre}{in t: tab }{res : string}
 {true}
 {$res \igobs nombre(t)$}
 {Devuelve el nombre de la tabla ingresada por parametro.}
 {O($1$)}
 {Se retorna res por copia, por ser un tipo basico.}

\operacion{claves}{in t: tab }{res : ConjString(campo)}
 {true}
 {$res \igobs claves(t)$}
 {Devuelve un conjunto de campos clave en la tabla ingresada por parametro.}
 {O($1$)}
 {Se devuelve res por referencia, no es modificable.}
 
\operacion{indices}{in t: tab }{res : ConjString(campo)}
 {true}
 {$res \igobs indices(t)$}
 {Devuelve un conjunto campos con los que se crearon los indices.}
 {O($1$)}
 {Se devuelve res por referencia, no es modificable.}
 
\operacion{campos}{in t: tab }{res : ConjString(campo)}
 {true}
 {$res \igobs campos(t)$}
 {Devuelve un conjunto de todos los campos de la tabla.}
 {O($1$)}
 {Se devuelve res por referencia, no es modificable.}

\operacion{tipoCampo}{in c: campo,in t: tab }{res : tipo}
 {c $\in$ campos(t)}
 {$res \igobs tipoCampo(t)$}
 {Devuelve el tipo del campo c en la tabla.}
 {O($1$)}
 {Se devuelve res por referencia, no es modificable.}
 
\operacion{registros}{in t: tab }{res : itConj(registro)}
 {true}
 {$res \igobs registros(t)$}
 {Devuelve un conjunto a los registros de la tabla.}
 {O($1$) }
 {Se devuelve res referencia.}

 
\operacion{cantidadDeAcccesos}{in t: tab }{res : nat}
 {true}
 {$res \igobs cantidadDeAccesos(t)$}
 {Devuelve la cantidad de modificaciones de la tabla ingresada por parametro.}
 {O($1$)}
 {Se devuelve res por copia.}

 
 %%%%%% generadores %%%%%%%
 
 \operacion{nuevaTabla}{in nombre: string, in claves: conjString(campo), in columnas: registro }{res : tab}
 {$\neg\emptyset$?(claves) $\land$ claves$\subseteq$campos(columnas)}
 {$res \igobs nuevaTabla(t)$}
 {Crea una tabla sin registros.}
 {O($1$)}
 {}

 \operacion{agregarRegistro}{in r: registro, in/out t: tab}{}
 {t\_0=t $\land$ campos(r)$\igobs$campos(t) $\land$ puedorInsertar?(r,t)}
 {agregarRegistro(r,t\_0)}
 {Agrega un registro a la tabla pasada por parametro.}
 {O($Log(n)$)}
 {Agrega el registro r por referencia.} 
 
 \operacion{borrarRegistro}{in crit: registro, in/out t: tab}{}
 {t\_0=t $\land$ $\#$(campos(r))=1 $\yluego$ Siguiente(CrearIt(campos(crit)))$\in$claves(t)}
 {borrarRegistro(r,t\_0)}
 {Borra los registros que cumplan el criterio pasado por parametro.}
 {O($n$)}
 {} 
 
  \operacion{indexar}{in crit: registro, in/out t: tab}{}
 {t\_0=t $\land$ puedeIndexar(c,t)}
 {indexar(c,t\_0)}
 {Crea un indice en base al campo de crit.}
 {O($n$)}
 {} 	
 
%%%%%% Otras Operaciones %%%%%%%%%%%

 \operacion{puedoInsertar?}{in r: registro, in t: tab}{res:bool}
 {$true$}
 {$res \igobs puedoInsertar?(r,t)$}
 {Informa si el registro pasado por parametro no tiene valores repetidos con respectos a los registros existentes, para los campos clave en la tabla pasada por parametro.}
 {O($n$)}
 {Retorna res por referencia, no es modificable.} 
 
  \operacion{compatible}{in r: registro, in t: tab}{res:bool}
 {$true$}
 {$res \igobs compatible(r,t)$}
 {Informa si el registro pasado por parametro tiene correspondecia en los tipos de los campos de tabla pasada por parametro.}
 {O($1$)}
 {Retorna res por referencia, no es modificable.} 
 
  \operacion{minimo}{in c: campo, in t: tab}{res:dato}
 {$\neg\emptyset$?(registro(t)) $\land$ c$\in$indices(t)}
 {$res \igobs minimo(c,t)$}
 {Retorna el minimo entre los valores de la tabla para el campo c.}
 {O($L+Log(n)$)}
 {Retorna res por referencia.}
  
  \operacion{maximo}{in c: campo, in t: tab}{res:dato}
 {$\neg\emptyset$?(registro(t)) $\land$ c$\in$indices(t)}
 {$res \igobs maximo(c,t)$}
 {Retorna el maximo entre los valores de la tabla para el campo c.}
 {O($L+Log(n)$)}
 {Retorna res por referencia.} 

  \operacion{puedeIndexar}{in c: campo, in t: tab}{res:bool}
 {$True$}
 {$res \igobs puedeIndexar(c,t)$}
 {Informa si se puede crear un nuevo indice.}
 {O($1$)}
 {Retorna res por referencia, no es modificable.}

  \operacion{coincidencias}{in r: registro, in cj: Conj(registro)}{res: Conj(ItConj(registro))}
 {$True$}
 {$res \igobs coincidencias(r,cj)$}
 {Devuelve el conjunto de registros de la tabla, que coinciden con los valores de r.}
 {O($Cardinal(cj)$)}
 {Retorna res por referencia.} 

  \operacion{hayCoincidencia}{in r: registro,in cjc: Conj(campo), in cjr: Conj(registro)}{res:bool}
 {$True$}
 {$res \igobs hayCoincidencia(r,cjc,cjr)$}
 {Retorna true si algun registro del conjunto cjr, coincide con r en todos los valores de los campos de cjc.}
 {O($Cardinal(cjr)$)}
 {Retorna res por referencia, no es modificable.} 


 \operacion{combinarRegistros}{in c: campo,in cj1: Conj(registro), in cj2: Conj(registro)}{$\hfill$$\hfill$$\hfill$$\hfill$$\hfill$$\hfill$$\hfill$
 res: conj(registro)}
 {$True$}
 {$res \igobs combinarRegistros(c,cj1,cj2)$}
 {Combina los valores de los registros para el campo dado por parametro.}
 {O($Cardinal(cj1)+Cardinal(cj2)$)}
 {Retorna res por referencia, es modificable.}

  \operacion{dameColumna}{in c: campo, in cj: Conj(registro)}{res: Conj(dato)}
 {$True$}
 {$res \igobs dameColumna(c,cj1,cj2)$}
 {Reune en un conjunto los valores del campo pasado por parametro.}
 {O($Cardinal(cj)*Log(Cardinal(cj))$)}
 {Retorna res por referencia, no es modificable.} 

  \operacion{mismosTipos}{in r: registro,in t: tab}{res: bool}
 {campos(r)$\subseteq$campos(t)}
 {$res \igobs mismosTipos(r,t)$}
 {Compara los tipos correspondientes a los campos del registro y la tabla.}
 {O($1$)}
 {Retorna res por referencia, no es modificable.} 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Representación}

\serc{Tabla}
{\donde{tab}
{ 
\tupla{
  		Nombre: String,
		Registros: Conj(Registro),
		Campos: \mbox{DiccString(Campo,Tipo)},
		Claves: \mbox{ConjString(Campo)},
		IndiceS: \tupla{CampoI: campo, EnUso: bool, Indice: DiccString(\mbox{string, Conj(ItConj(Registro)))}, Min: Dato, Max: Dato},
		IndiceN: \tupla{CampoI: campo, EnUso: bool, Indice: DiccNat(\mbox{nat, Conj(ItConj(Registro)))}, Min: Dato, Max: Dato},
		\#Accesos: Nat}
}
}

  
\subsubsection*{Invariante de representación}

\begin{enumerate}
% Las claves estan en los campos.
\item	t.Claves esta inclido o es igual a t.Campos.
% 
\item	t.Nombre es un string acotado.
% Los campos de cada registro es igual a los campos de la tabla.
\item	Para todo registro r de t.Registros, entonces Campos(r) es igual al t.Campos.
% Los campos de cada registro, tienen el mismo tipo que los campos de la tabla.
\item	Para todo registro r de t.Registros y para todo campo c de Campos(r), entonces Tipo?(Significado(r,c)) es igual Significado(t.Campos, c).
% Si el indice esta EnUso y tiene un campo que pertenece a t.Campos, para toda clave c de t.IndiceS.Indice, el significado de Significado(t.IndiceS.Indice, c) esta incluido en t.Registro.
\item	Si t.IndiceS.EnUso es true y t.IndiceS.CampoI pertenece a t.Campos, entonces para todo Dato d, si Definido?(t.IndiceS.Indice, d) es true, entonces Significado(t.IndiceS.Indice, d) esta incluido o es igual a t.Registros.
% Todo registro de la tabla pertenece a algun significado de t.IndiceS.Indice
\item	Si t.IndiceS.EnUso es true y t.IndiceS.CampoI pertenece a t.Campos, entonces para todo registro r de t.Registros entonces Definido?(t.IndiceS.Indice, Significado(r, t.IndiceS.CampoI)) es true y r pertenece a Significado(t.IndiceS.Indice, Significado(r, t.IndiceS.CampoI)).
%
\item	Lo anterior tambien aplica para t.IndiceN.Indice
  \item El valor de e.\#Accesos debe ser la cantidad de registros agregados, la cantidad de registros borrados
\end{enumerate}

%\rep{tab}{e}True $\iff$\\
%(1.) $(\forall r: registro)(Pertenece?(e.registros, r)$\yluego$(\forall c: campo)())$
%  \item Para todos los registros de r, el tipo de los datos de las columnas de r, deben coincidir con los tipos de las columnas en e.campos.
%  \item Todas las columnas de e.campos y su tipo, deben coincidir con los campos y tipo de todos los registros de e.registros.
%  \item El nombre de la tabla que figura en e.nombre, es un string de longitut acotada.
%  \item Para todo registro r de e.registros y para todo campo c de e.Indices.DiccClaves, se debe cumplir que si tenemos valor $\larr$ Significado(r, c) y ind $\larr$ Significado(e.Indices, c). Al evaluar que r $\in$ Significado(ind, valor) y deben ser del mismo tipo.
%  \item Para todo campo c, que pertenece a e.Indices.DiccClaves, si tenemos que  ind $\larr$ Significado(e.Indices, c), y para todo dato d perteneciente a ind.DiccClaves entonces Significado(ind, d) esta incluido o es igual a e.registros.
%  \item Para todo registro r perteneciente  a e.registros r.DiccClaves es igual a e.campos.DiccClaves.
%  \item El valor de e.\#Accesos debe ser la cantidad de registros agregados, la cantidad de registros borrados, mas la cantidad de indices creados.


%\subsubsection*{Función de representaciòn}
%\rep{tab}{Tabla}{s}{cs}
%$s.campus \igobs campus(cs)$ $\l ,Mand$ \\
%$s.estudiantes \igobs estudiantes(cs)$ $\land$ \\
%$s.hippies \igobs hippies(cs)$ $\land$ \\
%$s.agentes \igobs agentes(cs)$ $\land$ \\
%$((\paratodo{nombre}{n}) s.hippies.definido(n) \impluego s.hippies.Significado(n) \igobs posEstYHippie(n,cs)$ $\lor$ \\
%$(\paratodo{nombre}{n}) s.estudiantes.definido(n) \impluego s.estudiantes.Significado(n) \igobs posEstYHippie(n,cs))$ \\
%$(\paratodo{placa}{pl}) s.agentes.definido(pl) \impluego s.estudiantes.Significado(pl).pos \igobs posAgente(pl,cs))$ \\
%$(\paratodo{placa}{pl}) s.agentes.definido(pl) \impluego s.estudiantes.Significado(pl).cantSanciones \igobs cantSanciones(pl,cs))$ \\
%$(\paratodo{placa}{pl}) s.agentes.definido(pl) \impluego s.estudiantes.Significado(pl).cantCapturas \igobs cantCapturas(pl,cs))$ \\

\subsubsection*{Función de abstracción}
\abs{tab}{Tabla}{s}{t}
$s.Nombre \igobs nombre(t)$ $\land$ $s.Claves \igobs claves(t)$ $\land$ \\
$s.Indices \igobs indices(t)$ $\land$ 
$s.Registros \igobs registros(t)$ $\land$ 
$s.Campos.DiccClaves \igobs campos(t)$ $\land$ 
$s.\#Accesos \igobs cantidadDeAccesos(t)$ $\land$ \\
$((\paratodo{campo}{c}) Definido?(s.Campos, c) \impluego Significado(s.Campos, c) \igobs tipoCampo(c, t))$ \\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\subsection{Algoritmos}

\algoritmo{nombre}{in t:tab}{res:string}{
  \State $res \larr t.Nombre$ \complejidad{O(1)}
}{O(1)}

\algoritmo{claves}{in t:tab}{res:ConjString(campo)}{
  \State res $\larr$ t.Claves \complejidad{O(1)}
}{O(1)}

\algoritmo{indices}{in t:tab}{res:ConjString(campo)}{
  \State	ConjString(campo)res $\larr$ vacio();
  \If{t.IndiceS.EnUso}
		\State AgregarRapido(res, t.IndiceS.CampoI) \complejidad{O(1)}
  \EndIf
  \If{t.IndiceN.EnUso}
		\State AgregarRapido(res, t.IndiceN.CampoI) \complejidad{O(1)}
  \EndIf
}{O(1)}

\algoritmo{campos}{in t:tab}{res:ConjString(campo)}{
  \State $res \larr Claves(t.Campos)$ \complejidad{O(1)}
}{O(1)} % en otras operaciones tiene q figurar ese conjunto

\algoritmo{tipoCampo}{in c:campo, in t:tab}{res:Tipo}{
  \State $res \larr Significado(t.Campos, c)$ \complejidad{O(1)}
}{O(1)}

 \algoritmo{registros}{in t:tab}{res:Conj(registro)}{
    \State $res \larr t.registros $ \complejidad{$\theta$(1)}
	\State Se retorna el conjunto por referencia
 }{$\theta$(1) }

  \algoritmo{cantDeAccesos}{in t:tab}{res:nat}{
    \State $res \larr t.cantDeAccesos$ \complejidad{$\theta$(1)}
 }{$\theta$(1)}
 
 %%%%%%%%%%%%% generadores
 
\newpage
\algoritmo{nuevaTabla}{in nombre: string, in claves: conj(campo), in columnas: registro}{res: tab}{
	\State Conj(registro) Registros $\larr$ Vacio() \complejidad{O(1)}
	\State DiccString(campo, tipo) Campos $\larr$ Vacio() \complejidad{O(1)}
	\State ConjString(campo) Claves\_ $\larr$ Vacio() \complejidad{O(1)}
	\State Dato d $\larr$ Obtener(columnas, Siguiente(CrearIt(claves)))
	\State IndiceS $\larr <  Siguiente(CrearIt(claves)), False, Vacio(), d, d  >$ 		\complejidad{O(1)}
	\State IndiceN $\larr <  Siguiente(CrearIt(claves)), False, Vacio(), d, d  >$ 		\complejidad{O(1)}
	\State \#Acessos $\larr$ 0 \complejidad{O(1)}
	\State res $   \larr <  nombre, Registros, Campos, Claves\_, IndiceS, IndiceN, 0  >$ 		\complejidad{O(1)}
	%Agrego los campos al diccString
	\State itcampos $\larr$ crearItConj(Campos(columnas)) 				\complejidad{O(1)}
	\While{HaySiguiente(itcampos)}										\complejidad{O(1)}
	\State Este while es O(1) y se debe a que el cardinal de campos a iterar es acotado.			
					\State	valor $\larr$ Significado(columnas, Siguiente(itcampos)) \complejidad{O(1)}
					\State	DefinirRapido(res.Campos, Siguiente(itcampos), Tipo?(valor)) \complejidad{O(1)}
					\State	Avanzar(itcampos) \complejidad{O(1)}
	\EndWhile \\
	\State itclaves $\larr$ crearItConj(claves) 				\complejidad{O(1)}
	\State Paso los campos claves de un conj al conjString
	\While{HaySiguiente(itclaves)}										\complejidad{O(1)}
	\State Esto se debe a que \# de campos a iterar es acotada.			
					\State	AgregarRapido(res.Claves, Siguiente(itclaves)) \complejidad{O(L)}
					\State	Avanzar(itcampos) \complejidad{O(1)}
	\EndWhile
	\State Donde L es la longitud de la cadena string mas larga y acotada del parametro claves.
									
 }{$\theta$(1) }
 
\newpage
\algoritmo{agregarRegistro}{in r: registro, in/out t: tab}{}{
	\State Para poder acceder al registro, guardo el iterador al elemento
    \State itConj(Registro) nuevo $\larr$ AgregarRapido(t.Registros,r)	\complejidad{$\theta$(1)}
    \State t.\#Accesos++																	\complejidad{$\theta$(1)}
	\State Este registro debe ser indexado, si estos indices existieran.
	\If{t.IndiceS.EnUso}
					\State Para el indice traigo el valor del campo con el que se creo.
					\State valor	$\larr$	Significado(r, t.IndiceS.CampoI) \complejidad{$\theta$(L)}
					\If{Definido?(t.IndiceS.Indice, valor)} \complejidad{$\theta$(L)}
							\State viejo $\larr$ Significado(t.IndiceS.Indice, valor)\complejidad{$\theta$(L)}
							\State AgregarRapido(viejo, nuevo) \complejidad{$\theta$(L)}
					\Else
							\State viejo $\larr$ Vacio() \complejidad{$\theta$(1)}
							\State AgregarRapido(viejo, nuevo)\complejidad{$\theta$(L)}
							\State Definir(t.IndiceS.Indice, ValorString(valor), viejo) \complejidad{$\theta$(L)}
							\State Como ingresamos un nuevo valor, actualizamos el min y max
							\If{t.IndiceS.Min$\geq$valor} \complejidad{$\theta$(L)}
								\State t.IndiceS.Min $\larr$ Copiar(valor)\complejidad{$\theta$(L)}
							\EndIf
							\If{valor$\geq$t.IndiceS.Max}\complejidad{$\theta$(L)}
								\State t.IndiceS.Max $\larr$ Copiar(valor)\complejidad{$\theta$(L)}
							\EndIf
					\EndIf
	\State Donde L es la longitud del valor string agregado a t.IndiceS						
	\EndIf
	\If{t.IndiceN.EnUso}
					\State Para el indice traigo el valor del campo con el que se creo.
					\State valor	$\larr$	Significado(r, t.IndiceN.CampoI) \complejidad{$\theta$(Log(n)}
					\If{Definido?(t.IndiceN.Indice, valor)} \complejidad{$\theta$(log(n))}
							\State viejo $\larr$ Significado(t.IndiceN.Indice, valor)\complejidad{$\theta$(1)}
							\State AgregarRapido(viejo, nuevo) \complejidad{$\theta$(1)}
					\Else
							\State viejo $\larr$ Vacio() \complejidad{$\theta$(1)}
							\State AgregarRapido(viejo, nuevo) \complejidad{$\theta$(1)}
							\State Definir(t.IndiceN.Indice, valor, viejo) \complejidad{$\theta$(Log(n))}
							\State Como ingresamos un nuevo valor, actualizamos el min y max
							\If{t.IndiceN.Min$\geq$valor} \complejidad{$\theta$(1)}
								\State t.IndiceS.Min $\larr$ Copiar(valor)\complejidad{$\theta$(1)}
							\EndIf
							\If{valor$\geq$t.IndiceS.Max}\complejidad{$\theta$(1)}
								\State t.IndiceN.Max $\larr$ Copiar(valor)\complejidad{$\theta$(1)}
							\EndIf
					\EndIf
	\EndIf
	\State Donde n es la cantidad de registros y L es la longitudad maxima de un valor String.						
}{$\theta$(Log(n))}

\newpage
\algoritmo{borrarRegistro}{in crit: registro,in/out t: tab}{}{
	\State	Campo c $\larr$ Siguiente(CrearIt(Campos(crit)))	\complejidad{$\theta$(1)} %chequear
	\State 	Dato valor $\larr$	Copiar(Significado(crit, c))			\complejidad{$\theta$(L)}
	\State Sabemos que c esta incluido en claves(t)
	\State si hay un indice de un campo clave borrar es O(log(n)) u O(L) en peor caso
	\If{t.IndiceS.EnUso $\land$ t.IndiceS.CampoI=c}
		\State String S $\larr$ ValorString(valor) 
		\If{Definido?(t.IndiceS.Indice, S)}				\State	itConj(registro) itr $\larr$ Significado(t.IndiceS.Indice, S) 																																\complejidad{$\theta$(1)}
				\State Borro el registro del conjunto de registros
				\State EliminarSiguiente(itr) \complejidad{$\theta$(1)}
				\State Borro el registro del indice,
				\State Borrar(t.IndiceS.Indice, S) \complejidad{$\theta$(1)}
				\If{t.IndiceS.Min=valor}
					\State t.IndiceS.Min$\larr$ Minimo(Claves(t.IndiceS))
				\EndIf
				\If{t.IndiceS.Max=valor}
					\State t.IndiceS.Max$\larr$ Maximo(Claves(t.IndiceS))
				\EndIf
				\State Dado que el crit solo tiene un campo clave, siempre elimino un registro.
				t.\#Accesos++
		\EndIf
	\Else
		\If{t.IndiceN.EnUso $\land$ t.IndiceN.CampoI=c}
				\State N $\larr$ ValorNat(valor)
				\If{Definido?(t.IndiceN.Indice, valor)}
						\State	itConj(registro) itr $\larr$ Significado(t.IndiceN.Indice, valor) 		                        																									\complejidad{$\theta$(1)}
						% Borro el registro del indice,
						\State	EliminarSiguiente(itr) \complejidad{$\theta$(1)}
						\State	Borrar(t.IndiceN.Indice, valor) \complejidad{$\theta$(1)}
						\If{t.IndiceN.Min=valor} \complejidad{$\theta$(1)}
							\State t.IndiceS.Min$\larr$ Minimo(Claves(t.IndiceN)) \complejidad{$\theta$(Log(n))}
						\EndIf
						\If{t.IndiceN.Max=valor} \complejidad{$\theta$(1)}
							\State t.IndiceS.Max$\larr$ Maximo(Claves(t.IndiceN))\complejidad{$\theta$(Log(n))}
						\EndIf
						\State Dado que el crit solo tiene un campo clave, siempre elimino un registro.
						t.\#Accesos++
				\EndIf
						%ya tengo el indice ahora pregunto si ese valor de dato esta definido
		\Else
			\State No hay indice para el campo clave de criterio pasado por parametro
			\State itConj(registro) cr $\larr$ CrearItConj(t.registros)\complejidad{$\theta$(1)}
			\While{HaySiguiente(cr)}\complejidad{$\theta$(Cardinal(t.registros))}
					\State valorR $\larr$ Significado(Siguiente(cr), c)		\complejidad{$\theta$(1)}
					\If{valorR=valor}
						\State EliminarSiguiente(cr);									\complejidad{$\theta$(1)}
						\State Dado que el crit solo tiene un campo clave, siempre elimino solo un registro.
						t.\#Accesos++
					
					\EndIf
					\State Avanzar(cr)													\complejidad{$\theta$(1)}
			\EndWhile
			\State La complejidad de la operacion borrar depende de si hay o no indices
			\State para el campo del crit pasado por parametro.
			\State En caso de que exista dicho indice, en peor caso eliminar es O(Log(n)) u O(L)
			\State siendo n la cantidad de registros de la tabla pasada por parametro y L
			\State el valor string mas largo definido en la tabla.
			\State En caso de no haber tal indice es O(n).			
		\EndIf
	\EndIf
}{O(n)}
\newpage
\algoritmo{indexar}{in c: campo, in/out t: tab}{}{
	\If{tipoCampo(c,t)}
		\State t.IndiceN.EnUso $\larr$ True
	\Else
		\State t.IndiceS.EnUso $\larr$ True
	\EndIf
	\State	cr $\larr$ CrearItConj(t.registros)
	\If{tipoCampo?(c,t)}
			\While{HaySiguiente(cr)}
						\State 	Dato	valor $\larr$ Significado(Siguiente(cr), c)
						\State 	itConj(registro) itr $\larr$ CrearItConj(Siguiente(cr))
						\If{Definido?(t.IndiceN.Indice, valor)}
									\State	regviejos $\larr$ Significado(indC, valor)
									\State	AgregarRapido(regviejos, itr)
						\Else
									\State 	conj(registro) nuevo $\larr$ Vacio()
									\State 	AgregarRapido(nuevo, itr)
									\State	DefinirRapido(t.IndiceN.Indice, valor, nuevo)
						\EndIf
						\State	Avanzar(cr)
			\EndWhile
	\EndIf
	\If{$\neg$tipoCampo?(c,t)}
			\While{HaySiguiente(cr)}
						\State 	Dato	valor $\larr$ Significado(Siguiente(cr), c)
						\State 	itConj(registro) itr $\larr$ CrearItConj(Siguiente(cr))
						\If{Definido?(t.IndiceS.Indice, valor)}
									\State	regviejos $\larr$ Significado(indC, valor)
									\State	AgregarRapido(regviejos, itr)
						\Else
									\State 	conj(registro)	 nuevo $\larr$ Vacio()
									\State 	AgregarRapido(nuevo, itr)
									\State	DefinirRapido(t.IndiceN.Indice, valor, nuevo)
						\EndIf
						\State	Avanzar(cr)
			\EndWhile	
	\EndIf
}{$\theta$(1)}

  \algoritmo{puedoInsertar?}{in r:registro, in t:tab}{res:bool}{
    \State res $\larr$ campatible(r,t) $\land$ $\neg$hayCoincidencia( r, r.ClavesDicc, registros(t)  )  \complejidad{$\theta$(calcular))}
 }{$\theta$(calcular)}


  \algoritmo{compatible}{in r:registro, int t:tab}{res:bool}{
  		\State bool valor $\larr$ True
 		\If{Cardinal(campos(r))=Cardinal(t.Campos.DiccClaves)}
				  \State itcampos $\larr$ CrearItString(t.Campos.DiccClaves)
				  \While{valor $\land$ HaySiguiente(itcampos)} \complejidad{$\theta$(1)}
				  			\State Campo c $\larr$ Siguiente(itcampos) \complejidad{$\theta$(1)}
							\State valor $\larr$ Definido?(r, c) \complejidad{$\theta$(1)}
				  \EndWhile
		\Else
					\State valor $	\larr$ False  \complejidad{$\theta$(1)}
 		\EndIf
 		\State res $\larr$ valor  $\yluego$ mismosTipos(r,t)  \complejidad{$\theta$(1)}	
 		\State El costo del While es O(1) ya que la cantidad de campos de la tabla es acotado
 }{O($1$)}



 
  \algoritmo{minimo}{in c:campo, in t:tab}{res:dato}{
	\State	Si hay indice en el campo c, debe ser de complejidad O(1)
	\If{t.IndiceS.EnUso $\land$ t.IndiceS.CampoI=c}
		\State	Sabemos que hay un indice string para el campo c
		\State	res $\larr$ t.IndiceS.Min \complejidad{$\theta$(Cardinal(t.registros))}
	\Else
		\If{t.IndiceN.EnUso $\land$ t.IndiceN.CampoI=c}
			\State	Sabemos que hay un indice string para el campo c
			\State	res $\larr$ t.IndiceN.Min\complejidad{$\theta$(Cardinal(t.registros))}
%		\Else
%			\State	Si no hay indice para este campo hay que buscar el valor en O(n)
%			\State	ItConj(Registro) itr $\larr$ t.Registros
%			\State	Dato min\_ $\larr$ Significado(Siguiente(itr), c)
%			\While{HaySiguiente?(itr)}
%				\State	Dato sig $\larr$ Significado(Siguiente(itr), c)
%				\If{sig$\geq$min\_}
%						\State	min\_$\larr$ Copiar(sig)
%				\EndIf
%				\State Avanzar(itr)
%			\EndWhile
		\EndIf
	\EndIf
%  	\State 	res $\larr$ min( dameColumna(  c, t.registros  ))\complejidad{$\theta$(Cardinal(t.registros))}
 }{O(1)}
 
   \algoritmo{maximo}{in c:campo, in t:tab}{res:dato}{
	\State	Si hay indice en el campo c, debe ser de complejidad O(1)
	\If{t.IndiceS.EnUso $\land$ t.IndiceS.CampoI=c}
		\State	Sabemos que hay un indice string para el campo c
		\State	res $\larr$ t.IndiceS.Max \complejidad{$\theta$(Cardinal(t.registros))}
	\Else
		\If{t.IndiceN.EnUso $\land$ t.IndiceN.CampoI=c}
			\State	Sabemos que hay un indice string para el campo c
			\State	res $\larr$ t.IndiceN.Max\complejidad{$\theta$(Cardinal(t.registros))}
%		\Else
%			\State	Si no hay indice para este campo hay que buscar el valor en O(n)
%			\State	ItConj(Registro) itr $\larr$ t.Registros
%			\State	Dato max\_ $\larr$ Significado(Siguiente(itr), c)
%			\While{HaySiguiente?(itr)}
%				\State	Dato sig $\larr$ Significado(Siguiente(itr), c)
%				\If{sig$\geq$max\_}
%						\State	max\_$\larr$ Copiar(sig)
%				\EndIf
%				\State Avanzar(itr)
%			\EndWhile
		\EndIf
	\EndIf
}{O(1)}

  \algoritmo{puedeIndexar}{in c:campo, in t:tab}{res:bool}{
					\If{TipoCampo(c, t)}
							\State res $\larr$ $\neg$(t.IndiceN.EnUso)
					\Else
							\State res $\larr$ $\neg$(t.IndiceS.EnUso)
					\EndIf
 }{O(1)}


\algoritmo{hayCoincidencia}{in r:registro, in cc:ConjString(campo), in cr:Conj(registro)}{res:bool}{
  	\State	itcr $\larr$ CrearItConj(cr)   \complejidad{$\theta$(1)}  
    \State	res $\larr$ false                   \complejidad{$\theta$(1)}  
  	\While{HaySiguiente(itcr)}		\complejidad{$\theta$(Cardinal(cr))}  
				\State	res $\larr$ 	coincideAlguno(r,cc,Siguiente(itcr)) $\lor$res \complejidad{$\theta$(1)}  
				\State	Avanzar(itcr) 			\complejidad{$\theta$(1)}  
	\EndWhile   
}{O(Cardinal(cr))}


%  \operacion{coincidencias}{in r: registro, in cj: Conj(registro)}{res: Conj(ItConj(registro))}
% {$True$}
% {$res \igobs coincidencias(r,cj)$}
% {Devuelve el conjunto de registros de la tabla, que coinciden con los valores de r.}
% {O($L+Log(n)$)}
% {Retorna res por referencia,.}

 \algoritmo{coincidencias}{in crit:registro, in cr:Conj(registro)}{res:Conj(registro)}{
 	\State Conj(registro) salida	$\larr$ Vacio()
%	\If{Cardinal(Indices(t))$\geq$1}
%	\State Si hay indice, obtengo los valores de crit para los campos de los indices que existan
%		\If{t.IndiceS.EnUso}
%				\State	vals $\larr$ Significado(crit, t.IndiceS.CampoI)
%				\State	Conj(registro) rind	$\larr$ Significado(t.IndiceS.Indice, vals)
%				\State	itrind $\larr$ CrearItConj(rind)
%				\While{HaySiguiente(itrind)}
%						\State r1 $\larr$ Siguiente(Siguiente(itcr))
%						\State Esta ultima linea, se debe a que estoy iterando, 
%						\State iteradores de conjunto al elemento
%						\If{coincidenTodos(r1,t.Claves,crit)}
%								\State AgregarRapido(salida, r1) 
%								\State Agrego por referencia.
%						\EndIf
%						\State Avanzar(itcr)
%				\EndWhile
%		\Else
%				\If{t.IndiceN.EnUso}
%						\State	valn $\larr$ Significado(crit, t.IndiceN.CampoI)
%						\State	Conj(registro) rind	$\larr$ Significado(t.IndiceN.Indice, valn)
%						\State	itrind $\larr$ CrearItConj(rind)
%						\While{HaySiguiente(itrind)}
%								\State r1 $\larr$ Siguiente(Siguiente(itcr))
%								\State Esta ultima linea, se debe a que estoy iterando, 
%								\State iteradores de conjunto al elemento
%								\If{coincidenTodos(r1,t.Claves,crit)}
%										\State AgregarRapido(salida, r1) 
%										\State Agrego por referencia.
%								\EndIf
%								\State Avanzar(itcr)
%						\EndWhile
%				\EndIf
%		\EndIf
%		\State Como buscamos los registros que tenga los mismo datos que crit,
%		\State los registros que cumplan dicho requerimiento. Si aparecen en uno
%		\State de los indices, en el otro tambien apareceran. Entonces solo comparo
%		\State los registros que tienen los mismos datos para los campos de los indices
%		\State correspondientes.
%	\EndIf
	\State Debemos comparar todos los registros de cr.
	\State y agregarlos al conjunto de registros salida
  	\State 	itcr $\larr$ CrearItConj(cr)						
  	\While{HaySiguiente(cr)}							\complejidad{$\theta$(Cardinal(cr))}
				\If {coincidenTodos(crit,campos(crit),Siguiente(itcr))}  \complejidad{$\theta$(1)}
								\State	AgregarRapido(salida,Siguiente(itcr)) 						\complejidad{$\theta$(1)}
				\EndIf				
				\State	Avanzar(itcr);																\complejidad{$\theta$(1)}
	\EndWhile   
 }{O(Cardinal(cr))}


\algoritmo{combinarRegistros}{in c:campo, in cr1:Conj(registro), in cr2:Conj(registro)}{res:Conj(registros)}{
	\State	itcr1 $\larr$ CrearItConjString(cr1) \complejidad{$\theta$(1)}  
	\State	copiacr2 $\larr$ Copiar(cr2)		\complejidad{$\theta$(Cardinal(cr2))}  
  	\While{HaySiguiente(itcr1)}         \complejidad{$\theta$(Cardinal(cr1))}
		\State	combinarTodos(c,Siguiente(itcr1),copiacr2) \complejidad{$\theta$(1)}	%combinarTodos deberia hacer por copia asi no afecta el original.
				\State	Avanzar(itcr1) 					\complejidad{$\theta$(1)}  
	\EndWhile   
  	\State	res $\larr$ copiacr2                      \complejidad{$\theta$(1)}
}{O(Cardinal(cr1))}

 
\algoritmo{dameColumna}{in c:campo, in cr:Conj(registro)}{res:Conj(dato)}{
  	\State 	Conj(Dato)	cj $\larr$ vacio();				\complejidad{$\theta$(1)}
	\State	La idea es no agregar el mismo dato dos veces, para eso uso un conj
	\State	del tipo de dato de la columna para hacer consulta.
	\If{Cardinal(cr)$\geq$1}\complejidad{$\theta$(1)}		
			\State	Tvalor $\larr$ Tipo?(Significado(Siguiente(CrearIt(cr))), c)\complejidad{$\theta$(1)}		
			\If{Tvalor}
					\State	ConjLog(nat) cj $\larr$ Vacio()\complejidad{$\theta$(1)}		
			\Else
					\State	ConjString(string) cj $\larr$ Vacio()\complejidad{$\theta$(1)}		
			\EndIf
			\State 	itcr $\larr$ CrearItConj(cr)					\complejidad{$\theta$(1)}		
			\State	cjd $\larr$ Vacio()
		  	\While{HaySiguiente(itcr)}						\complejidad{$\theta$(Cardinal(cr))}
		  				\State Dato data $\larr$ Significado(Siguiente(itcr), c)
		  				\If{Tvalor}
		  						\If {$\neg$Pertenece?(cj, valorNat(data))}\complejidad{$\theta$(Log(n))}
										\State 	AgregarRapido(cjd, data)\complejidad{$\theta$(1)}
										\State	AgregarRapido(cj, valorNat(data))\complejidad{$\theta$(1)}
								\EndIf	
						\Else
		  						\If {$\neg$Pertenece?(cj, valorString(data))}\complejidad{$\theta$(1)}
										\State 	AgregarRapido(cjd, data)\complejidad{$\theta$(1)}
										\State	AgregarRapido(cj, valorString(data))\complejidad{$\theta$(1)}
								\EndIf	
						\EndIf
				\State	Avanzar(itcr);							\complejidad{$\theta$(1)}
			\EndWhile     	
	\EndIf
	\State res $\larr$ cjd
	\State Si la columna es de tipo String, la complejidad es O(n), en caso de ser
	\State de tipo Nat la complejidad es O(nlog(n)).
	\State El cardinal de res es la cantidad de datos distintos.
}{O(nlog(n))}
 
\algoritmo{mismosTipos}{in r:registro, in t:tab}{res:bool}{
  	\State 	valor $\larr$ True										\complejidad{$\theta$(1)}
  	\State 	itconjClaves $\larr$ CrearItConj(r.ClavesDicc) \complejidad{$\theta$(1)}
  	\While{valor $\land$ HaySiguiente(itconjClaves)}				\complejidad{$\theta$(1)}
  					\State	val1$\larr$ tipo?(Significado(r,Siguiente(itconjClaves))) \complejidad{$\theta$(1)}
  					\State	val2$\larr$ tipoCampo(Siguiente(itconjClaves),t)	\complejidad{$\theta$(1)}
					\State	valor $\larr$ (val1 = val2)	\complejidad{$\theta$(1)}
					\State	Avanzar(cr);								\complejidad{$\theta$(1)}
	\EndWhile     	
	\State	res $\larr$ valor
 }{O(1)}


  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Algoritmos operaciones auxiliares}
