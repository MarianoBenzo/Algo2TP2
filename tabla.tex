
%\section{Pos es tupla(x:Nat, y:Nat)}

%\section{Placa es Nat}

%\section{Nombre es String}

\section{Tabla}

\subsection{Interfaz}

\sexc{tabla}
\generos{}{DiccString(string, alfha),} {DiccNat(nat, beta),}{Nat, String, Dato, Campo, Tipo, Registro, ConjString, ConjNat.}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Operaciones}


%%%%%% observadores basicos %%%%%%

\operacion{nombre}{in t: tab }{res : string}
 {true}
 {$res \igobs nombre(t)$}
 {Devuelve el nombre de la tabla ingresada por parametro.}
 {O($1$)}
 {Se retorna res por copia, por ser un tipo basico.}

\operacion{claves}{in t: tab }{res : ConjString(campo)}
 {true}
 {$res \igobs claves(t)$}
 {Devuelve un conjunto de campos clave en la tabla ingresada por parametro.}
 {O($1$)}
 {Se devuelve res por referencia, no es modificable.}
 
\operacion{indices}{in t: tab }{res : ConjString(campo)}
 {true}
 {$res \igobs indices(t)$}
 {Devuelve un conjunto campos con los que se crearon los indices.}
 {O($1$)}
 {Se devuelve res por referencia, no es modificable.}
 
\operacion{campos}{in t: tab }{res : ConjString(campo)}
 {true}
 {$res \igobs campos(t)$}
 {Devuelve un conjunto de todos los campos de la tabla.}
 {O($1$)}
 {Se devuelve res por referencia, no es modificable.}

\operacion{tipoCampo}{in c: campo,in t: tab }{res : tipo}
 {c $\in$ campos(t)}
 {$res \igobs tipoCampo(t)$}
 {Devuelve el tipo del campo c en la tabla.}
 {O($1$)}
 {Se devuelve res por referencia, no es modificable.}
 
\operacion{registros}{in t: tab }{res : itConj(registro)}
 {true}
 {$res \igobs registros(t)$}
 {Devuelve un conjunto a los registros de la tabla.}
 {O($1$) }
 {Se devuelve res referencia.}

 
\operacion{cantidadDeAcccesos}{in t: tab }{res : nat}
 {true}
 {$res \igobs cantidadDeAccesos(t)$}
 {Devuelve la cantidad de modificaciones de la tabla ingresada por parametro.}
 {O($1$)}
 {Se devuelve res por copia.}

 
 %%%%%% generadores %%%%%%%
 
 \operacion{nuevaTabla}{in nombre: string, in claves: conjString(campo), in columnas: registro }{res : tab}
 {$\neg\emptyset$?(claves) $\land$ claves$\subseteq$campos(columnas)}
 {$res \igobs nuevaTabla(t)$}
 {Crea una tabla sin registros.}
 {O($1$)}
 {}

 \operacion{agregarRegistro}{in r: registro, in/out t: tab}{}
 {t\_0=t $\land$ campos(r)$\igobs$campos(t) $\land$ puedorInsertar?(r,t)}
 {agregarRegistro(r,t\_0)}
 {Agrega un registro a la tabla pasada por parametro.}
 {O($Log(n)$)}
 {Agrega el registro r por referencia.} 
 
 \operacion{borrarRegistro}{in crit: registro, in/out t: tab}{}
 {t\_0=t $\land$ $\#$(campos(r))=1 $\yluego$ Siguiente(CrearIt(campos(crit)))$\in$claves(t)}
 {borrarRegistro(r,t\_0)}
 {Borra los registros que cumplan el criterio pasado por parametro.}
 {O($n$)}
 {} 
 
  \operacion{indexar}{in crit: registro, in/out t: tab}{}
 {t\_0=t $\land$ puedeIndexar(c,t)}
 {indexar(c,t\_0)}
 {Crea un indice en base al campo de crit.}
 {O($n$)}
 {} 	
 
%%%%%% Otras Operaciones %%%%%%%%%%%

 \operacion{puedoInsertar?}{in r: registro, in t: tab}{res:bool}
 {$true$}
 {$res \igobs puedoInsertar?(r,t)$}
 {Informa si el registro pasado por parametro no tiene valores repetidos con respectos a los registros existentes, para los campos clave en la tabla pasada por parametro.}
 {O($n$)}
 {Retorna res por referencia, no es modificable.} 
 
  \operacion{compatible}{in r: registro, in t: tab}{res:bool}
 {$true$}
 {$res \igobs compatible(r,t)$}
 {Informa si el registro pasado por parametro tiene correspondecia en los tipos de los campos de tabla pasada por parametro.}
 {O($1$)}
 {Retorna res por referencia, no es modificable.} 
 
  \operacion{minimo}{in c: campo, in t: tab}{res:dato}
 {$\neg\emptyset$?(registro(t)) $\land$ c$\in$indices(t)}
 {$res \igobs minimo(c,t)$}
 {Retorna el minimo entre los valores de la tabla para el campo c.}
 {O($L+Log(n)$)}
 {Retorna res por referencia.}
  
  \operacion{maximo}{in c: campo, in t: tab}{res:dato}
 {$\neg\emptyset$?(registro(t)) $\land$ c$\in$indices(t)}
 {$res \igobs maximo(c,t)$}
 {Retorna el maximo entre los valores de la tabla para el campo c.}
 {O($L+Log(n)$)}
 {Retorna res por referencia.} 

  \operacion{puedeIndexar}{in c: campo, in t: tab}{res:bool}
 {$True$}
 {$res \igobs puedeIndexar(c,t)$}
 {Informa si se puede crear un nuevo indice.}
 {O($1$)}
 {Retorna res por referencia, no es modificable.}

  \operacion{coincidencias}{in r: registro, in cj: Conj(registro)}{res: Conj(ItConj(registro))}
 {$True$}
 {$res \igobs coincidencias(r,cj)$}
 {Devuelve el conjunto de registros de la tabla, que coinciden con los valores de r.}
 {O($Cardinal(cj)$)}
 {Retorna res por referencia.} 

  \operacion{hayCoincidencia}{in r: registro,in cjc: Conj(campo), in cjr: Conj(registro)}{res:bool}
 {$True$}
 {$res \igobs hayCoincidencia(r,cjc,cjr)$}
 {Retorna true si algun registro del conjunto cjr, coincide con r en todos los valores de los campos de cjc.}
 {O($Cardinal(cjr)$)}
 {Retorna res por referencia, no es modificable.} 


 \operacion{combinarRegistros}{in c: campo,in cj1: Conj(registro), in cj2: Conj(registro)}{$\hfill \hfill \hfill \hfill \hfill \hfill \hfill$
 res: conj(registro)}
 {$True$}
 {$res \igobs combinarRegistros(c,cj1,cj2)$}
 {Combina los valores de los registros para el campo dado por parametro.}
 {O($Cardinal(cj1)+Cardinal(cj2)$)}
 {Retorna res por referencia, es modificable.}

  \operacion{dameColumna}{in c: campo, in cj: Conj(registro)}{res: Conj(dato)}
 {$True$}
 {$res \igobs dameColumna(c,cj1,cj2)$}
 {Reune en un conjunto los valores del campo pasado por parametro.}
 {O($Cardinal(cj)*Log(Cardinal(cj))$)}
 {Retorna res por referencia, no es modificable.} 

  \operacion{mismosTipos}{in r: registro,in t: tab}{res: bool}
 {campos(r)$\subseteq$campos(t)}
 {$res \igobs mismosTipos(r,t)$}
 {Compara los tipos correspondientes a los campos del registro y la tabla.}
 {O($1$)}
 {Retorna res por referencia, no es modificable.} 

 %%%%%%% AUXILIARES
 \operacion{BuscarEnTabla}{in c: campo,in t: tab}{res: Conj(ItConj(registro))}
 {c$\subseteq$campos(t)}
 {$res \igobs BuscarEnTabla(c, t)$}
 {}
 {O($xxxxx$)}
 {Retorna res por referencia, es modificable.} 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Representación}

\serc{Tabla}
{\donde{tab}
{ 
\tupla{
  		Nombre: String,
		Registros: Conj(Registro),
		Campos: \mbox{DiccString(Campo,Tipo)},
		Claves: \mbox{ConjString(Campo)},
		IndiceS: \tupla{CampoI: campo, EnUso: bool, Indice: DiccString(\mbox{string, Conj(ItConj(Registro)))}, Min: Dato, Max: Dato},
		IndiceN: \tupla{CampoI: campo, EnUso: bool, Indice: DiccNat(\mbox{nat, Conj(ItConj(Registro)))}, Min: Dato, Max: Dato},
		\#Accesos: Nat}
}
}

  
\subsubsection*{Invariante de representación}

\begin{enumerate}
% Las claves estan en los campos.
\item	t.Claves esta inclido o es igual a t.Campos.
% 
\item	t.Nombre es un string acotado.
% Los campos de cada registro es igual a los campos de la tabla.
\item	Para todo registro r de t.Registros, entonces Campos(r) es igual al t.Campos.
% Los campos de cada registro, tienen el mismo tipo que los campos de la tabla.
\item	Para todo registro r de t.Registros y para todo campo c de Campos(r), entonces Tipo?(Significado(r,c)) es igual Significado(t.Campos, c).
% Si el indice esta EnUso y tiene un campo que pertenece a t.Campos, para toda clave c de t.IndiceS.Indice, el significado de Significado(t.IndiceS.Indice, c) esta incluido en t.Registro.
\item	Si t.IndiceS.EnUso es true y t.IndiceS.CampoI pertenece a t.Campos, entonces para todo Dato d, si Definido?(t.IndiceS.Indice, d) es true, entonces Significado(t.IndiceS.Indice, d) esta incluido o es igual a t.Registros.
% Todo registro de la tabla pertenece a algun significado de t.IndiceS.Indice
\item	Si t.IndiceS.EnUso es true y t.IndiceS.CampoI pertenece a t.Campos, entonces para todo registro r de t.Registros entonces Definido?(t.IndiceS.Indice, Significado(r, t.IndiceS.CampoI)) es true y r pertenece a Significado(t.IndiceS.Indice, Significado(r, t.IndiceS.CampoI)).
%
\item	Lo anterior tambien aplica para t.IndiceN.Indice
  \item El valor de e.\#Accesos debe ser la cantidad de registros agregados, la cantidad de registros borrados
\end{enumerate}

%\rep{tab}{e}True $\iff$\\
%(1.) $(\forall r: registro)(Pertenece?(e.registros, r)$\yluego$(\forall c: campo)())$
%  \item Para todos los registros de r, el tipo de los datos de las columnas de r, deben coincidir con los tipos de las columnas en e.campos.
%  \item Todas las columnas de e.campos y su tipo, deben coincidir con los campos y tipo de todos los registros de e.registros.
%  \item El nombre de la tabla que figura en e.nombre, es un string de longitut acotada.
%  \item Para todo registro r de e.registros y para todo campo c de e.Indices.DiccClaves, se debe cumplir que si tenemos valor $\larr$ Significado(r, c) y ind $\larr$ Significado(e.Indices, c). Al evaluar que r $\in$ Significado(ind, valor) y deben ser del mismo tipo.
%  \item Para todo campo c, que pertenece a e.Indices.DiccClaves, si tenemos que  ind $\larr$ Significado(e.Indices, c), y para todo dato d perteneciente a ind.DiccClaves entonces Significado(ind, d) esta incluido o es igual a e.registros.
%  \item Para todo registro r perteneciente  a e.registros r.DiccClaves es igual a e.campos.DiccClaves.
%  \item El valor de e.\#Accesos debe ser la cantidad de registros agregados, la cantidad de registros borrados, mas la cantidad de indices creados.


%\subsubsection*{Función de representaciòn}
%\rep{tab}{Tabla}{s}{cs}
%$s.campus \igobs campus(cs)$ $\l ,Mand$ \\
%$s.estudiantes \igobs estudiantes(cs)$ $\land$ \\
%$s.hippies \igobs hippies(cs)$ $\land$ \\
%$s.agentes \igobs agentes(cs)$ $\land$ \\
%$((\paratodo{nombre}{n}) s.hippies.definido(n) \impluego s.hippies.Significado(n) \igobs posEstYHippie(n,cs)$ $\lor$ \\
%$(\paratodo{nombre}{n}) s.estudiantes.definido(n) \impluego s.estudiantes.Significado(n) \igobs posEstYHippie(n,cs))$ \\
%$(\paratodo{placa}{pl}) s.agentes.definido(pl) \impluego s.estudiantes.Significado(pl).pos \igobs posAgente(pl,cs))$ \\
%$(\paratodo{placa}{pl}) s.agentes.definido(pl) \impluego s.estudiantes.Significado(pl).cantSanciones \igobs cantSanciones(pl,cs))$ \\
%$(\paratodo{placa}{pl}) s.agentes.definido(pl) \impluego s.estudiantes.Significado(pl).cantCapturas \igobs cantCapturas(pl,cs))$ \\

\subsubsection*{Función de abstracción}
\abs{tab}{Tabla}{s}{t}
$s.Nombre \igobs nombre(t)$ $\land$ $s.Claves \igobs claves(t)$ $\land$ \\
$s.Indices \igobs indices(t)$ $\land$ 
$s.Registros \igobs registros(t)$ $\land$ 
$s.Campos.DiccClaves \igobs campos(t)$ $\land$ 
$s.\#Accesos \igobs cantidadDeAccesos(t)$ $\land$ \\
$((\paratodo{campo}{c}) Definido?(s.Campos, c) \impluego Significado(s.Campos, c) \igobs tipoCampo(c, t))$ \\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\subsection{Algoritmos}

\algoritmo{nombre}{in t:tab}{res:string}{
  \State $res \larr t.Nombre$ \complejidad{O(1) por ref}
}{O(1)}

\algoritmo{claves}{in t:tab}{res:ConjString(campo)}{
  \State res $\larr$ t.Claves \complejidad{O(1) por ref}
}{O(1)}

\algoritmo{indices}{in t:tab}{res:ConjString(campo)}{
  \State	ConjString(campo) res $\larr$ vacio();\complejidad{O(1)}
  \If{t.IndiceS.EnUso}\complejidad{O(1)}
		\State AgregarRapido(res, t.IndiceS.CampoI) \complejidad{O(1) por ref}
  \EndIf
  \If{t.IndiceN.EnUso}\complejidad{O(1)}
		\State AgregarRapido(res, t.IndiceN.CampoI) \complejidad{O(1) por ref}
  \EndIf
}{O(1)}

\algoritmo{campos}{in t:tab}{res:ConjString(campo)}{
  \State $res \larr DiccClaves(t.Campos)$ \complejidad{O(\# de campos)}
}{O(1)} % en otras operaciones tiene q figurar ese conjunto

\algoritmo{tipoCampo}{in c:campo, in t:tab}{res:Tipo}{
  \State $res \larr Significado(t.Campos, c)$ \complejidad{O(1)}
}{O(1)}

 \algoritmo{registros}{in t:tab}{res:Conj(registro)}{
    \State $res \larr t.registros $ \complejidad{O(1)}
	\State Se retorna el conjunto por referencia
 }{O(1) }

  \algoritmo{cantDeAccesos}{in t:tab}{res:nat}{
    \State $res \larr t.cantDeAccesos$ \complejidad{O(1) por ref}
 }{O(1)}
 
 %%%%%%%%%%%%% generadores
 
\newpage
\algoritmo{nuevaTabla}{in nombre: string, in claves: conj(campo), in columnas: registro}{res: tab}{
	\State Conj(registro) Registros $\larr$ Vacio() \complejidad{O(1)}
	\State DiccString(campo, tipo) Campos $\larr$ Vacio() \complejidad{O(1)}
	\State ConjString(campo) Claves\_ $\larr$ Vacio() \complejidad{O(1)}
	\State Dato d $\larr$ Obtener(columnas, Siguiente(CrearIt(claves)))
	\State IndiceS $\larr <  Siguiente(CrearIt(claves)), False, Vacio(), d, d  >$ 		\complejidad{O(1)}
	\State IndiceN $\larr <  Siguiente(CrearIt(claves)), False, Vacio(), d, d  >$ 		\complejidad{O(1)}
	\State \#Acessos $\larr$ 0 \complejidad{O(1)}
	\State res $   \larr <  nombre, Registros, Campos, Claves\_, IndiceS, IndiceN, 0  >$ 		\complejidad{O(1)}
	%Agrego los campos al diccString
	\State itcampos $\larr$ crearIt(Campos(columnas)) 				\complejidad{O(\# de campos)}
	\While{HaySiguiente(itcampos)}										\complejidad{O(\# de campos)}
	\State Este while es O(1) y se debe a que el cardinal de campos a iterar es acotado.			
					\State	Dato valor $\larr$ Significado(columnas, Siguiente(itcampos)) \complejidad{O(L)}
					\State	Definir(res.Campos, Siguiente(itcampos), Tipo?(valor)) \complejidad{O(1)}
					\State	Avanzar(itcampos) \complejidad{O(1)}
	\EndWhile \\
	\State itclaves $\larr$ crearItConj(claves) 				\complejidad{O(1)}
	\State Paso los campos claves de un conj al conjString
	\While{HaySiguiente(itclaves)}										\complejidad{O(\# de campos)}	
					\State	AgregarRapido(res.Claves, Siguiente(itclaves)) \complejidad{O(L)}
					\State	Avanzar(itcampos) \complejidad{O(1)}
	\EndWhile
	\State Donde L es la longitud del valor string mas largo.
 }{O((\#(campos(columnas))*L) }
 
\newpage
\algoritmo{agregarRegistro}{in r: registro, in/out t: tab}{}{
	\State Para poder acceder al registro en el conj en O(1), guardo el iterador al elemento
    \State itConj(Registro) nuevo $\larr$ AgregarRapido(t.Registros,r)	\complejidad{O(1)}
    \State t.\#Accesos++																	\complejidad{O(1)}
	\State Este registro debe ser indexado, si algun indice esta en uso.
%	\State $<$itConj(registro), itConj(registro) $>$ IndS $\larr$$<$nuevo, CrearIt(vacio())$>$
	\State IndS $\larr$$<$nuevo, CrearIt(vacio()), CrearIt(vacio())$>$
	\State IndN $\larr$$<$nuevo, CrearIt(vacio()), CrearIt(vacio())$>$
	\If{t.IndiceS.EnUso $\land$ t.IndiceN.EnUso}
		\State Dato valorS	$\larr$	Significado(r, t.IndiceS.CampoI) \complejidad{O(L)}
		\State Dato valorN	$\larr$	Significado(r, t.IndiceN.CampoI) \complejidad{O(L)}		
		\State EsClaveS $\larr$ Pertenece?(t.claves, t.IndiceS.campoI)
		\State EsClaveN $\larr$ Pertenece?(t.claves, t.IndiceN.campoI)
		\State Bool DefinidoS $\larr$Definido?(t.IndiceS.Indice, ValorString(valor))
		\State Bool DefinidoN $\larr$Definido?(t.IndiceN.Indice, ValorNat(valor))
		\If{$\neg$DefinidoS $\land$ $\neg$DefinidoN}
			\State Ambos no estan definidos
			\State cjS $\larr$ vacio()
			\State cjN $\larr$ vacio()
			\State newS $\larr$AgregarRapido(cjS, IndS)			
			\State newN $\larr$AgregarRapido(cjN, IndN)			
			\State $\pi_2$(Siguiente(newS)) $\larr$ newN
			\State $\pi_3$(Siguiente(newS)) $\larr$ newS
			\State $\pi_2$(Siguiente(newN)) $\larr$ newS
			\State $\pi_3$(Siguiente(newN)) $\larr$ newN
		\Else
			\If{DefinidoS $\land$ $\neg$DefinidoN}
				\State
			\EndIf
%			\State Bool DefinidoS $\larr$Definido?(t.IndiceS.Indice, ValorString(valor))
%			\State Bool DefinidoN $\larr$Definido?(t.IndiceN.Indice, ValorNat(valor))
			
		\EndIf	
	\Else
	\EndIf
}{O(L+Log(n))}
%	\If{t.IndiceS.EnUso}
%					\State Obtengo de r el valor del campo con el que se creo el indice.
%					\State Dato valor	$\larr$	Significado(r, t.IndiceS.CampoI) \complejidad{O(L)}
%					\State Bool Def $\larr$Definido?(t.IndiceS.Indice, ValorString(valor))
%					\If{Def} \complejidad{O(1)}
%							\State	Si esta definido, entonces hay varios registros que cumplen
%							\State	agrego el iterador al conjunto de que ya estaban.
%							\State Conj($<$itConj(registro), itConj(registro)$>$) viejo
%							\State viejo $\larr$ Significado(t.IndiceS.Indice, valor)\complejidad{O(L)}
%							\State itConj(registro)AgregarRapido(viejo, nuevo) \complejidad{O(L)}
%					\Else
%							\State Conj(Registro) viejo $\larr$ Vacio() \complejidad{O(1)}
%							\State AgregarRapido(viejo, nuevo)\complejidad{O(1)}
%							\State Definir(t.IndiceS.Indice, ValorString(valor), viejo) \complejidad{O(L)}
%							\State Como ingresamos un nuevo valor, actualizamos el min y max
%							\If{t.IndiceS.Min $>$ valor} \complejidad{O(L)}
%								\State t.IndiceS.Min $\larr$ valor\complejidad{O(L)}
%							\EndIf
%							\If{valor $>$ t.IndiceS.Max}\complejidad{O(L)}
%								\State t.IndiceS.Max $\larr$ valor\complejidad{O(L)}
%							\EndIf
%					\EndIf
%	\State Donde L es la longitud del valor string agregado a t.IndiceS						
%	\EndIf
%	\If{t.IndiceN.EnUso}
%					\State Obtengo de r el valor del campo con el que se creo el indice.
%					\State Dato valor $\larr$ Significado(r, t.IndiceN.CampoI) \complejidad{O(L)}
%					\State Bool Def $\larr$ Definido?(t.IndiceN.Indice, ValorNat(valor))\complejidad{O(log(n))}
%					\If{Def} 
%							\State Conj(Registro) viejo $\larr$ Significado(t.IndiceN.Indice, ValorNat(valor))\complejidad{O(log(n))}									
%							\State AgregarRapido(viejo, nuevo) \complejidad{O(1)}
%					\Else
%							\State Conj(Registro) viejo $\larr$ Vacio() \complejidad{O(1)}
%							\State AgregarRapido(viejo, nuevo) \complejidad{O(1)}
%							\State Definir(t.IndiceN.Indice, ValorNat(valor), viejo) \complejidad{O(Log(n))}
%							\State Como ingresamos un nuevo valor, actualizamos el min y max
%							\If{t.IndiceN.Min $>$ valor} \complejidad{O(1)}
%								\State t.IndiceS.Min $\larr$ valor\complejidad{O(1)}
%							\EndIf
%							\If{valor $>$ t.IndiceS.Max}\complejidad{O(1)}
%								\State t.IndiceN.Max $\larr$ valor\complejidad{O(1)}
%							\EndIf
%					\EndIf
%	\EndIf
%	\State Donde n es la cantidad de registros y L es la longitud maxima de un valor String.						
%	\State La complejidad depende del si hay o no indices, si ambos estan en uso. Si solo el
%	\State indice String esta en uso es O(L), si en cambio solo esta en uso el indice Natural
%	\State es O(Log(n)). Si ambos estan en uso es O(L+Log(n)) en peor caso.
%}{O(L+Log(n))}

\newpage
\algoritmo{borrarRegistro}{in crit: registro,in/out t: tab}{}{}{O(n)}
%	\State	Campo c $\larr$ Siguiente(CrearIt(Campos(crit)))	\complejidad{O(1)} %chequear
%	\State 	Dato valor $\larr$	Copiar(Significado(crit, c))			\complejidad{O(L)}
%	\State Sabemos que c esta incluido en claves(t) y crit tiene solo un campo.
%	\State Si hay un indice para el campo clave c, borrarRegistro es O(log(n)) u O(L) en peor caso.
%	\State Tenemos en cuenta que se borra en base a un campo clave, se borra solo un registro.
%	\If{t.IndiceS.EnUso $\lor$t.IndiceN.EnUso}
%	\State Caso: Hay algun indice en uso.
%		\If{t.IndiceS.CampoI=c $\lor$ t.IndiceN.CampoI=c}
%		\State Caso: Hay algun indice basado en el campo c de crit.
%			\If{t.IndiceS.CampoI=c}
%			\State Sabemos que c es un campo clave. Entonces eliminamos solo un reg.
%				\State ItConj(registro) itr Significado(t.IndiceS.Indice, ValorString(valor))
%				\State Registro r $\larr$ Siguiente(itr)
%				\State Borro el registro del conj(registro)
%				\State EliminarSiguiente(itr)
%				\State Borro la clave ValorString(valor) del indice
%				\State Borrar(t.IndiceS.Indice, ValorString(valor))
%				\State Hecho todo esto puede suceder que el Indice de Nat este en uso
%				\If{t.IndiceN.EnUso}
%				\State Si esta en uso, el campo del indice no es c,
%				\State t.IndiceN.CampoI puede ser clave o no.
%					\State Dato valorN  $\larr$ Obtener(r, t.IndiceN.CampoI)
%					\If{Pertenece?(t.claves, t.IndiceN.CampoI)}
%						\State El campo es clave, entonces elimino solo un registro
%						\State o sea elimino la entrada del diccionario.
%						\State Borrar(t.IndiceN.Indice, ValorNat(valor))
%					\Else
%						\State El campo no es clave, tengo que recorrer el conj(itConj(registro)),
%						\State sabemos que los valores Nat se insertan 
%						\State y borran con distribucion uniforme.
%					\EndIf
%				\Else
%				\EndIf
%			\Else
%			\EndIf
%		\Else
%		\EndIf	
%	\Else
%	\EndIf
%	
%	
%	\If{t.IndiceS.EnUso $\yluego$ t.IndiceS.CampoI=c}
%		\State Caso en el que hay un indice String en uso
%		\State String S $\larr$ ValorString(valor) 
%		\If{Definido?(t.IndiceS.Indice, S)}				
%			\State Conj(itConj(registro)) cj $\larr$ Significado(t.IndiceS.Indice, S) \complejidad{O(L)}
%			\State ItConj(Conj(itConj(registro))) itcj $\larr$ CrearIt(cj) \complejidad{O(1)}
%			\State itConj(registro) elem $\larr$ Siguiente(itcj)
%			\State Borro el registro del conjunto de t.registros
%			\State EliminarSiguiente(elem) \complejidad{O(1)}
%			\State Borro la clave S que contiene el conjunto con el iterador al registro.
%			\State Borrar(t.IndiceS.Indice, S) \complejidad{O(L)}
%			\If{t.IndiceS.Min=valor}
%				\State t.IndiceS.Min$\larr$ Minimo(Claves(t.IndiceS))
%			\EndIf
%			\If{t.IndiceS.Max=valor}
%				\State t.IndiceS.Max$\larr$ Maximo(Claves(t.IndiceS))
%			\EndIf
%			\State Dado que el crit solo tiene un campo clave, siempre elimino un registro.
%			\State t.\#Accesos++
%		\EndIf
%	\EndIf
%	\State Caso en el que hay un indice de Naturales
%	\If{t.IndiceN.EnUso $\land$ t.IndiceN.CampoI=c}
%		\State Nat N $\larr$ ValorNat(valor)
%		\If{Definido?(t.IndiceN.Indice, valor)}
%				\State Conj(itConj(registro)) cj $\larr$ Significado(t.IndiceS.Indice, S) \complejidad{O(L)}
%				\State ItConj(Conj(itConj(registro))) itcj $\larr$ CrearIt(cj) \complejidad{O(1)}
%				\State itConj(registro) elem $\larr$ Siguiente(itcj)
%				\State Borro el registro del conjunto de t.registros
%				\State EliminarSiguiente(elem) \complejidad{O(1)}
%				\State Borro la clave S que contiene el conjunto con el iterador al registro.
%
%				\State	itConj(registro) itr $\larr$ Significado(t.IndiceN.Indice, valor)\complejidad{O(1)}
%				% Borro el registro del indice,
%				\State	EliminarSiguiente(itr) \complejidad{O(1)}
%				\State	Borrar(t.IndiceN.Indice, valor) \complejidad{O(1)}
%				\If{t.IndiceN.Min=valor} \complejidad{O(1)}
%					\State t.IndiceS.Min$\larr$ Minimo(Claves(t.IndiceN)) \complejidad{O(Log(n))}
%				\EndIf
%				\If{t.IndiceN.Max=valor} \complejidad{O(1)}
%					\State t.IndiceS.Max$\larr$ Maximo(Claves(t.IndiceN))\complejidad{O(Log(n))}
%				\EndIf
%				\State Dado que el crit solo tiene un campo clave, siempre elimino un registro.
%				\State t.\#Accesos++
%		\EndIf
%	\EndIf
%		\Else
%			\State No hay indice para el campo clave de criterio pasado por parametro
%			\State itConj(registro) cr $\larr$ CrearItConj(t.registros)\complejidad{O(1)}
%			\While{HaySiguiente(cr)}\complejidad{O(Cardinal(t.registros))}
%					\State valorR $\larr$ Significado(Siguiente(cr), c)		\complejidad{O(1)}
%					\If{valorR=valor}
%						\State EliminarSiguiente(cr);									\complejidad{O(1)}
%						\State Dado que el crit solo tiene un campo clave, siempre elimino solo un registro.
%						\State t.\#Accesos++
%					\EndIf
%					\State Avanzar(cr)													\complejidad{O(1)}
%			\EndWhile
%			\State La complejidad de la operacion borrar depende de si hay o no indices
%			\State para el campo del crit pasado por parametro.
%			\State En caso de que exista dicho indice, en peor caso eliminar es O(Log(n)) u O(L)
%			\State siendo n la cantidad de registros de la tabla pasada por parametro y L
%			\State el valor string mas largo definido en la tabla.
%			\State En caso de no haber tal indice es O(n).			
%		\EndIf
%	\EndIf
%}{O(n)}

\newpage
\algoritmo{indexar}{in c: campo, in/out t: tab}{}{
	\If{tipoCampo(c,t)}
		\State t.IndiceN.EnUso $\larr$ True
	\Else
		\State t.IndiceS.EnUso $\larr$ True
	\EndIf
	\State	cr $\larr$ CrearItConj(t.registros)
	\If{tipoCampo?(c,t)}
			\While{HaySiguiente(cr)}
						\State 	Dato	valor $\larr$ Significado(Siguiente(cr), c)
						\State 	itConj(registro) itr $\larr$ CrearItConj(Siguiente(cr))
						\If{Definido?(t.IndiceN.Indice, valor)}
									\State	regviejos $\larr$ Significado(indC, valor)
									\State	AgregarRapido(regviejos, itr)
						\Else
									\State 	conj(registro) nuevo $\larr$ Vacio()
									\State 	AgregarRapido(nuevo, itr)
									\State	DefinirRapido(t.IndiceN.Indice, valor, nuevo)
						\EndIf
						\State	Avanzar(cr)
			\EndWhile
	\EndIf
	\If{$\neg$tipoCampo?(c,t)}
			\While{HaySiguiente(cr)}
						\State 	Dato	valor $\larr$ Significado(Siguiente(cr), c)
						\State 	itConj(registro) itr $\larr$ CrearItConj(Siguiente(cr))
						\If{Definido?(t.IndiceS.Indice, valor)}
									\State	regviejos $\larr$ Significado(indC, valor)
									\State	AgregarRapido(regviejos, itr)
						\Else
									\State 	conj(registro)	 nuevo $\larr$ Vacio()
									\State 	AgregarRapido(nuevo, itr)
									\State	DefinirRapido(t.IndiceN.Indice, valor, nuevo)
						\EndIf
						\State	Avanzar(cr)
			\EndWhile	
	\EndIf
}{O(1)}

  \algoritmo{puedoInsertar?}{in r:registro, in t:tab}{res:bool}{
    \State res $\larr$ campatible(r,t) $\land$ $\neg$hayCoincidencia( r, r.ClavesDicc, registros(t)  )  \complejidad{O(calcular))}
 }{O(calcular)}


  \algoritmo{compatible}{in r:registro, int t:tab}{res:bool}{
  		\State bool valor $\larr$ True
 		\If{Cardinal(campos(r))=Cardinal(t.Campos.DiccClaves)}
				  \State itcampos $\larr$ CrearItString(t.Campos.DiccClaves)
				  \While{valor $\land$ HaySiguiente(itcampos)} \complejidad{O(1)}
				  			\State Campo c $\larr$ Siguiente(itcampos) \complejidad{O(1)}
							\State valor $\larr$ Definido?(r, c) \complejidad{O(1)}
				  \EndWhile
		\Else
					\State valor $	\larr$ False  \complejidad{O(1)}
 		\EndIf
 		\State res $\larr$ valor  $\yluego$ mismosTipos(r,t)  \complejidad{O(1)}	
 		\State El costo del While es O(1) ya que la cantidad de campos de la tabla es acotado
 }{O($1$)}



 
  \algoritmo{minimo}{in c:campo, in t:tab}{res:dato}{
	\State	Si hay indice en el campo c, debe ser de complejidad O(1)
	\If{t.IndiceS.EnUso $\land$ t.IndiceS.CampoI=c}
		\State	Sabemos que hay un indice string para el campo c
		\State	res $\larr$ t.IndiceS.Min \complejidad{O(Cardinal(t.registros))}
	\Else
		\If{t.IndiceN.EnUso $\land$ t.IndiceN.CampoI=c}
			\State	Sabemos que hay un indice string para el campo c
			\State	res $\larr$ t.IndiceN.Min\complejidad{O(Cardinal(t.registros))}
%		\Else
%			\State	Si no hay indice para este campo hay que buscar el valor en O(n)
%			\State	ItConj(Registro) itr $\larr$ t.Registros
%			\State	Dato min\_ $\larr$ Significado(Siguiente(itr), c)
%			\While{HaySiguiente?(itr)}
%				\State	Dato sig $\larr$ Significado(Siguiente(itr), c)
%				\If{sig$\geq$min\_}
%						\State	min\_$\larr$ Copiar(sig)
%				\EndIf
%				\State Avanzar(itr)
%			\EndWhile
		\EndIf
	\EndIf
%  	\State 	res $\larr$ min( dameColumna(  c, t.registros  ))\complejidad{O(Cardinal(t.registros))}
 }{O(1)}
 
   \algoritmo{maximo}{in c:campo, in t:tab}{res:dato}{
	\State	Si hay indice en el campo c, debe ser de complejidad O(1)
	\If{t.IndiceS.EnUso $\land$ t.IndiceS.CampoI=c}
		\State	Sabemos que hay un indice string para el campo c
		\State	res $\larr$ t.IndiceS.Max \complejidad{O(Cardinal(t.registros))}
	\Else
		\If{t.IndiceN.EnUso $\land$ t.IndiceN.CampoI=c}
			\State	Sabemos que hay un indice string para el campo c
			\State	res $\larr$ t.IndiceN.Max\complejidad{O(Cardinal(t.registros))}
%		\Else
%			\State	Si no hay indice para este campo hay que buscar el valor en O(n)
%			\State	ItConj(Registro) itr $\larr$ t.Registros
%			\State	Dato max\_ $\larr$ Significado(Siguiente(itr), c)
%			\While{HaySiguiente?(itr)}
%				\State	Dato sig $\larr$ Significado(Siguiente(itr), c)
%				\If{sig$\geq$max\_}
%						\State	max\_$\larr$ Copiar(sig)
%				\EndIf
%				\State Avanzar(itr)
%			\EndWhile
		\EndIf
	\EndIf
}{O(1)}

  \algoritmo{puedeIndexar}{in c:campo, in t:tab}{res:bool}{
					\If{TipoCampo(c, t)}
							\State res $\larr$ $\neg$(t.IndiceN.EnUso)
					\Else
							\State res $\larr$ $\neg$(t.IndiceS.EnUso)
					\EndIf
 }{O(1)}


\algoritmo{hayCoincidencia}{in r:registro, in cc:ConjString(campo), in cr:Conj(registro)}{res:bool}{
  	\State	itcr $\larr$ CrearItConj(cr)   \complejidad{O(1)}  
    \State	res $\larr$ false                   \complejidad{O(1)}  
  	\While{HaySiguiente(itcr)}		\complejidad{O(Cardinal(cr))}  
				\State	res $\larr$ 	coincideAlguno(r,cc,Siguiente(itcr)) $\lor$res \complejidad{O(1)}  
				\State	Avanzar(itcr) 			\complejidad{O(1)}  
	\EndWhile   
}{O(Cardinal(cr))}


%  \operacion{coincidencias}{in r: registro, in cj: Conj(registro)}{res: Conj(ItConj(registro))}
% {$True$}
% {$res \igobs coincidencias(r,cj)$}
% {Devuelve el conjunto de registros de la tabla, que coinciden con los valores de r.}
% {O($L+Log(n)$)}
% {Retorna res por referencia,.}

\algoritmo{coincidencias}{in crit:registro, in cr:Conj(registro)}{res:Conj(ItConj(registro))}{
 	\State Conj(registro) salida	$\larr$ Vacio() \complejidad{O(1)}
	\State Debemos comparar todos los registros de cr.
	\State y agregarlos al conjunto de registros salida
  	\State 	itcr $\larr$ CrearItConj(cr)						
  	\While{HaySiguiente?(cr)}							\complejidad{O(Cardinal(cr))}
		\If {coincidenTodos(crit,campos(crit),Siguiente(itcr))}  \complejidad{O(1)}
				\State	AgregarRapido(salida, CrearIt(Siguiente(itcr))) \complejidad{O(1)}
				
				\State	AgregarRapido(salida, itcr) \complejidad{O(1)}

		\EndIf				
		\State	Avanzar(itcr) \complejidad{O(1)}
	\EndWhile   
	\State res $\larr$ salida\complejidad{O(1)por ref}
}{O(Cardinal(cr))}
 
%	\If{Cardinal(Indices(t))$\geq$1}
%	\State Si hay indice, obtengo los valores de crit para los campos de los indices que existan
%		\If{t.IndiceS.EnUso}
%				\State	vals $\larr$ Significado(crit, t.IndiceS.CampoI)
%				\State	Conj(registro) rind	$\larr$ Significado(t.IndiceS.Indice, vals)
%				\State	itrind $\larr$ CrearItConj(rind)
%				\While{HaySiguiente(itrind)}
%						\State r1 $\larr$ Siguiente(Siguiente(itcr))
%						\State Esta ultima linea, se debe a que estoy iterando, 
%						\State iteradores de conjunto al elemento
%						\If{coincidenTodos(r1,t.Claves,crit)}
%								\State AgregarRapido(salida, r1) 
%								\State Agrego por referencia.
%						\EndIf
%						\State Avanzar(itcr)
%				\EndWhile
%		\Else
%				\If{t.IndiceN.EnUso}
%						\State	valn $\larr$ Significado(crit, t.IndiceN.CampoI)
%						\State	Conj(registro) rind	$\larr$ Significado(t.IndiceN.Indice, valn)
%						\State	itrind $\larr$ CrearItConj(rind)
%						\While{HaySiguiente(itrind)}
%								\State r1 $\larr$ Siguiente(Siguiente(itcr))
%								\State Esta ultima linea, se debe a que estoy iterando, 
%								\State iteradores de conjunto al elemento
%								\If{coincidenTodos(r1,t.Claves,crit)}
%										\State AgregarRapido(salida, r1) 
%										\State Agrego por referencia.
%								\EndIf
%								\State Avanzar(itcr)
%						\EndWhile
%				\EndIf
%		\EndIf
%		\State Como buscamos los registros que tenga los mismo datos que crit,
%		\State los registros que cumplan dicho requerimiento. Si aparecen en uno
%		\State de los indices, en el otro tambien apareceran. Entonces solo comparo
%		\State los registros que tienen los mismos datos para los campos de los indices
%		\State correspondientes.
%	\EndIf

\newpage
\algoritmo{combinarRegistros}{in c:campo, in cr1:Conj(registro), in cr2:Conj(registro)}{res:Conj(registros)}{
	\State	itcr1 $\larr$ CrearItConjString(cr1) \complejidad{O(1)}  
	\State	Se me ocurre hacer un DiccString o DiccNat, dependiendo de tipo sea el campo c, de manera que combinar todos sea complejidad O(Log(Cardinal(cr2))).
	\State	Lo malo es que combinarRegistros sera O(Cardinal(cr2)*Log(Cardinal(cr2)))
	\If{Cardinal(cr2)$\geq$1}\complejidad{O(1)}  
		Registro rtemp $\larr$ Siguiente(CrearIt(cr2))\complejidad{O(1)}  
		Tipo rac $\larr$ Tipo?(Significado(rtemp, c))\complejidad{O(1)}  
		\If{rac} \complejidad{O(1)}  
			\State	Caso Natural
			\State	DiccNat(Nat, Conj(registro)) d $\larr$ vacio() \complejidad{O(1)}  
			\State	itcr2 $\larr$ CrearIt(cr2)\complejidad{O(1)}  
			\While{HaySiguiente?(itcr2)}\complejidad{O(1)}  
					\State Dato valor $\larr$ Obtener(Siguiente(itcr2), c) \complejidad{O(1)}
					\If{Definido?(d, ValorNat(valor))}  \complejidad{O(Cardinal(cr2))}
						\State	cjViejo $\larr$ Significado(d, ValorNat(valor)) \complejidad{O(Cardinal(cr2))}
						\State	AgregarRapido(d, Siguiente(itcr2)) \complejidad{O(1)}
					\Else
						\State	ConjNat(registro) cjNuevo $\larr$ vacio() \complejidad{O(1)}
						\State	AgregarRapido(d, Siguiente(itcr2)) \complejidad{O(1)}
						\State	Definir(d, ValorNat(valor), cjNuevo)\complejidad{O(Cardinal(cr2))}
					\EndIf
					\State	Avanzar(itcr2)\complejidad{O(1)}
			\EndWhile
		\Else
			\State	Caso String
			\State	DiccString(String, Conj(registro)) d $\larr$ vacio() \complejidad{O(1)}  
			\State	itcr2 $\larr$ CrearIt(cr2)\complejidad{O(1)}  
			\While{HaySiguiente?(itcr2)}\complejidad{O(1)}  
					\State Dato valor $\larr$ Obtener(Siguiente(itcr2), c) \complejidad{O(1)}
					\If{Definido?(d, ValorString(valor))}  \complejidad{O(Cardinal(cr2))}
						\State	cjViejo $\larr$ Significado(d, ValorString(valor)) \complejidad{O(Cardinal(cr2))}
						\State	AgregarRapido(d, Siguiente(itcr2)) \complejidad{O(1)}
					\Else
						\State	ConjString(registro) cjNuevo $\larr$ vacio() \complejidad{O(1)}
						\State	AgregarRapido(d, Siguiente(itcr2)) \complejidad{O(1)}
						\State	Definir(d, ValorString(valor), cjNuevo)\complejidad{O(Cardinal(cr2))}
					\EndIf
					\State	Avanzar(itcr2)\complejidad{O(1)}
			\EndWhile
		\EndIf	
		\State itcr1 $\larr$ CrearIt(cr1) \complejidad{O(1)} 
		\State res $\larr$ vacio()
	  	\While{HaySiguiente(itcr1)}         \complejidad{O(Cardinal(cr1))}
			\State	AgregarRapido(res, combinarTodos(c,Siguiente(itcr1),cr2)) \complejidad{O(vvv)}	
			\State	Avanzar(itcr1) 					\complejidad{O(1)}  
		\EndWhile   
	\Else
		\State res $\larr$ vacio()
	\EndIf
}{O(Cardinal(cr1))}

 
\algoritmo{dameColumna}{in c:campo, in cr:Conj(registro)}{res:Conj(dato)}{
  	\State 	Conj(Dato)	cj $\larr$ vacio();				\complejidad{O(1)}
	\State	La idea es no agregar el mismo dato dos veces, para eso uso un conj
	\State	del tipo de dato de la columna para hacer consulta.
	\If{Cardinal(cr)$\geq$1}\complejidad{O(1)}		
			\State	Tvalor $\larr$ Tipo?(Significado(Siguiente(CrearIt(cr))), c)\complejidad{O(1)}		
			\If{Tvalor}
					\State	ConjLog(nat) cj $\larr$ Vacio()\complejidad{O(1)}		
			\Else
					\State	ConjString(string) cj $\larr$ Vacio()\complejidad{O(1)}		
			\EndIf
			\State 	itcr $\larr$ CrearItConj(cr)					\complejidad{O(1)}		
			\State	cjd $\larr$ Vacio()
		  	\While{HaySiguiente(itcr)}						\complejidad{O(Cardinal(cr))}
		  				\State Dato data $\larr$ Significado(Siguiente(itcr), c)
		  				\If{Tvalor}
		  						\If {$\neg$Pertenece?(cj, valorNat(data))}\complejidad{O(Log(n))}
										\State 	AgregarRapido(cjd, data)\complejidad{O(1)}
										\State	AgregarRapido(cj, valorNat(data))\complejidad{O(1)}
								\EndIf	
						\Else
		  						\If {$\neg$Pertenece?(cj, valorString(data))}\complejidad{O(1)}
										\State 	AgregarRapido(cjd, data)\complejidad{O(1)}
										\State	AgregarRapido(cj, valorString(data))\complejidad{O(1)}
								\EndIf	
						\EndIf
				\State	Avanzar(itcr);							\complejidad{O(1)}
			\EndWhile     	
	\EndIf
	\State res $\larr$ cjd
	\State Si la columna es de tipo String, la complejidad es O(n), en caso de ser
	\State de tipo Nat la complejidad es O(nlog(n)).
	\State Donde n es el cardinal de cr	.
}{O(nlog(n))}
 
\algoritmo{mismosTipos}{in r:registro, in t:tab}{res:bool}{
  	\State 	valor $\larr$ True										\complejidad{O(1)}
  	\State 	itconjClaves $\larr$ CrearItConj(r.ClavesDicc) \complejidad{O(1)}
  	\While{valor $\land$ HaySiguiente(itconjClaves)}				\complejidad{O(1)}
  					\State	val1$\larr$ tipo?(Significado(r,Siguiente(itconjClaves))) \complejidad{O(1)}
  					\State	val2$\larr$ tipoCampo(Siguiente(itconjClaves),t)	\complejidad{O(1)}
					\State	valor $\larr$ (val1 = val2)	\complejidad{O(1)}
					\State	Avanzar(cr);								\complejidad{O(1)}
	\EndWhile     	
	\State	res $\larr$ valor
 }{O(1)}


  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Algoritmos operaciones auxiliares}

 %\operacion{BuscarEnTabla}{in c: campo,in t: tab}{res: Conj(ItConj(registro))}
 %{c$\subseteq$campos(t)}
 %{$res \igobs BuscarEnTabla(c, t)$}
 %{completar con lo que hace.}
 %{O($xxxxx$)}
 %{Retorna res por referencia, es modificable.} 
 
\algoritmo{BuscarEnTabla}{in criterio: registro, in t: tab}{res: Conj(ItConj(registro))}{
	\State 	Primero busco que campos de r, estan en los campos de t y son del mismo tipo
	\State	itcampos $\larr$ CrearIt(DiccClaves(t.campos))
	\State	Bool Encontrado $\larr$ false
	\State	campo EncontradoC 	
	\State	Conj(campo) cj $\larr$ vacio()
	\State	Vemos si algun campo de criterio esta en los indices
	\While{HaySiguiente?(itcampos) $\land$ $\neg$Encontrado}
		\State Campo c $\larr$ Siguiente(itcampos)
		\If{Definido?(criterio, c)}
			\State bool valorD $\larr$ (Tipo?(Significado(criterio, c))=Significado(t.campos, c))
			\If{valorD}
				\State	AgregarRapido(cj, c)
				\State	Encontrado $\larr$ (t.IndiceS.EnUso $\yluego$ t.IndiceS.CampoI=c)
				\If{Encontrado}
					\State	EncontradoC $\larr$ c
				\EndIf
			\EndIf
		\EndIf
		\State	Avanzar(itcri)
	\EndWhile	
	\State	Si encontrado es true entonces uso indice, sino recorro todo los registros
	\If{Encontrado}
		\State Entonces hay un indice para EncontradoC
		\If{Significado(t.campos, EncontradoC)}
			\State	Caso Natural
			\State	Obtengo el valor nat del registro criterio
			\State	Nat valor $\larr$ ValorNat(Significado(t.campos, EncontradoC))
			\State	res $\larr$ Significado(t.IndiceN.Indice, valor)
		\EndIf
		\If{$\neg$Significado(t.campos, EncontradoC)}
			\State	Caso String
			\State	Obtengo el valor nat del registro criterio
			\State	String valor $\larr$ ValorString(Significado(t.campos, EncontradoC))
			\State	res $\larr$ Significado(t.IndiceS.Indice, valor)
		\EndIf
	\Else
		res $\larr$ Coincidencias(criterio, t.registros)
	\EndIf
 }{O(1)}
 