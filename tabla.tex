
%\section{Pos es tupla(x:Nat, y:Nat)}

%\section{Placa es Nat}

%\section{Nombre es String}

\section{Tabla}

\subsection{Interfaz}

\sexc{tabla}
$\textbf{usa}$  
\generos{nat, dato, campo, tipo, registro, conjTrie, string, diccTrie(string, alfha), diccAVL(nat, beta)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Operaciones}


%%%%%% observadores basicos %%%%%%

\operacion{nombre}{in t: tab }{res : string}
 {true}
 {$res \igobs nombre(t)$}
 {Devuelve el nombre de la tabla ingresada por parametro.}
 {O($1$)}
 {Se retorna res por copia, por ser un tipo basico.}

\operacion{claves}{in t: tab }{res : itConjTrie(campo)}
 {true}
 {$res \igobs claves(t)$}
 {Devuelve un conjunto de campos que son claves en la tabla ingresada por parametro.}
 {O($1$)}
 {Se devuelve un iterador al conjunto claves por referencia.}
 
\operacion{indices}{in t: tab }{res : itConjTrie(campo)}
 {true}
 {$res \igobs indices(t)$}
 {Devuelve un conjunto de los indices de la tabla ingresada por parametro.}
 {O($calcular$)}
 {Se devuelve res por referencia y no es modificable.}
 
\operacion{campos}{in t: tab }{res : itConjTrie(campo)}
 {true}
 {$res \igobs campos(t)$}
 {Devuelve un conjunto a los campos de la tabla ingresada por parametro.}
 {O($1$)}
 {Se devuelve res por referencia.}

\operacion{tipoCampo}{in c: campo,in t: tab }{res : tipo}
 {c $\in$ campos(t)}
 {$res \igobs tipoCampo(t)$}
 {Devuelve el tipo del campo c en la tabla ingresada por parametro.}
 {O($1$)}
 {Se devuelve res por referencia, no es modificable.}
 
\operacion{registros}{in t: tab }{res : itConj(registro)}% deberia ser lista algo asi el conjunto
 {true}
 {$res \igobs registros(t)$}
 {Devuelve un conjunto a los registros de la tabla ingresada por parametro.}
 {O($L + log(n)$) } %tambien podria ser  O($R*(log(n+mz))$)
 {Se devuelve res referencia}

 
\operacion{cantidadDeAcccesos}{in t: tab }{res : nat}
 {true}
 {$res \igobs cantidadDeAccesos(t)$}
 {Devuelve la cantidad de modificaciones de la tabla ingresada por parametro.}
 {O($1$)}
 {Se devuelve res por copia.}

 
 %%%%%% generadores %%%%%%%
 
 \operacion{nuevaTabla}{in nombre: string, in claves: conjTrie(campo), in columnas: registro }{res : tab}
 {$\neg\emptyset$?(claves) $\land$ claves$\subseteq$campos(columnas)}
 {$res \igobs nuevaTabla(t)$}
 {Crea una tabla sin registros.}
 {O($calcular$)}
 {}

 \operacion{agregarRegistro}{in r: registro, in t: tab}{}
 {t\_0=t $\land$ campos(r)$\igobs$campos(t) $\land$ puedorInsertar?(r,t)}
 {agregarRegistro(r,t\_0)}
 {Agrega un registro a la tabla pasada por parametro.}
 {O($L + in$)}
 {Agrega el registro r por referencia.} 
 
 \operacion{borrarRegistro}{in crit: registro, in t: tab}{}
 {t\_0=t $\land$ $\#$(campos(r))=1 $\yluego$ dameUno(campos(crit))$\in$claves(t)}
 {borrarRegistro(r,t\_0)}
 {Borra los registros que cumplan el criterio pasado por parametro.}
 {O($L + in$)}
 {} 
 
  \operacion{indexar}{in crit: registro, in t: tab}{}
 {t\_0=t $\land$ puedeIndexar(c,t)}
 {indexar(c,t\_0)}
 {Borra los registros que cumplan el criterio pasado por parametro.}
 {O($L + in$)}
 {} 	
 
%%%%%% Otras Operaciones %%%%%%%%%%%

 \operacion{puedoInsertar?}{in r: registro, in t: tab}{res:bool}
 {$true$}
 {$res \igobs puedoInsertar?(r,t)$}
 {Informa si el registro pasado por parametro no tiene valores repetidos con respectos a los registros existentes, para los campos clave en la tabla pasada por parametro.}
 {O($T*L + in$)}
 {} 
 
  \operacion{compatible}{in r: registro, in t: tab}{res:bool}
 {$true$}
 {$res \igobs compatible(r,t)$}
 {Informa si el registro pasado por parametro tiene correspondecia en los tipos de los campos de tabla pasada por parametro.}
 {O($1$)}
 {} 
 
  \operacion{minimo}{in c: campo, in t: tab}{res:dato}
 {$\neg\emptyset$?(registro(t)) $\land$ c$\in$indices(t)}
 {$res \igobs minimo(c,t)$}
 {Retorna el minimo entre los valores de la tabla para el campo c.}
 {O($L+in$)}
 {Retorna res por referencia.}
  
  \operacion{maximo}{in c: campo, in t: tab}{res:dato}
 {$\neg\emptyset$?(registro(t)) $\land$ c$\in$indices(t)}
 {$res \igobs maximo(c,t)$}
 {Retorna el maximo entre los valores de la tabla para el campo c.}
 {O($L+in$)}
 {Retorna res por referencia.} 

  \operacion{puedeIndexar}{in c: campo, in t: tab}{res:bool}
 {$True$}
 {$res \igobs puedeIndexar(c,t)$}
 {Informa si se puede crear un nuevo indice.}
 {O($L+in$)}
 {} 
 																							% aca seria conj sobre lista algo asi%


  \operacion{coincidencias}{in r: registro, in cj: Conj(registro)}{res: Conj(registro)}
 {$True$}
 {$res \igobs coincidencias(r,cj)$}
 {Compara el valor del registro con el conjunto de registros y retorna la interseccion.}%se puede escribir mas correcto%
 {O($L+in$)}% aca tambien hay que usar renombres para que sea con complejidad de los conjuntos%
 {Retorna res por referencia.} 

  \operacion{hayCoincidencia}{in r: registro,in cj1: ConjTrie(campo), in cj2: Conj(registro)}{res:bool}
 {$True$}
 {$res \igobs hayCoincidencia(r,cj1,cj2)$}
 {Compara los valores del registro para los campos dados por parametro, con el conjunto de registros.}
 {O($L+in$)}% hay que usar renombres para que sea con complejidad de los conjuntos%
 {} 


 \operacion{combinarRegistros}{in c: campo,in cj1: Conj(registro), in cj2: Conj(registro)}{$\hfill$$\hfill$$\hfill$$\hfill$$\hfill$$\hfill$$\hfill$
 res: conj(registro)}
 {$True$}% en el tp no da una restriccion pero capaz hay que agregarla.
 {$res \igobs combinarRegistros(c,cj1,cj2)$}
 {Combina los valores de los registros para el campo dado por parametro.}
 {O($L+in$)}% aca tmb hay que usar renombres para que sea con complejidad de los conjuntos
 {Retorna res por copia.}%chequear!!!!!!!!!!!!!! 

  \operacion{dameColumna}{in c: campo,in cj: Conj(registro)}{res: conj(dato)}
 {$True$}% en el tp no da una restriccion pero capaz hay que agregarla.
 {$res \igobs dameColumna(c,cj1,cj2)$}
 {Reune en un conjunto los valores del campo pasado por parametro.}
 {O($T*L+in$)}% aca tmb hay que usar renombres para que sea con complejidad de los conjuntos
 {Retorna res por referencia.} 

  \operacion{mismosTipos}{in r: registro,in t: tab}{res: bool}
 {campos(r)$\subseteq$campos(t)}% en el tp no da una restriccion pero capaz hay que agregarla.
 {$res \igobs mismosTipos(r,t)$}
 {Compara los tipos correspondientes a los campos del registro y la tabla.}
 {O($1$)}% aca tmb hay que usar renombres para que sea con complejidad de los conjuntos
 {} 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Representaci贸n}

\serc{Tabla}{
  \donde{tab}{\tupla{
  		Nombre:\mbox{String},
  		Indices: \mbox{DiccTrie(campo, Indice)},
		Registros:\mbox{Conj(Registro)},
		Campos:\mbox{DiccTrie(Campo,Tipo)},
		\#Accesos:\mbox{Nat}
    }
      \donde{Indice}{Dicc(Dato,Conj(Registro))}
  }
}

\subsubsection*{Invariante de representaci贸n}

\begin{enumerate}
  \item El Nombre de la tabla es un String acotado.
  \item Indices un diccionario con claves que son campos y significados son Indice
  \item Para toda Dato que es clave en Indice, su significado llamemoslo sign esta incluido en Registros.
  \item 

\end{enumerate}


\subsubsection*{Funci贸n de abstracci贸n}
\abs{sistema}{CampusSeguro}{s}{cs}
$s.campus \igobs campus(cs)$ $\land$ \\
$s.estudiantes \igobs estudiantes(cs)$ $\land$ \\
$s.hippies \igobs hippies(cs)$ $\land$ \\
$s.agentes \igobs agentes(cs)$ $\land$ \\
$((\paratodo{nombre}{n}) s.hippies.definido(n) \impluego s.hippies.obtener(n) \igobs posEstYHippie(n,cs)$ $\lor$ \\
$(\paratodo{nombre}{n}) s.estudiantes.definido(n) \impluego s.estudiantes.obtener(n) \igobs posEstYHippie(n,cs))$ \\
$(\paratodo{placa}{pl}) s.agentes.definido(pl) \impluego s.estudiantes.obtener(pl).pos \igobs posAgente(pl,cs))$ \\
$(\paratodo{placa}{pl}) s.agentes.definido(pl) \impluego s.estudiantes.obtener(pl).cantSanciones \igobs cantSanciones(pl,cs))$ \\
$(\paratodo{placa}{pl}) s.agentes.definido(pl) \impluego s.estudiantes.obtener(pl).cantCapturas \igobs cantCapturas(pl,cs))$ \\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\subsection{Algoritmos}



\algoritmo{nombre}{in t:tab}{res:string}{
  \State $res \larr t.nombre$ \complejidad{O(1)}
}{O(1)}

\algoritmo{claves}{in t:tab}{res:ConjTrie(campo)}{
  \State $res \larr t.Campos.ClavesDicc$ \complejidad{O(1)}
}{O(1)}

\algoritmo{indices}{in t:tab}{res:ConjTrie(campo)}{ 
  \State $res \larr t.ClavesDicc$ \complejidad{O(1)}
}{O(1)}

\algoritmo{campos}{in t:tab}{res:ConjTrie(campo)}{
  \State $res \larr t.Campos.ClavesDicc$ \complejidad{O(1)}
}{O(1)} % en otras operaciones tiene q figurar ese conjunto

\algoritmo{tipoCampo}{in c:campo, in t:tab}{res:Tipo}{
  \State $res \larr Significado(t.Campos,c)$ \complejidad{O(1)}
}{O(1)}

 \algoritmo{registros}{in t:tab}{res:Conj(registro)}{
    \State $res \larr t.registros $ \complejidad{$\theta$(L+ log(n))}
 }{$\theta$(L+ log(n))}

  \algoritmo{cantDeAccesos}{in t:tab}{res:nat}{
    \State $res \larr t.cantDeAccesos$ \complejidad{$\theta$(1)}
 }{$\theta$(1)}
 
 %%%%%%%%%%%%% generadores
 

\algoritmo{nuevaTabla}{in nombre: string, in claves: conjTrie(campo), in columnas: registro}{res: tab}{
	\State itcampos $\larr$ crearItTrie(Campos(columnas)) 				\complejidad{O(1)}
	\State res $\larr \hfill <  nombre\, Vacio()\, Vacio()\, Vacio()\, 0  >$ 		\complejidad{O(1)}
	\While{HaySiguiente(itcampos)}										\complejidad{O(1)}
	\State Esto se debe a que \# de campos a iterar es acotada.			
					\State	valor $\larr$ Significado(r, Siguiente(itcampos)) \complejidad{O(1)}
					\State	DefinirRapido(res.Campos, Siguiente(itcampos), valor) \complejidad{O(1)}
					\If{Pertenece?(claves,Siguiente(itcampos))} 	\complejidad{O(1)}
									\State	val $\larr$ Significado(r, Siguiente(itcampos))
									\State	AgregarRapido(res.Campos.CamposClave, val) \complejidad{O(1)} %% depende de como sea diccTrie o conjTrie
					\EndIf				
					\State	Avanzar(itcampos) \complejidad{O(1)}
	\EndWhile
									
 }{$\theta$(1) }

\algoritmo{agregarRegistro}{in r:registro, in t: tab}{}{
    \State nuevo $\larr$ AgregarRapido(t.Registros,r)							\complejidad{$\theta$(1)}
    \State t.\#Accesos++																	\complejidad{$\theta$(1)}
    \If{Cardinal(t.Indices.ClavesDicc)$\geq$1}							\complejidad{$\theta$(1)}
    				\State itInd $\larr$ crearItConjTrie(t.Indices.ClavesDicc) \complejidad{$\theta$(1)}
    				\While{HaySiguiente(itInd)}									\complejidad{$\theta$(1)}
								\State indiceC	$\larr$	Obtener(t.Indices, Siguiente(itInd)) \complejidad{$\theta$(1)}
								\State valorC		$\larr$	Obtener(r, Siguiente(itInd)) \complejidad{$\theta$(1)}
    							\State AgregarRapido(Obtener(indiceC, valorC), nuevo) \complejidad{$\theta$(1)}
    							\State Avanzar(itInd)									\complejidad{$\theta$(1)}		
					\EndWhile
    \EndIf 
}{$\theta$(1)}
%    									\State \If {$\neg$Definido?(t.Indices, Siguiente(itInd))} 	\complejidad{$\theta$(1)}
%    												\State DefinirRapido(t.Indices, Siguiente(itInd), Vacio()) \complejidad{$\theta$(1)}
%										\State \EndIf


\algoritmo{borrarRegistro}{in crit: registro, in t: tab}{}{
	\State	c $\larr$ Siguiente(Campos(crit))	\complejidad{$\theta$(1)}
	\State 	valor $\larr$	Obtener(crit, c)			\complejidad{$\theta$(1)}
	\If{Definido?(t.Indices, c)} 			\complejidad{$\theta$(1)}
				%Si hay un indice para ese campo lo obtengo
					\State	indiceC $\larr$ Obtener(t.Indices, c)	\complejidad{$\theta$(1)}
				%ya tengo el indice ahora pregunto si ese valor de dato esta definido
				%asumo que entonces el registro esta en el indice desde que se agrego
					\State	itcjr $\larr$ CrearItConj(Obtener(indiceC, valor)) \complejidad{$\theta$(1)}
					\While{HaySiguiente(itcjr)}								\complejidad{$\theta$(Log(n))}
							\State	EliminarSiguiente(Siguiente(itcjr))				\complejidad{$\theta$(1)}
							\State	tiene sentido???	
							\State	EliminarSiguiente(itcjr)								\complejidad{$\theta$(1)}
					\EndWhile
	\Else	
					%No hay indice para c
					\State	cr $\larr$ Coincidencias(crit, t.registros)				\complejidad{$\theta$(Cardinal(t.registros))}
					%se supone que cr es un interador de un conj de itconj(registro)
					\While{HaySiguiente(cr)}
									\State	EliminarSiguiente(Siguiente(cr))
									\State	tiene sentido???	
									\State	EliminarSiguiente(cr)
					\EndWhile
	\EndIf
}{$\theta$(Calcular despues de consulta)}

\algoritmo{indexar}{in c: campo, in t: tab}{}{
	\If{tipoCampo(c,t)}
		\State conjLog(registro) nuevo $\larr$ vacio()
	\Else
		\State conjTrie(registro) nuevo $\larr$ vacio()
	\EndIf
	\State	indC $\larr$ Siguiente(DefinirRapido(t.Indices, c, nuevo))
	\State	cr $\larr$ t.registros
	\While{HaySiguiente(cr)}
				\State	valor $\larr$ Obtener(Siguiente(cr), c)
				\If{Definido?(indC, valor)}
							\State	regviejos $\larr$ Obtener(indC, valor)
							\State	AgregarRapido(regviejos, Siguiente(cr))
				\Else
							\State	DefinirRapido(indC, valor, Siguiente(cr))
				\EndIf
				\State	Avanzar(cr)
	\EndWhile

}{$\theta$(1)}

  \algoritmo{puedoInsertar?}{in r:registro, in t:tab}{res:bool}{
    \State res $\larr$ campatible(r,t) $\land$ $\neg$hayCoincidencia( r, r.ClavesDicc, registros(t)  )  \complejidad{$\theta$(L+log(n))}
 }{$\theta$(L+log(n))}


  \algoritmo{compatible}{in r:registro, int t:tab}{res:bool}{
      \State res $\larr$ campatible(r,t) $\yluego$ mismosTipos(r,t)  \complejidad{$\theta$(1)}
 }{O($1$)}


  \algoritmo{puedeIndexar}{in c:campo, in t:tab}{res:bool}{
      \State res  $\larr $ Definido?(t.campos,c) $\yluego \neg$ Definido?(t.Indices,c) $\land$ (Cardinal(t.Indices)$\leq$1 % \\ (long(t.Indices.IndicesL)=0 $\lor$ (long(t.Indices.IndicesL)$<$2 $\land$ \\ (tipoCampo(c,t)!=tipoCampo(t.Indices.IndicesL.primero,t))))    \complejidad{$\theta$(1)} %funcion axuliar hayIndiceC?(c,t)
 }{O(calcular)}
 

\algoritmo{combinarRegistros}{in c:campo, in cr1:Conj(registro), in cr2:Conj(registro)}{res:Conj(registros)}{
  	\State	res $\larr$ vacio();                      \complejidad{$\theta$(1)}
	\State	itcr1 $\larr$ CrearItConjTrie(cr1) \complejidad{$\theta$(1)}  
  	\While{HaySiguiente(itcr1)}         \complejidad{$\theta$(Cardinal(cr1))}
		\State	AgregarRapido(res, combinarTodos(c,Siguiente(itcr1),cr2)) \complejidad{$\theta$(1)}	%combinarTodos deberia hacer por copia asi no afecta el original.
				\State	Avanzar(itcr1); 					\complejidad{$\theta$(1)}  
	\EndWhile   
}{O(Cardinal(cr1))}
 
\algoritmo{hayCoincidencia}{in r:registro, in cc:ConjTrie(campo), in cr:Conj(registro)}{res:bool}{
  	\State	itcr $\larr$ CrearItConj(cr);   \complejidad{$\theta$(1)}  
    \State	res $\larr$ false;                   \complejidad{$\theta$(1)}  
  	\While{HaySiguiente(itcr)}		\complejidad{$\theta$(Cardinal(cr))}  
				\State	res $\larr$ 	coincideAlguno(r,cc,Siguiente(itcr)) $\lor$res; \complejidad{$\theta$(1)}  
				\State	Avanzar(itcr); 			\complejidad{$\theta$(1)}  
	\EndWhile   
}{O(Cardinal(cr))}

 \algoritmo{coincidencias}{in crit:registro, in cr:Conj(registro)}{res:Conj(registro)}{
%	\State c $\larr$ Siguiente(crit.ClavesDicc)
%	\If{tipo?(Obtener(crit, c))}
%				\State ConjLog(registro) res $\larr$ vacio()
%	\Else
%				\State ConjTrie(registro) res $\larr$ vacio()
%	\EndIf					
  	\State 	res $\larr$ Vacio(); 				\complejidad{$\theta$(1)}
  	\State 	itcr $\larr$ CrearItConj(cr)						
  	\While{HaySiguiente(cr)}							\complejidad{$\theta$(Cardinal(cr))}
				\If {coincidenTodos(crit,campos(crit),Siguiente(itcr))}  \complejidad{$\theta$(1)}
								\State	AgregarRapido(res,Siguiente(itcr)) 						\complejidad{$\theta$(1)}
				\EndIf				
				\State	Avanzar(itcr);																\complejidad{$\theta$(1)}
	\EndWhile   
 }{O(Cardinal(cr))}
 
  \algoritmo{minimo}{in c:campo, in t:tab}{res:dato}{
  	\State 	res $\larr$ min( dameColumna(  c, t.registros  ))\complejidad{$\theta$(Cardinal(t.registros))}
 }{O(Cardinal(t.registros))}
 
   \algoritmo{maximo}{in c:campo, in t:tab}{res:dato}{
  	\State 	res $\larr$ max( dameColumna(  c,  t.registros  ))\complejidad{$\theta$(Cardinal(t.registros))}
 }{O(Cardinal(t.registros))}
 
    \algoritmo{dameColumna}{in c:campo, in cr:Conj(registro)}{res:Conj(dato)}{
  	\State 	itcr $\larr$ CrearItConj(cr);					\complejidad{$\theta$(1)}
  	\State 	res $\larr$ vacio();				\complejidad{$\theta$(1)}
  	\While{HaySiguiente(itcr)}						\complejidad{$\theta$(Cardinal(cr))}
				\If {$\neg$Pertenece(res, Siguiente(itcr))} \complejidad{$\theta$(?????)}
							\State	AgregarRapido(res, Siguiente(itcr))				
%								\State	AgregarAtras(res,Obtener(Siguiente(itcr), c)) ; \complejidad{$\theta$(?????)}
				\EndIf				
				\State	Avanzar(itcr);							\complejidad{$\theta$(1)}
	\EndWhile     	
 }{O(calcular)}
 
    \algoritmo{mismosTipos}{in r:registro, in t:tab}{res:bool}{
  	\State 	res $\larr$ True;										\complejidad{$\theta$(1)}
  	\State 	itconjClaves $\larr$ CrearItConj(r.ClavesDicc); \complejidad{$\theta$(1)}
  	\While{HaySiguiente(itconjClaves)}				\complejidad{$\theta$(1)}
  					\State	val1$\larr$ tipo?(Obtener(r,Siguiente(itconjClaves))) \complejidad{$\theta$(Cardinal(t.registros))}
  					\State	val2$\larr$ tipoCampo(Siguiente(itconjClaves)),t)	\complejidad{$\theta$(1)}
					\State	res $\larr$ res $\land$ val1 = val2	\complejidad{$\theta$(1)}
					\State	Avanzar(cr);								\complejidad{$\theta$(1)}
	\EndWhile     	
 }{O(calcular)}


  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Algoritmos operaciones auxiliares}
%\algoritmo{agregarEstudiante}{in/out campus:campusSeguro, in pos:pos, in nombre:nombre}{}{
%    \State $campus.campus[pos.x][pos.y].hayEst \larr True$ \complejidad{O(1)}
%    \State $campus.campus[pos.x][pos.y].estudiante \larr definir(campus.estudiantes, nombre, pos)$ \complejidad{O(long(nombre))}
%}{O(long(nombre))}
%
%\algoritmo{agregarHippie}{in/out campus:campusSeguro, in pos:pos, in nombre:nombre}{}{
%    \State $campus.campus[pos.x][pos.y].hayHippie \larr True$ \complejidad{O(1)}
%    \State $campus.campus[pos.x][pos.y].hippie \larr definir(campus.hippies, nombre, pos)$ \complejidad{O(long(nombre))}
%}{O(long(nombre))}
%
%
% \algoritmo{sancionarAgentesVecinos}{in/out campus:campusSeguro, in pos:pos}{}{
%    % Sancionar VECINOS
%    \State $vecinos \larr campus.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
%    \If {$campus.atrapadoPorAgente?(pos)$} 
%       \While {$i < vecinos.tamanio()$}  \complejidad{O(1)}
%           \If {$campus.campus[vecinos[i].x][vecinos[i].y].hayAgente?$}
%               \State $campus.sancionarAgente(vecinos[i].agente)$ \complejidad{O(1)}
%           \EndIf
%           \State $i++$
%       \EndWhile
%    \EndIf
% }{O(1)}
%
%\algoritmo{sancionarAgentesEncerrandoEstVecinos}{in/out campus:campusSeguro, in pos:pos}{}{
%   \State $vecinos \larr campus.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
%   \State $i \larr 0$
%   \While {$i < vecinos.tamanio$} \complejidad{O(1)}
%      \If {$campus.campus[vecinos[i].x][vecinos[i].y].hayEst$ $\land$ $atrapadoPorAgente?(campus,pos)$}  \complejidad{O(1)}
%          \State $sancionarAgentesVecinos(campus,pos)$ \complejidad{O(1)}
%      \EndIf
%      \State $i++$
%    \EndWhile
%}{O(1)}
%
%\algoritmo{sancionarAgente}{in/out campus:campusSeguro, in/out agente:itDiccRapido}{}{
%    \State $campus.conKSanciones.ocurrioSancion \larr True$ \complejidad{O(1)}
%    \State $agente.siguiente.cantSanciones + 1$ \complejidad{O(1)}
%    \State $agente.siguiente.miUbicacion.eliminarSiguiente()$ \complejidad{O(1)}
%    \State // El iterador mismas apunta a la posicion correspondiente del agente dentro de la lista ordenada por cantSanciones
%    \State // Como la lista en el peor caso puede contener a todos los agentes con igual cant de sanciones
%    \State // la mayor cantidad posible de iteraciones del ciclo es 4
%    \While {$agente.siguiente.mismcampus.haySiguiente()$ \\$\land$ $agente.siguiente.mismas.siguiente.cantSanciones < agente.siguiente.cantSanciones$}
%      \State $agente.siguiente.mismas.avanzar()$ \complejidad{O(1)}
%    \EndWhile
%    \State // Si no hay siguiente o  si la cantidad de sanciones del siguiente es menor que la del agente, entonces, 
%    \State // creo un conMismasBucket, lo inserto como siguiente y me guardo el iterador en miUbicacion
%    \State // Sino, agrego el agente al conj de agentes del siguiente y me guardo el iterador en miUbicacion
%    \If {$\neg(agente.siguiente.mismas.haySiguiente)$ $\lor$
%        \\$(agente.siguiente.mismas.haySiguiente \land$\\$agente.siguiente.cantSanciones=agente.siguiente.mismas.cantSanciones)$} \complejidad{O(1)}
%      \State $nConMismasB \larr nuevaTupla(CrearNuevoDiccLineal(), agente.siguiente.cantSanciones)$
%      \State $agente.siguiente.mismas \larr agente.siguiente.mismas.agregarComoSiguiente(nConMismasB)$ \complejidad{O(1)}
%      \State $agente.siguiente.miUbicacion$ $\larr$
%      \State $agente.siguiente.mismas.siguiente.agentes.agregarComoSiguiente(agente.siguiente.pl)$ \complejidad{O(1)}
%    \Else 
%      \State $agente.siguiente.mismas.siguiente.agentes.agregarComoSiguiente(agente.siguiente.pl)$ \complejidad{O(1)}
%    \EndIf
%}{O(1)}
%
% \algoritmo{atrapadoPorAgente?}{in campus:campusSeguro, in pos:pos}{res:bool}{
%    \State $vecinos \larr campus.campusEstatico.vecinos(pos)$
%    \State $alMenos1Agente \larr False$ \complejidad{O(1)}
%    \State $i \larr 0$
%    \If {$\neg(encerrado?(pos, campus.campusEstatico.vecinos(pos)))$}
%      \State $return$ $false$
%    \EndIf
%    \State // Veo si hay algun agente alrededor
%     \While {$i<vecinos.tamanio()$} \complejidad{O(1)}
%       \If {$as.campus[vecinos[i].x][vecinos[i].y].hayAgente?$}
%          \State $return$ $true$            
%        \EndIf
%        \State $i++$ \complejidad{O(1)}
%    \EndWhile
% }{O(1)}
%
% \algoritmo{hippificarEstudiantesVecinos}{in/out campus:campusSeguro, in pos:pos}{}{
%    \State $vecinos \larr campus.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
%    \State $i \larr 0$ \complejidad{O(1)}
%    \While {$i<vecinos.tamanio()$} \complejidad{O(long(nombre))}
%        \If {$estAHippie?(campus,vecinos[i])$}
%            \State $hippificar(campus,vecinos[i])$ \complejidad{O(long(nombre))}
%        \EndIf
%        \State $i++$ \complejidad{O(1)}
%    \EndWhile
% }{O(long(nombre))}
%
%\algoritmo{hippificar}{in/out campus:campusSeguro, in pos:pos}{}{
%    \State // PRE: La posicion esta en el tablero y hay estudiante en la posicion
%    \State $as.campus[pos.x][pos.y].hayHippie \larr True$ \complejidad{O(1)}
%    \State $as.campus[pos.x][pos.y].hippie.agregarComoSiguiente(nombre, pos)$ \complejidad{O(long(nombreEstudiante))}
%    \State $as.campus[pos.x][pos.y].hayEst \larr False$ \complejidad{O(1)}
%    \State $as.campus[pos.x][pos.y].estudiante.eliminarSiguiente()$ \complejidad{O(long(nombreEstudiante))}
%}{O(long(nombre))}
%
% \algoritmo{estAHippie?}{in campus:campusSeguro, in pos:pos}{res:bool}{
%    \If {$\neg(encerrado?(pos,vecinos))$}
%      \State $return$ $false$ \complejidad{O(1)}
%    \EndIf
%    \State $i$ $\larr$ $0$ \complejidad{O(1)}
%    \State $cantHippies$ $\larr$ $0$ \complejidad{O(1)}
%    \State $vecinos \larr campus.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
%    \While {$i < vecinos.tamanio()$}
%      \If {$campus[vecinos[i].x][vecinos[i].y].hayHippie$}
%        \State $cantHippies++$ \complejidad{O(1)}
%      \EndIf
%      \State $i++$
%    \EndWhile
%    \State $return$ $cantHippies \ge 2$ \complejidad{O(1)}
% }{O(1)}
%
%\algoritmo{hippieAEst?}{in campus:campusSeguro, in pos:pos}{res:bool}{
%  \State $i$ $\larr$ $0$ \complejidad{O(1)}
%  \State $vecinos \larr campus.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
%  \While {$i < vecinos.tamanio()$} \complejidad{O(1)}
%      \If {$\neg(as.campus[vecinos[i].x][vecinos[i].y].hayEst?)$}
%        \State $return$ $False$ \complejidad{O(1)}
%      \EndIf
%  \EndWhile
%  \State $return$ $True$
%}{O(1)}
%
% \algoritmo{encerrado?}{in campus:campusSeguro, in pos:pos}{}{
%    \State $vecinos \larr vecinos(as.campusEstatico, pos)$ \complejidad{O(1)}
%    \State $i \larr vecinos.tamanio()$ \complejidad{O(1)}
%    \While {$i<vecinos.tamanio()$} \complejidad{O(1)}
%       \If {$\neg(campus.campus[vecinos[i].x][vecinos[i].y].hayAgente?$ $\lor$
%             \\$campus.campus[vecinos[i].x][vecinos[i].y].hayEst?$ $\lor$
%             \\$campus.campus[vecinos[i].x][vecinos[i].y].hayHippie?$ $\lor$
%             \\$campus.campus[vecinos[i].x][vecinos[i].y].hayObst?)$} \complejidad{O(1)}
%              \State $return$ $false$ \complejidad{O(1)}
%        \EndIf
%        \State $i++$ \complejidad{O(1)}
%    \EndWhile
%    \State $return true$
% }{O(1)}
%
% \algoritmo{aplicarHippiesVecinos}{in/out campus:campusSeguro, in pos:pos}{}{
%    \State $vecinos \larr campus.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
%    \State $i \larr 0$ \complejidad{O(1)}
%    \While {$i < vecinos.tamanio()$} \complejidad{O(long(nombre))}
%       \State aplicarHippie(campus, pos) \complejidad{O(long(nombre))}
%    \EndWhile
% }{O(long(nombre))}
%
% \algoritmo{aplicarHippie}{in/out campus:campusSeguro, in pos:pos}{}{
%    \State // PRE: pos valida y hayHippie en campus.campus[pos.x][pos.y]
%    \If {$campus.campus[pos.x][pos.y].hayHippie$}
%      \If {$as.hippieAEst(pos)$} \complejidad{O(1)}
%          \State $campus:campusSeguro.campus[pos.x][pos.y].hayHippie \larr False$ \complejidad{O(1)}
%          \State $campus:campusSeguro.campus[pos.x][pos.y].hayEst \larr True$ \complejidad{O(1)}
%          \State $as.campus[pos.x][pos.y].estudiante \larr CrearIt(campus.hippies)$ \complejidad{O(1)}
%          \State $campus.campus[pos.x][pos.y].estudiante.$
%          \State $agregarComoSiguiente(campus.campus[pos.x][pos.y].estudiante.nombre)$ \complejidad{O(long(nombre))}
%          \State $campus.campus[pos.x][pos.y].hippie.eliminarSiguiente()$ \complejidad{O(long(nombre))}
%      \Else
%        \If {$campus.campus[pos.x][pos.y].hayHippie?$ $\land$ $atrapadoPorAgente(pos)$}
%            \State $vecinos \larr campus.campusSeguro.vecinos(pos)$ \complejidad{O(1)}
%            \State $i \larr 0$ \complejidad{O(1)}
%            \While {$i < vecinos.tamanio()$} \complejidad{O(1)}
%                \State $posAct \larr vecinos[pos.x][pos.y]$ \complejidad{O(1)}
%                \State $info$ $\larr$ $campus.campus[vecinos[i].x][vecinos[i].y]$ \complejidad{O(1)}
%                \If {$posAct.hayAgente$}
%                    \State $info.agente.siguiente.cantCapturas++$ \complejidad{O(1)}
%                    \State // Actualizar mas vigilante
%                    \If {$campus.masVigilante.siguienteSignificado().cantCapturas < $\\$info.agente.siguienteSignificado().cantCapturas$}
%                        \State $campus.masVigilante \larr info.agente$ \complejidad{O(1)}
%                    \Else
%                        \If{$campus.masVigilante.siguienteSignificado().cantCapturas = $\\$info.agente.siguienteSignificado().cantCapturas$\\
%                            $\land campus.masVigilante.siguienteClave() < info.agente.siguienteClave()$} \complejidad{O(1)}
%                              \State $campus.masVigilante \larr info.agente$ \complejidad{O(1)}
%                        \EndIf
%                    \EndIf
%                \EndIf
%                \State $i++$
%            \EndWhile
%            \State $campus.campus[pos.x][pos.y].hayHippie? = False$ \complejidad{O(1)}
%            \State $campus.campus[pos.x][pos.y].hippie.eliminarSiguiente()$ \complejidad{O(long(nombre))}
%        \EndIf
%      \EndIf
%    \EndIf
% }{O(long(nombre))}
%
% \algoritmo{proxPosHippie}{in/out campus:campusSeguro, in nombre:string}{res:pos}{
%    \State // PRE: El nombre es un hippie y el hippie no esta encerrado
%    \State $posHippie \larr campus.hippies.obtener(nombre)$ \complejidad{O(long(nombre))}
%    \If {$campus.estudiantes.tamanio()>0$}
%      \State // Retorna de las posiciones mas cercanas, la que esta mas cerca del (0,0)
%      \State $proxPos \larr aPosMasCercana(campus.campusEstatico,posHippie,campus.estudiantes.significados)$ \complejidad{O($N_e$)}
%    \Else
%        \State // Retorna el ingreso mas cercan, en caso de empate, el de abajo
%        \State $proxPos \larr aIngresoMasCercano(campus.campusEstatico,posHippie)$ \complejidad{$O(1)$}
%    \EndIf
%    \State $res \larr proxPos$ \complejidad{O(1)}
% }{O($N_e$)}
%
%  \algoritmo{proxPosAgente}{in/out campus:campusSeguro, in posAgente:pos}{res:pos}{
%    \State // PRE: En la posicion hay un agente que se puede mover
%    \If {$campus.hippies.tamanio()>0$}
%      \State // Retorna de las posiciones mas cercanas, la que esta mas cerca del (0,0)
%      \State $proxPos \larr aPosMasCercana(campus.campusEstatico,posAgente,campus.hippies.significados)$ \complejidad{O($N_h$)}
%    \Else
%        \State // Retorna el ingreso mas cercano, en caso de empate, el de abajo
%        \State $proxPos \larr aIngresoMasCercano(campus.campusEstatico,posAgente)$ \complejidad{$O(1)$}
%    \EndIf
%    \State $res \larr proxPos$ \complejidad{O(1)}
% }{O($N_h$)}
%
%
% \algoritmo{aIngresoMasCercano}{in p:pos, cs: campusSeguro}{res:pos}{
%	\If{$p.Y\leq c.alto/2$}
%		\If{$PosValida(cs.campus,<p.X,p.Y-1>)\land \lnot HayAlgo(cs,<p.X,p.Y-1>)$}
%			\State $res \larr <p.X,p.Y-1>$
%		\Else
%			\If{$PosValida/c,<p.X+1,p.Y>)\land \lnot HayAlgo(c,<p.X+1,p.Y>)$}
%				\State $res \larr <p.X+1,p.Y>$
%			\Else
%				\If{$PosValida/c,<p.X-1,p.Y>)\land \lnot HayAlgo(c,<p.X-1,p.Y>)$}
%					\State $res \larr <p.X-1,p.Y>$
%				\Else
%					\State $res \larr <p.X,p.Y+1>$
%				\EndIf
%			\EndIf
%		\EndIf
%	\Else
%		\If{$PosValida(cs.campus,<p.X,p.Y+1>)\land \lnot HayAlgo(cs,<p.X,p.Y+1>)$}
%			\State $res \larr <p.X,p.Y-1>$
%		\Else
%			\If{$PosValida/c,<p.X+1,p.Y>)\land \lnot HayAlgo(c,<p.X+1,p.Y>)$}
%				\State $res \larr <p.X+1,p.Y>$
%			\Else
%				\If{$PosValida/c,<p.X-1,p.Y>)\land \lnot HayAlgo(c,<p.X-1,p.Y>)$}
%					\State $res \larr <p.X-1,p.Y>$
%				\Else
%					\State $res \larr <p.X,p.Y-1>$
%				\EndIf
%			\EndIf
%		\EndIf
%	\EndIf
%}
%{O($1$)}
%
% \algoritmo{ibusquedaBinariaPorSanciones}{in ar:arreglo(val:nat otr: $\alpha$>), in sanc:nat}{res:$<\alpha , bool>$)}{
% 	\State $res.\pi_2 \larr false$
%	\State $min \larr 0$
%	\State $max \larr |ar|$
%    \While {$max-min>1$} \complejidad{O(log($|ar|$))}
%       \State $med \larr (max-min)/2$
%       \If {$ar[med].val \leq sanc$}
%       		\State $min \larr med$
%       \Else
%       		\State $max \larr med$
%       	\EndIf
%    \EndWhile
%    \If {$ar[min].val = sanc$}
%    	\State $res \larr <ar[min].otr, true>$
%    \EndIf
% }{O(log($|ar|$)}