
%\section{Pos es tupla(x:Nat, y:Nat)}

%\section{Placa es Nat}

%\section{Nombre es String}

\section{Tabla}

\subsection{Interfaz}

\sexc{tabla}
$\textbf{usa}$  
\generos{nat, dato, campo, tipo, registro, conjTrie, string, diccTrie(string, alfha), diccAVL(nat, beta)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Operaciones}


%%%%%% observadores basicos %%%%%%

\operacion{nombre}{in t: tab }{res : string}
 {true}
 {$res \igobs nombre(t)$}
 {Devuelve el nombre de la tabla ingresada por parametro.}
 {O($1$)}
 {Se retorna res por copia, por ser un tipo basico.}

\operacion{claves}{in t: tab }{res : itConjTrie(campo)}
 {true}
 {$res \igobs claves(t)$}
 {Devuelve un conjunto de campos que son claves en la tabla ingresada por parametro.}
 {O($1$)}
 {Se devuelve un iterador al conjunto claves por referencia.}
 
\operacion{indices}{in t: tab }{res : itConjTrie(campo)}
 {true}
 {$res \igobs indices(t)$}
 {Devuelve un conjunto de los indices de la tabla ingresada por parametro.}
 {O($calcular$)}
 {Se devuelve res por referencia y no es modificable.}
 
\operacion{campos}{in t: tab }{res : itConjTrie(campo)}
 {true}
 {$res \igobs campos(t)$}
 {Devuelve un conjunto a los campos de la tabla ingresada por parametro.}
 {O($1$)}
 {Se devuelve res por referencia.}

\operacion{tipoCampo}{in c: campo,in t: tab }{res : tipo}
 {c $\in$ campos(t)}
 {$res \igobs tipoCampo(t)$}
 {Devuelve el tipo del campo c en la tabla ingresada por parametro.}
 {O($1$)}
 {Se devuelve res por referencia, no es modificable.}
 
\operacion{registros}{in t: tab }{res : itConj(registro)}% deberia ser lista algo asi el conjunto
 {true}
 {$res \igobs registros(t)$}
 {Devuelve un conjunto a los registros de la tabla ingresada por parametro.}
 {O($L + log(n)$) } %tambien podria ser  O($R*(log(n+mz))$)
 {Se devuelve res referencia}

 
\operacion{cantidadDeAcccesos}{in t: tab }{res : nat}
 {true}
 {$res \igobs cantidadDeAccesos(t)$}
 {Devuelve la cantidad de modificaciones de la tabla ingresada por parametro.}
 {O($1$)}
 {Se devuelve res por copia.}

 
 %%%%%% generadores %%%%%%%
 
 \operacion{nuevaTabla}{in nombre: string, in claves: conjTrie(campo), in columnas: registro }{res : tab}
 {$\neg\emptyset$?(claves) $\land$ claves$\subseteq$campos(columnas)}
 {$res \igobs nuevaTabla(t)$}
 {Crea una tabla sin registros.}
 {O($calcular$)}
 {}

 \operacion{agregarRegistro}{in r: registro, in t: tab}{}
 {t\_0=t $\land$ campos(r)$\igobs$campos(t) $\land$ puedorInsertar?(r,t)}
 {agregarRegistro(r,t\_0)}
 {Agrega un registro a la tabla pasada por parametro.}
 {O($L + in$)}
 {Agrega el registro r por referencia.} 
 
 \operacion{borrarRegistro}{in crit: registro, in t: tab}{}
 {t\_0=t $\land$ $\#$(campos(r))=1 $\yluego$ dameUno(campos(crit))$\in$claves(t)}
 {borrarRegistro(r,t\_0)}
 {Borra los registros que cumplan el criterio pasado por parametro.}
 {O($L + in$)}
 {} 
 
  \operacion{indexar}{in crit: registro, in t: tab}{}
 {t\_0=t $\land$ puedeIndexar(c,t)}
 {indexar(c,t\_0)}
 {Borra los registros que cumplan el criterio pasado por parametro.}
 {O($L + in$)}
 {} 	
 
%%%%%% Otras Operaciones %%%%%%%%%%%

 \operacion{puedoInsertar?}{in r: registro, in t: tab}{res:bool}
 {$true$}
 {$res \igobs puedoInsertar?(r,t)$}
 {Informa si el registro pasado por parametro no tiene valores repetidos con respectos a los registros existentes, para los campos clave en la tabla pasada por parametro.}
 {O($T*L + in$)}
 {} 
 
  \operacion{compatible}{in r: registro, in t: tab}{res:bool}
 {$true$}
 {$res \igobs compatible(r,t)$}
 {Informa si el registro pasado por parametro tiene correspondecia en los tipos de los campos de tabla pasada por parametro.}
 {O($1$)}
 {} 
 
  \operacion{minimo}{in c: campo, in t: tab}{res:dato}
 {$\neg\emptyset$?(registro(t)) $\land$ c$\in$indices(t)}
 {$res \igobs minimo(c,t)$}
 {Retorna el minimo entre los valores de la tabla para el campo c.}
 {O($L+in$)}
 {Retorna res por referencia.}
  
  \operacion{maximo}{in c: campo, in t: tab}{res:dato}
 {$\neg\emptyset$?(registro(t)) $\land$ c$\in$indices(t)}
 {$res \igobs maximo(c,t)$}
 {Retorna el maximo entre los valores de la tabla para el campo c.}
 {O($L+in$)}
 {Retorna res por referencia.} 

  \operacion{puedeIndexar}{in c: campo, in t: tab}{res:bool}
 {$True$}
 {$res \igobs puedeIndexar(c,t)$}
 {Informa si se puede crear un nuevo indice.}
 {O($L+in$)}
 {} 
 																							% aca seria conj sobre lista algo asi%


  \operacion{coincidencias}{in r: registro, in cj: Conj(registro)}{res: Conj(registro)}
 {$True$}
 {$res \igobs coincidencias(r,cj)$}
 {Compara el valor del registro con el conjunto de registros y retorna la interseccion.}%se puede escribir mas correcto%
 {O($L+in$)}% aca tambien hay que usar renombres para que sea con complejidad de los conjuntos%
 {Retorna res por referencia.} 

  \operacion{hayCoincidencia}{in r: registro,in cj1: ConjTrie(campo), in cj2: Conj(registro)}{res:bool}
 {$True$}
 {$res \igobs hayCoincidencia(r,cj1,cj2)$}
 {Compara los valores del registro para los campos dados por parametro, con el conjunto de registros.}
 {O($L+in$)}% hay que usar renombres para que sea con complejidad de los conjuntos%
 {} 


 \operacion{combinarRegistros}{in c: campo,in cj1: Conj(registro), in cj2: Conj(registro)}{$\hfill$$\hfill$$\hfill$$\hfill$$\hfill$$\hfill$$\hfill$
 res: conj(registro)}
 {$True$}% en el tp no da una restriccion pero capaz hay que agregarla.
 {$res \igobs combinarRegistros(c,cj1,cj2)$}
 {Combina los valores de los registros para el campo dado por parametro.}
 {O($L+in$)}% aca tmb hay que usar renombres para que sea con complejidad de los conjuntos
 {Retorna res por copia.}%chequear!!!!!!!!!!!!!! 

  \operacion{dameColumna}{in c: campo,in cj: Conj(registro)}{res: conj(dato)}
 {$True$}% en el tp no da una restriccion pero capaz hay que agregarla.
 {$res \igobs dameColumna(c,cj1,cj2)$}
 {Reune en un conjunto los valores del campo pasado por parametro.}
 {O($T*L+in$)}% aca tmb hay que usar renombres para que sea con complejidad de los conjuntos
 {Retorna res por referencia.} 

  \operacion{mismosTipos}{in r: registro,in t: tab}{res: bool}
 {campos(r)$\subseteq$campos(t)}% en el tp no da una restriccion pero capaz hay que agregarla.
 {$res \igobs mismosTipos(r,t)$}
 {Compara los tipos correspondientes a los campos del registro y la tabla.}
 {O($1$)}% aca tmb hay que usar renombres para que sea con complejidad de los conjuntos
 {} 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Representación}

\serc{Tabla}
{\donde{tab}
{ 
\tupla{
  		Nombre:String,
		Registros: Conj(Registro),
		Campos:\mbox{DiccTrie(Campo,Tipo)},
		Claves:\mbox{ConjTrie(Campo)},
		IndiceS:\tupla{CampoI: campo, EnUso: bool, Indice: DiccTrie(\mbox{string, Conj(Registro))}},
		IndiceN:\tupla{CampoI: campo, EnUso: bool, Indice: DiccNat(\mbox{nat, Conj(Registro))}},
		\#Accesos: Nat
  		}
}
}

  
\subsubsection*{Invariante de representación}

\begin{enumerate}
% Las claves estan en los campos.
\item	t.Claves esta inclido o es igual a t.Campos.
% 
\item	t.Nombre es un string acotado.
% Los campos de cada registro es igual a los campos de la tabla.
\item	Para todo registro r de t.Registros, entonces Campos(r) es igual al t.Campos.
% Los campos de cada registro, tienen el mismo tipo que los campos de la tabla.
\item	Para todo registro r de t.Registros y para todo campo c de Campos(r), entonces Tipo?(Obtener(r,c)) es igual Obtener(t.Campos, c).
% Si el indice esta EnUso y tiene un campo que pertenece a t.Campos, para toda clave c de t.IndiceS.Indice, el significado de Obtener(t.IndiceS.Indice, c) esta incluido en t.Registro.
\item	Si t.IndiceS.EnUso es true y t.IndiceS.CampoI pertenece a t.Campos, entonces para todo Dato d, si Definido?(t.IndiceS.Indice, d) es true, entonces Obtener(t.IndiceS.Indice, d) esta incluido o es igual a t.Registros.
% Todo registro de la tabla pertenece a algun significado de t.IndiceS.Indice
\item	Si t.IndiceS.EnUso es true y t.IndiceS.CampoI pertenece a t.Campos, entonces para todo registro r de t.Registros entonces Definido?(t.IndiceS.Indice, Obtener(r, t.IndiceS.CampoI)) es true y r pertenece a Obtener(t.IndiceS.Indice, Obtener(r, t.IndiceS.CampoI)).
%
\item	Lo anterior tambien aplica para t.IndiceN.Indice
  \item El valor de e.\#Accesos debe ser la cantidad de registros agregados, la cantidad de registros borrados, mas la cantidad de indices creados.
\end{enumerate}

%\rep{tab}{e}True $\iff$\\
%(1.) $(\forall r: registro)(Pertenece?(e.registros, r)$\yluego$(\forall c: campo)())$
%  \item Para todos los registros de r, el tipo de los datos de las columnas de r, deben coincidir con los tipos de las columnas en e.campos.
%  \item Todas las columnas de e.campos y su tipo, deben coincidir con los campos y tipo de todos los registros de e.registros.
%  \item El nombre de la tabla que figura en e.nombre, es un string de longitut acotada.
%  \item Para todo registro r de e.registros y para todo campo c de e.Indices.DiccClaves, se debe cumplir que si tenemos valor $\larr$ Obtener(r, c) y ind $\larr$ Obtener(e.Indices, c). Al evaluar que r $\in$ Obtener(ind, valor) y deben ser del mismo tipo.
%  \item Para todo campo c, que pertenece a e.Indices.DiccClaves, si tenemos que  ind $\larr$ Obtener(e.Indices, c), y para todo dato d perteneciente a ind.DiccClaves entonces Obtener(ind, d) esta incluido o es igual a e.registros.
%  \item Para todo registro r perteneciente  a e.registros r.DiccClaves es igual a e.campos.DiccClaves.
%  \item El valor de e.\#Accesos debe ser la cantidad de registros agregados, la cantidad de registros borrados, mas la cantidad de indices creados.


%\subsubsection*{Función de representaciòn}
%\rep{tab}{Tabla}{s}{cs}
%$s.campus \igobs campus(cs)$ $\l ,Mand$ \\
%$s.estudiantes \igobs estudiantes(cs)$ $\land$ \\
%$s.hippies \igobs hippies(cs)$ $\land$ \\
%$s.agentes \igobs agentes(cs)$ $\land$ \\
%$((\paratodo{nombre}{n}) s.hippies.definido(n) \impluego s.hippies.obtener(n) \igobs posEstYHippie(n,cs)$ $\lor$ \\
%$(\paratodo{nombre}{n}) s.estudiantes.definido(n) \impluego s.estudiantes.obtener(n) \igobs posEstYHippie(n,cs))$ \\
%$(\paratodo{placa}{pl}) s.agentes.definido(pl) \impluego s.estudiantes.obtener(pl).pos \igobs posAgente(pl,cs))$ \\
%$(\paratodo{placa}{pl}) s.agentes.definido(pl) \impluego s.estudiantes.obtener(pl).cantSanciones \igobs cantSanciones(pl,cs))$ \\
%$(\paratodo{placa}{pl}) s.agentes.definido(pl) \impluego s.estudiantes.obtener(pl).cantCapturas \igobs cantCapturas(pl,cs))$ \\

\subsubsection*{Función de abstracción}
\abs{tab}{Tabla}{s}{t}
$s.Nombre \igobs nombre(t)$ $\land$ \\
$s.Claves \igobs claves(t)$ $\land$ \\
$s.Indices \igobs indices(t)$ $\land$ \\
$s.Registros \igobs registros(t)$ $\land$ \\
$s.Campos.DiccClaves \igobs campos(t)$ $\land$ \\
$s.\#Accesos \igobs cantidadDeAccesos(t)$ $\land$ \\
$((\paratodo{campo}{c}) Definido?(s.Campos, c) \impluego Obtener(s.Campos, c) \igobs tipoCampo(c, t))$ \\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\subsection{Algoritmos}

\algoritmo{nombre}{in t:tab}{res:string}{
  \State $res \larr t.nombre$ \complejidad{O(1)}
}{O(1)}

\algoritmo{claves}{in t:tab}{res:ConjTrie(campo)}{
  \State $res \larr t.Claves.DiccClaves$ \complejidad{O(1)}
}{O(1)}

\algoritmo{indices}{in t:tab}{res:ConjTrie(campo)}{
  \State	res $\larr$ vacio();
  \If{t.IndiceS.EnUso}
		\State AgregarRapido(res, t.IndiceS.CampoI) \complejidad{O(1)}
  \EndIf
  \If{t.IndiceN.EnUso}
		\State AgregarRapido(res, t.IndiceN.CampoI) \complejidad{O(1)}
  \EndIf
}{O(1)}

\algoritmo{campos}{in t:tab}{res:ConjTrie(campo)}{
  \State $res \larr t.Campos.DiccClaves$ \complejidad{O(1)}
}{O(1)} % en otras operaciones tiene q figurar ese conjunto

\algoritmo{tipoCampo}{in c:campo, in t:tab}{res:Tipo}{
  \State $res \larr Significado(t.Campos, c)$ \complejidad{O(1)}
}{O(1)}

 \algoritmo{registros}{in t:tab}{res:Conj(registro)}{
    \State $res \larr t.registros $ \complejidad{$\theta$(1)}
 }{$\theta$(1)}

  \algoritmo{cantDeAccesos}{in t:tab}{res:nat}{
    \State $res \larr t.cantDeAccesos$ \complejidad{$\theta$(1)}
 }{$\theta$(1)}
 
 %%%%%%%%%%%%% generadores
 
\newpage
\algoritmo{nuevaTabla}{in nombre: string, in claves: conj(campo), in columnas: registro}{res: tab}{
	\State Conj(registro) Registros $\larr$ Vacio() \complejidad{O(1)}
	\State DiccTrie(campo, tipo) Campos $\larr$ Vacio() \complejidad{O(1)}
	\State ConjTrie(campo) Claves\_ $\larr$ Vacio() \complejidad{O(1)}
	\State IndiceS $\larr <  DameUno(claves) ,False , Vacio()  >$ 		\complejidad{O(1)}
	\State IndiceN $\larr <  DameUno(claves) ,False , Vacio()  >$ 		\complejidad{O(1)}
	\State \#Acessos $\larr$ 0 \complejidad{O(1)}
	\State res $   \larr <  nombre, Registros, Campos, Claves\_, IndiceS, IndiceN, 0  >$ 		\complejidad{O(1)}
	%Agrego los campos al dicctrie
	\State itcampos $\larr$ crearItConj(Campos(columnas)) 				\complejidad{O(1)}
	\While{HaySiguiente(itcampos)}										\complejidad{O(1)}
	\State Este while es O(1) y se debe a que el cardinal de campos a iterar es acotado.			
					\State	valor $\larr$ Significado(r, Siguiente(itcampos)) \complejidad{O(1)}
					\State	DefinirRapido(res.Campos, Siguiente(itcampos), Tipo?(valor)) \complejidad{O(1)}
					\State	Avanzar(itcampos) \complejidad{O(1)}
	\EndWhile \\
	\State itclaves $\larr$ crearItConj(claves) 				\complejidad{O(1)}
	\While{HaySiguiente(itclaves)}										\complejidad{O(1)}
	\State Esto se debe a que \# de campos a iterar es acotada.			
					\State	AgregarRapido(re.Claves, Siguiente(itclaves)) \complejidad{O(L)}
					\State	Avanzar(itcampos) \complejidad{O(1)}
	\EndWhile
	\State Donde L es la longitud de la cadena string mas larga y acotada del parametro claves.
									
 }{$\theta$(1) }
 
\newpage
\algoritmo{agregarRegistro}{in r: registro, in t: tab}{}{
    \State nuevo $\larr$ AgregarRapido(t.Registros,r)							\complejidad{$\theta$(1)}
    \State t.\#Accesos++																	\complejidad{$\theta$(1)}
	\If{t.IndiceS.EnUso}
					\State valor	$\larr$	Obtener(r, t.IndiceS.CampoI) \complejidad{$\theta$(1)}
					\If{Definido?(t.IndiceS.Indice, valor)} \complejidad{$\theta$(1)}
							\State viejo $\larr$ Obtener(t.IndiceS.Indice, valor)\complejidad{$\theta$(1)}
							\State AgregarRapido(viejo, nuevo) \complejidad{$\theta$(1)}
					\Else
							\State viejo $\larr$ Vacio() \complejidad{$\theta$(1)}
							\State AgregarRapido(viejo, nuevo) \complejidad{$\theta$(1)}
							Definir(t.IndiceS.Indice, valor, viejo) \complejidad{$\theta$(1)}
					\EndIf
	\EndIf
	\If{t.IndiceN.EnUso}
					\State valor	$\larr$	Obtener(r, t.IndiceN.CampoI) \complejidad{$\theta$(Log(n)}
					\If{Definido?(t.IndiceN.Indice, valor)} \complejidad{$\theta$(log(n))}
							\State viejo $\larr$ Obtener(t.IndiceN.Indice, valor)\complejidad{$\theta$(1)}
							\State AgregarRapido(viejo, nuevo) \complejidad{$\theta$(1)}
					\Else
							\State viejo $\larr$ Vacio() \complejidad{$\theta$(1)}
							\State AgregarRapido(viejo, nuevo) \complejidad{$\theta$(1)}
							Definir(t.IndiceN.Indice, valor, viejo) \complejidad{$\theta$(Log(n))}
					\EndIf
	\EndIf
	\State Donde n es la cantidad de cantidad de valores distintos definidos en t.IndiceN						
}{$\theta$(Log(n))}

\algoritmo{borrarRegistro}{in crit: registro,in t: tab}{}{
	\State	c $\larr$ Siguiente(Campos(crit))	\complejidad{$\theta$(1)}
	\State 	valor $\larr$	Obtener(crit, c)			\complejidad{$\theta$(1)}
	% Sabemos que c esta incluido en claves(t)
	% Si hay un indice de un campo clave borrar es O(log(n)) en peor caso
	\If{t.IndiceS.EnUso $\land$ t.IndiceS.CampoI=c}
			\If{Definido?(t.IndiceS.Indice, valor)}
					\State	itConj(registro) itr $\larr$ Obtener(t.IndiceS.Indice, valor) \complejidad{$\theta$(1)}
					% Borro el registro del indice,
					\State	EliminarSiguiente(itr) \complejidad{$\theta$(1)}
					\State	Borrar(t.IndiceS.Indice, valor) \complejidad{$\theta$(1)}
			\EndIf
	\EndIf
	\If{t.IndiceN.EnUso $\land$ t.IndiceN.CampoI=c}
			\If{Definido?(t.IndiceN.Indice, valor)}
					\State	itConj(registro) itr $\larr$ Obtener(t.IndiceN.Indice, valor) \complejidad{$\theta$(1)}
					% Borro el registro del indice,
					\State	EliminarSiguiente(itr) \complejidad{$\theta$(1)}
					\State	Borrar(t.IndiceN.Indice, valor) \complejidad{$\theta$(1)}
			\EndIf
	\EndIf				%ya tengo el indice ahora pregunto si ese valor de dato esta definido
					%No hay indice para c
%	\State conj(itConj(registro))cr $\larr$ Coincidencias(crit, t.registros)\complejidad{$\theta$(Cardinal(t.registros))}
					%se supone que cr es un interador de un conj de itconj(registro)
	\State itConj(registro) cr $\larr$ CrearItConj(t.registros)\complejidad{$\theta$(1)}
	\State Dato valorR $\larr$ Obtener(Siguiente(cr), c)		\complejidad{$\theta$(1)}
	\While{HaySiguiente(cr) $\land$ $\neg$(valorR=valor)}\complejidad{$\theta$(Cardinal(t.registros))}
			\State valorR $\larr$ Obtener(Siguiente(cr), c)		\complejidad{$\theta$(1)}
			\State Avanzar(cr)													\complejidad{$\theta$(1)}
	\EndWhile
	\If{HaySiguiente(cr)}														\complejidad{$\theta$(1)}
			\State EliminarSiguiente(cr);									\complejidad{$\theta$(1)}
	\EndIf
	\State La complejidad de la operacion borrar depende de si hay o no indices
	\State para el campo del crit pasado por parametro.
	\State En caso de que exista dicho indice, en peor caso eliminar es O(Log(n))
	\State siendo n la cantidad de registros de la tabla pasada por parametro.
	\State En caso contrario borrar es O(n).
}{}

\algoritmo{indexar}{in c: campo, in t: tab}{}{
	\If{tipoCampo(c,t)}
		\State t.IndiceN.EnUso $\larr$ True
	\Else
		\State t.IndiceS.EnUso $\larr$ True
	\EndIf
	\State	cr $\larr$ CrearItConj(t.registros)
	\If{tipoCampo?(c,t)}
			\While{HaySiguiente(cr)}
						\State 	Dato	valor $\larr$ Obtener(Siguiente(cr), c)
						\State 	itConj(registro) itr $\larr$ CrearItConj(Siguiente(cr))
						\If{Definido?(t.IndiceN.Indice, valor)}
									\State	regviejos $\larr$ Obtener(indC, valor)
									\State	AgregarRapido(regviejos, itr)
						\Else
									\State 	conj(registro) nuevo $\larr$ Vacio()
									\State 	AgregarRapido(nuevo, itr)
									\State	DefinirRapido(t.IndiceN.Indice, valor, nuevo)
						\EndIf
						\State	Avanzar(cr)
			\EndWhile
	\EndIf
	\If{$\neg$tipoCampo?(c,t)}
			\While{HaySiguiente(cr)}
						\State 	Dato	valor $\larr$ Obtener(Siguiente(cr), c)
						\State 	itConj(registro) itr $\larr$ CrearItConj(Siguiente(cr))
						\If{Definido?(t.IndiceS.Indice, valor)}
									\State	regviejos $\larr$ Obtener(indC, valor)
									\State	AgregarRapido(regviejos, itr)
						\Else
									\State 	conj(registro)	 nuevo $\larr$ Vacio()
									\State 	AgregarRapido(nuevo, itr)
									\State	DefinirRapido(t.IndiceN.Indice, valor, nuevo)
						\EndIf
						\State	Avanzar(cr)
			\EndWhile	
	\EndIf
}{$\theta$(1)}

  \algoritmo{puedoInsertar?}{in r:registro, in t:tab}{res:bool}{
    \State res $\larr$ campatible(r,t) $\land$ $\neg$hayCoincidencia( r, r.ClavesDicc, registros(t)  )  \complejidad{$\theta$(calcular))}
 }{$\theta$(calcular)}


  \algoritmo{compatible}{in r:registro, int t:tab}{res:bool}{
  		\State bool valor $\larr$ True
 		\If{Cardinal(campos(r))=Cardinal(t.Campos.DiccClaves)}
				  \State itcampos $\larr$ CrearItTrie(t.Campos.DiccClaves)
				  \While{valor $\land$ HaySiguiente(itcampos)} \complejidad{$\theta$(1)}
				  			\State Campo c $\larr$ Siguiente(itcampos) \complejidad{$\theta$(1)}
							\State valor $\larr$ Definido?(r, c) \complejidad{$\theta$(1)}
				  \EndWhile
		\Else
					\State valor $	\larr$ False  \complejidad{$\theta$(1)}
 		\EndIf
 		\State res $\larr$ valor  $\yluego$ mismosTipos(r,t)  \complejidad{$\theta$(1)}	
 		\State El costo del While es O(1) ya que la cantidad de campos de la tabla es acotado
 }{O($1$)}


  \algoritmo{puedeIndexar}{in c:campo, in t:tab}{res:bool}{
					\If{TipoCampo(c, t)}
							\State res $\larr$ $\neg$(t.IndiceN.EnUso)
					\Else
							\State res $\larr$ $\neg$(t.IndiceS.EnUso)
					\EndIf
 }{O(1)}
 

\algoritmo{combinarRegistros}{in c:campo, in cr1:Conj(registro), in cr2:Conj(registro)}{res:Conj(registros)}{
	\State	itcr1 $\larr$ CrearItConjTrie(cr1) \complejidad{$\theta$(1)}  
	\State	copiacr2 $\larr$ Copiar(cr2)		\complejidad{$\theta$(Cardinal(cr2))}  
  	\While{HaySiguiente(itcr1)}         \complejidad{$\theta$(Cardinal(cr1))}
		\State	combinarTodos(c,Siguiente(itcr1),copiacr2) \complejidad{$\theta$(1)}	%combinarTodos deberia hacer por copia asi no afecta el original.
				\State	Avanzar(itcr1) 					\complejidad{$\theta$(1)}  
	\EndWhile   
  	\State	res $\larr$ copiacr2                      \complejidad{$\theta$(1)}
}{O(Cardinal(cr1))}
 
\algoritmo{hayCoincidencia}{in r:registro, in cc:ConjTrie(campo), in cr:Conj(registro)}{res:bool}{
  	\State	itcr $\larr$ CrearItConj(cr)   \complejidad{$\theta$(1)}  
    \State	res $\larr$ false                   \complejidad{$\theta$(1)}  
  	\While{HaySiguiente(itcr)}		\complejidad{$\theta$(Cardinal(cr))}  
				\State	res $\larr$ 	coincideAlguno(r,cc,Siguiente(itcr)) $\lor$res \complejidad{$\theta$(1)}  
				\State	Avanzar(itcr) 			\complejidad{$\theta$(1)}  
	\EndWhile   
}{O(Cardinal(cr))}

 \algoritmo{coincidencias}{in crit:registro, in cr:Conj(registro)}{res:Conj(registro)}{
 	\State Conj(registro) salida	$\larr$ Vacio()
%	\If{Cardinal(Indices(t))$\geq$1}
%	\State Si hay indice, obtengo los valores de crit para los campos de los indices que existan
%		\If{t.IndiceS.EnUso}
%				\State	vals $\larr$ Obtener(crit, t.IndiceS.CampoI)
%				\State	Conj(registro) rind	$\larr$ Obtener(t.IndiceS.Indice, vals)
%				\State	itrind $\larr$ CrearItConj(rind)
%				\While{HaySiguiente(itrind)}
%						\State r1 $\larr$ Siguiente(Siguiente(itcr))
%						\State Esta ultima linea, se debe a que estoy iterando, 
%						\State iteradores de conjunto al elemento
%						\If{coincidenTodos(r1,t.Claves,crit)}
%								\State AgregarRapido(salida, r1) 
%								\State Agrego por referencia.
%						\EndIf
%						\State Avanzar(itcr)
%				\EndWhile
%		\Else
%				\If{t.IndiceN.EnUso}
%						\State	valn $\larr$ Obtener(crit, t.IndiceN.CampoI)
%						\State	Conj(registro) rind	$\larr$ Obtener(t.IndiceN.Indice, valn)
%						\State	itrind $\larr$ CrearItConj(rind)
%						\While{HaySiguiente(itrind)}
%								\State r1 $\larr$ Siguiente(Siguiente(itcr))
%								\State Esta ultima linea, se debe a que estoy iterando, 
%								\State iteradores de conjunto al elemento
%								\If{coincidenTodos(r1,t.Claves,crit)}
%										\State AgregarRapido(salida, r1) 
%										\State Agrego por referencia.
%								\EndIf
%								\State Avanzar(itcr)
%						\EndWhile
%				\EndIf
%		\EndIf
%		\State Como buscamos los registros que tenga los mismo datos que crit,
%		\State los registros que cumplan dicho requerimiento. Si aparecen en uno
%		\State de los indices, en el otro tambien apareceran. Entonces solo comparo
%		\State los registros que tienen los mismos datos para los campos de los indices
%		\State correspondientes.
%	\EndIf
	\State Debemos comparar todos los registros de cr.
	\State y agregarlos al conjunto de registros salida
  	\State 	itcr $\larr$ CrearItConj(cr)						
  	\While{HaySiguiente(cr)}							\complejidad{$\theta$(Cardinal(cr))}
				\If {coincidenTodos(crit,campos(crit),Siguiente(itcr))}  \complejidad{$\theta$(1)}
								\State	AgregarRapido(salida,Siguiente(itcr)) 						\complejidad{$\theta$(1)}
				\EndIf				
				\State	Avanzar(itcr);																\complejidad{$\theta$(1)}
	\EndWhile   
 }{O(Cardinal(cr))}
 
  \algoritmo{minimo}{in c:campo, in t:tab}{res:dato}{
  	\State 	res $\larr$ min( dameColumna(  c, t.registros  ))\complejidad{$\theta$(Cardinal(t.registros))}
 }{O(Cardinal(t.registros))}
 
   \algoritmo{maximo}{in c:campo, in t:tab}{res:dato}{
  	\State 	res $\larr$ max( dameColumna(  c,  t.registros  ))\complejidad{$\theta$(Cardinal(t.registros))}
 }{O(Cardinal(t.registros))}
 
\algoritmo{dameColumna}{in c:campo, in cr:Conj(registro)}{res:Conj(dato)}{
  	\State 	Conj(Dato)	cj $\larr$ vacio();				\complejidad{$\theta$(1)}
	\If{Cardinal(cr)$\geq$1}\complejidad{$\theta$(1)}		
			\State	Tvalor $\larr$ Tipo?(Obtener(DameUno(cr), c))\complejidad{$\theta$(1)}		
			\If{Tvalor}
					\State	ConjLog(nat) cj $\larr$ Vacio()\complejidad{$\theta$(1)}		
			\Else
					\State	ConjTrie(string) cj $\larr$ Vacio()\complejidad{$\theta$(1)}		
			\EndIf
			\State 	itcr $\larr$ CrearItConj(cr)					\complejidad{$\theta$(1)}		
			\State	cjd $\larr$ Vacio()
		  	\While{HaySiguiente(itcr)}						\complejidad{$\theta$(Cardinal(cr))}
		  				\State Dato data $\larr$ Obtener(Siguiente(itcr), c)
		  				\If{Tvalor}
		  						\If {$\neg$Pertenece?(cj, valorNat(data))}\complejidad{$\theta$(Log(n))}
										\State 	AgregarRapido(cjd, data)\complejidad{$\theta$(1)}
								\Else
										\State	AgregarRapido(cj, valorNat(data))\complejidad{$\theta$(1)}
								\EndIf	
						\Else
		  						\If {$\neg$Pertenece?(cj, valorString(data))}\complejidad{$\theta$(1)}
										\State 	AgregarRapido(cjd, data)\complejidad{$\theta$(1)}
								\Else
										\State	AgregarRapido(cj, valorString(data))\complejidad{$\theta$(1)}
								\EndIf	
						\EndIf
				\State	Avanzar(itcr);							\complejidad{$\theta$(1)}
			\EndWhile     	
	\EndIf
	\State res $\larr$ cjd
	\State Si la columna es de tipo String, la complejidad es O(n), en caso de ser
	\State de tipo Nat la complejidad es O(nlog(n)).
	\State El cardinal de res es la cantidad de datos distintos.
}{O(nlog(n))}
 
\algoritmo{mismosTipos}{in r:registro, in t:tab}{res:bool}{
  	\State 	valor $\larr$ True										\complejidad{$\theta$(1)}
  	\State 	itconjClaves $\larr$ CrearItConj(r.ClavesDicc) \complejidad{$\theta$(1)}
  	\While{valor $\land$ HaySiguiente(itconjClaves)}				\complejidad{$\theta$(1)}
  					\State	val1$\larr$ tipo?(Obtener(r,Siguiente(itconjClaves))) \complejidad{$\theta$(1)}
  					\State	val2$\larr$ tipoCampo(Siguiente(itconjClaves),t)	\complejidad{$\theta$(1)}
					\State	valor $\larr$ (val1 = val2)	\complejidad{$\theta$(1)}
					\State	Avanzar(cr);								\complejidad{$\theta$(1)}
	\EndWhile     	
	\State	res $\larr$ valor
 }{O(1)}


  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Algoritmos operaciones auxiliares}
%\algoritmo{agregarEstudiante}{in/out campus:campusSeguro, in pos:pos, in nombre:nombre}{}{
%    \State $campus.campus[pos.x][pos.y].hayEst \larr True$ \complejidad{O(1)}
%    \State $campus.campus[pos.x][pos.y].estudiante \larr definir(campus.estudiantes, nombre, pos)$ \complejidad{O(long(nombre))}
%}{O(long(nombre))}
%
%\algoritmo{agregarHippie}{in/out campus:campusSeguro, in pos:pos, in nombre:nombre}{}{
%    \State $campus.campus[pos.x][pos.y].hayHippie \larr True$ \complejidad{O(1)}
%    \State $campus.campus[pos.x][pos.y].hippie \larr definir(campus.hippies, nombre, pos)$ \complejidad{O(long(nombre))}
%}{O(long(nombre))}
%
%
% \algoritmo{sancionarAgentesVecinos}{in/out campus:campusSeguro, in pos:pos}{}{
%    % Sancionar VECINOS
%    \State $vecinos \larr campus.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
%    \If {$campus.atrapadoPorAgente?(pos)$} 
%       \While {$i < vecinos.tamanio()$}  \complejidad{O(1)}
%           \If {$campus.campus[vecinos[i].x][vecinos[i].y].hayAgente?$}
%               \State $campus.sancionarAgente(vecinos[i].agente)$ \complejidad{O(1)}
%           \EndIf
%           \State $i++$
%       \EndWhile
%    \EndIf
% }{O(1)}
%
%\algoritmo{sancionarAgentesEncerrandoEstVecinos}{in/out campus:campusSeguro, in pos:pos}{}{
%   \State $vecinos \larr campus.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
%   \State $i \larr 0$
%   \While {$i < vecinos.tamanio$} \complejidad{O(1)}
%      \If {$campus.campus[vecinos[i].x][vecinos[i].y].hayEst$ $\land$ $atrapadoPorAgente?(campus,pos)$}  \complejidad{O(1)}
%          \State $sancionarAgentesVecinos(campus,pos)$ \complejidad{O(1)}
%      \EndIf
%      \State $i++$
%    \EndWhile
%}{O(1)}
%
%\algoritmo{sancionarAgente}{in/out campus:campusSeguro, in/out agente:itDiccRapido}{}{
%    \State $campus.conKSanciones.ocurrioSancion \larr True$ \complejidad{O(1)}
%    \State $agente.siguiente.cantSanciones + 1$ \complejidad{O(1)}
%    \State $agente.siguiente.miUbicacion.eliminarSiguiente()$ \complejidad{O(1)}
%    \State // El iterador mismas apunta a la posicion correspondiente del agente dentro de la lista ordenada por cantSanciones
%    \State // Como la lista en el peor caso puede contener a todos los agentes con igual cant de sanciones
%    \State // la mayor cantidad posible de iteraciones del ciclo es 4
%    \While {$agente.siguiente.mismcampus.haySiguiente()$ \\$\land$ $agente.siguiente.mismas.siguiente.cantSanciones < agente.siguiente.cantSanciones$}
%      \State $agente.siguiente.mismas.avanzar()$ \complejidad{O(1)}
%    \EndWhile
%    \State // Si no hay siguiente o  si la cantidad de sanciones del siguiente es menor que la del agente, entonces, 
%    \State // creo un conMismasBucket, lo inserto como siguiente y me guardo el iterador en miUbicacion
%    \State // Sino, agrego el agente al conj de agentes del siguiente y me guardo el iterador en miUbicacion
%    \If {$\neg(agente.siguiente.mismas.haySiguiente)$ $\lor$
%        \\$(agente.siguiente.mismas.haySiguiente \land$\\$agente.siguiente.cantSanciones=agente.siguiente.mismas.cantSanciones)$} \complejidad{O(1)}
%      \State $nConMismasB \larr nuevaTupla(CrearNuevoDiccLineal(), agente.siguiente.cantSanciones)$
%      \State $agente.siguiente.mismas \larr agente.siguiente.mismas.agregarComoSiguiente(nConMismasB)$ \complejidad{O(1)}
%      \State $agente.siguiente.miUbicacion$ $\larr$
%      \State $agente.siguiente.mismas.siguiente.agentes.agregarComoSiguiente(agente.siguiente.pl)$ \complejidad{O(1)}
%    \Else 
%      \State $agente.siguiente.mismas.siguiente.agentes.agregarComoSiguiente(agente.siguiente.pl)$ \complejidad{O(1)}
%    \EndIf
%}{O(1)}
%
% \algoritmo{atrapadoPorAgente?}{in campus:campusSeguro, in pos:pos}{res:bool}{
%    \State $vecinos \larr campus.campusEstatico.vecinos(pos)$
%    \State $alMenos1Agente \larr False$ \complejidad{O(1)}
%    \State $i \larr 0$
%    \If {$\neg(encerrado?(pos, campus.campusEstatico.vecinos(pos)))$}
%      \State $return$ $false$
%    \EndIf
%    \State // Veo si hay algun agente alrededor
%     \While {$i<vecinos.tamanio()$} \complejidad{O(1)}
%       \If {$as.campus[vecinos[i].x][vecinos[i].y].hayAgente?$}
%          \State $return$ $true$            
%        \EndIf
%        \State $i++$ \complejidad{O(1)}
%    \EndWhile
% }{O(1)}
%
% \algoritmo{hippificarEstudiantesVecinos}{in/out campus:campusSeguro, in pos:pos}{}{
%    \State $vecinos \larr campus.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
%    \State $i \larr 0$ \complejidad{O(1)}
%    \While {$i<vecinos.tamanio()$} \complejidad{O(long(nombre))}
%        \If {$estAHippie?(campus,vecinos[i])$}
%            \State $hippificar(campus,vecinos[i])$ \complejidad{O(long(nombre))}
%        \EndIf
%        \State $i++$ \complejidad{O(1)}
%    \EndWhile
% }{O(long(nombre))}
%
%\algoritmo{hippificar}{in/out campus:campusSeguro, in pos:pos}{}{
%    \State // PRE: La posicion esta en el tablero y hay estudiante en la posicion
%    \State $as.campus[pos.x][pos.y].hayHippie \larr True$ \complejidad{O(1)}
%    \State $as.campus[pos.x][pos.y].hippie.agregarComoSiguiente(nombre, pos)$ \complejidad{O(long(nombreEstudiante))}
%    \State $as.campus[pos.x][pos.y].hayEst \larr False$ \complejidad{O(1)}
%    \State $as.campus[pos.x][pos.y].estudiante.eliminarSiguiente()$ \complejidad{O(long(nombreEstudiante))}
%}{O(long(nombre))}
%
% \algoritmo{estAHippie?}{in campus:campusSeguro, in pos:pos}{res:bool}{
%    \If {$\neg(encerrado?(pos,vecinos))$}
%      \State $return$ $false$ \complejidad{O(1)}
%    \EndIf
%    \State $i$ $\larr$ $0$ \complejidad{O(1)}
%    \State $cantHippies$ $\larr$ $0$ \complejidad{O(1)}
%    \State $vecinos \larr campus.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
%    \While {$i < vecinos.tamanio()$}
%      \If {$campus[vecinos[i].x][vecinos[i].y].hayHippie$}
%        \State $cantHippies++$ \complejidad{O(1)}
%      \EndIf
%      \State $i++$
%    \EndWhile
%    \State $return$ $cantHippies \ge 2$ \complejidad{O(1)}
% }{O(1)}
%
%\algoritmo{hippieAEst?}{in campus:campusSeguro, in pos:pos}{res:bool}{
%  \State $i$ $\larr$ $0$ \complejidad{O(1)}
%  \State $vecinos \larr campus.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
%  \While {$i < vecinos.tamanio()$} \complejidad{O(1)}
%      \If {$\neg(as.campus[vecinos[i].x][vecinos[i].y].hayEst?)$}
%        \State $return$ $False$ \complejidad{O(1)}
%      \EndIf
%  \EndWhile
%  \State $return$ $True$
%}{O(1)}
%
% \algoritmo{encerrado?}{in campus:campusSeguro, in pos:pos}{}{
%    \State $vecinos \larr vecinos(as.campusEstatico, pos)$ \complejidad{O(1)}
%    \State $i \larr vecinos.tamanio()$ \complejidad{O(1)}
%    \While {$i<vecinos.tamanio()$} \complejidad{O(1)}
%       \If {$\neg(campus.campus[vecinos[i].x][vecinos[i].y].hayAgente?$ $\lor$
%             \\$campus.campus[vecinos[i].x][vecinos[i].y].hayEst?$ $\lor$
%             \\$campus.campus[vecinos[i].x][vecinos[i].y].hayHippie?$ $\lor$
%             \\$campus.campus[vecinos[i].x][vecinos[i].y].hayObst?)$} \complejidad{O(1)}
%              \State $return$ $false$ \complejidad{O(1)}
%        \EndIf
%        \State $i++$ \complejidad{O(1)}
%    \EndWhile
%    \State $return true$
% }{O(1)}
%
% \algoritmo{aplicarHippiesVecinos}{in/out campus:campusSeguro, in pos:pos}{}{
%    \State $vecinos \larr campus.campusEstatico.vecinos(pos)$ \complejidad{O(1)}
%    \State $i \larr 0$ \complejidad{O(1)}
%    \While {$i < vecinos.tamanio()$} \complejidad{O(long(nombre))}
%       \State aplicarHippie(campus, pos) \complejidad{O(long(nombre))}
%    \EndWhile
% }{O(long(nombre))}
%
% \algoritmo{aplicarHippie}{in/out campus:campusSeguro, in pos:pos}{}{
%    \State // PRE: pos valida y hayHippie en campus.campus[pos.x][pos.y]
%    \If {$campus.campus[pos.x][pos.y].hayHippie$}
%      \If {$as.hippieAEst(pos)$} \complejidad{O(1)}
%          \State $campus:campusSeguro.campus[pos.x][pos.y].hayHippie \larr False$ \complejidad{O(1)}
%          \State $campus:campusSeguro.campus[pos.x][pos.y].hayEst \larr True$ \complejidad{O(1)}
%          \State $as.campus[pos.x][pos.y].estudiante \larr CrearIt(campus.hippies)$ \complejidad{O(1)}
%          \State $campus.campus[pos.x][pos.y].estudiante.$
%          \State $agregarComoSiguiente(campus.campus[pos.x][pos.y].estudiante.nombre)$ \complejidad{O(long(nombre))}
%          \State $campus.campus[pos.x][pos.y].hippie.eliminarSiguiente()$ \complejidad{O(long(nombre))}
%      \Else
%        \If {$campus.campus[pos.x][pos.y].hayHippie?$ $\land$ $atrapadoPorAgente(pos)$}
%            \State $vecinos \larr campus.campusSeguro.vecinos(pos)$ \complejidad{O(1)}
%            \State $i \larr 0$ \complejidad{O(1)}
%            \While {$i < vecinos.tamanio()$} \complejidad{O(1)}
%                \State $posAct \larr vecinos[pos.x][pos.y]$ \complejidad{O(1)}
%                \State $info$ $\larr$ $campus.campus[vecinos[i].x][vecinos[i].y]$ \complejidad{O(1)}
%                \If {$posAct.hayAgente$}
%                    \State $info.agente.siguiente.cantCapturas++$ \complejidad{O(1)}
%                    \State // Actualizar mas vigilante
%                    \If {$campus.masVigilante.siguienteSignificado().cantCapturas < $\\$info.agente.siguienteSignificado().cantCapturas$}
%                        \State $campus.masVigilante \larr info.agente$ \complejidad{O(1)}
%                    \Else
%                        \If{$campus.masVigilante.siguienteSignificado().cantCapturas = $\\$info.agente.siguienteSignificado().cantCapturas$\\
%                            $\land campus.masVigilante.siguienteClave() < info.agente.siguienteClave()$} \complejidad{O(1)}
%                              \State $campus.masVigilante \larr info.agente$ \complejidad{O(1)}
%                        \EndIf
%                    \EndIf
%                \EndIf
%                \State $i++$
%            \EndWhile
%            \State $campus.campus[pos.x][pos.y].hayHippie? = False$ \complejidad{O(1)}
%            \State $campus.campus[pos.x][pos.y].hippie.eliminarSiguiente()$ \complejidad{O(long(nombre))}
%        \EndIf
%      \EndIf
%    \EndIf
% }{O(long(nombre))}
%
% \algoritmo{proxPosHippie}{in/out campus:campusSeguro, in nombre:string}{res:pos}{
%    \State // PRE: El nombre es un hippie y el hippie no esta encerrado
%    \State $posHippie \larr campus.hippies.obtener(nombre)$ \complejidad{O(long(nombre))}
%    \If {$campus.estudiantes.tamanio()>0$}
%      \State // Retorna de las posiciones mas cercanas, la que esta mas cerca del (0,0)
%      \State $proxPos \larr aPosMasCercana(campus.campusEstatico,posHippie,campus.estudiantes.significados)$ \complejidad{O($N_e$)}
%    \Else
%        \State // Retorna el ingreso mas cercan, en caso de empate, el de abajo
%        \State $proxPos \larr aIngresoMasCercano(campus.campusEstatico,posHippie)$ \complejidad{$O(1)$}
%    \EndIf
%    \State $res \larr proxPos$ \complejidad{O(1)}
% }{O($N_e$)}
%
%  \algoritmo{proxPosAgente}{in/out campus:campusSeguro, in posAgente:pos}{res:pos}{
%    \State // PRE: En la posicion hay un agente que se puede mover
%    \If {$campus.hippies.tamanio()>0$}
%      \State // Retorna de las posiciones mas cercanas, la que esta mas cerca del (0,0)
%      \State $proxPos \larr aPosMasCercana(campus.campusEstatico,posAgente,campus.hippies.significados)$ \complejidad{O($N_h$)}
%    \Else
%        \State // Retorna el ingreso mas cercano, en caso de empate, el de abajo
%        \State $proxPos \larr aIngresoMasCercano(campus.campusEstatico,posAgente)$ \complejidad{$O(1)$}
%    \EndIf
%    \State $res \larr proxPos$ \complejidad{O(1)}
% }{O($N_h$)}
%
%
% \algoritmo{aIngresoMasCercano}{in p:pos, cs: campusSeguro}{res:pos}{
%	\If{$p.Y\leq c.alto/2$}
%		\If{$PosValida(cs.campus,<p.X,p.Y-1>)\land \lnot HayAlgo(cs,<p.X,p.Y-1>)$}
%			\State $res \larr <p.X,p.Y-1>$
%		\Else
%			\If{$PosValida/c,<p.X+1,p.Y>)\land \lnot HayAlgo(c,<p.X+1,p.Y>)$}
%				\State $res \larr <p.X+1,p.Y>$
%			\Else
%				\If{$PosValida/c,<p.X-1,p.Y>)\land \lnot HayAlgo(c,<p.X-1,p.Y>)$}
%					\State $res \larr <p.X-1,p.Y>$
%				\Else
%					\State $res \larr <p.X,p.Y+1>$
%				\EndIf
%			\EndIf
%		\EndIf
%	\Else
%		\If{$PosValida(cs.campus,<p.X,p.Y+1>)\land \lnot HayAlgo(cs,<p.X,p.Y+1>)$}
%			\State $res \larr <p.X,p.Y-1>$
%		\Else
%			\If{$PosValida/c,<p.X+1,p.Y>)\land \lnot HayAlgo(c,<p.X+1,p.Y>)$}
%				\State $res \larr <p.X+1,p.Y>$
%			\Else
%				\If{$PosValida/c,<p.X-1,p.Y>)\land \lnot HayAlgo(c,<p.X-1,p.Y>)$}
%					\State $res \larr <p.X-1,p.Y>$
%				\Else
%					\State $res \larr <p.X,p.Y-1>$
%				\EndIf
%			\EndIf
%		\EndIf
%	\EndIf
%}
%{O($1$)}
%
% \algoritmo{ibusquedaBinariaPorSanciones}{in ar:arreglo(val:nat otr: $\alpha$>), in sanc:nat}{res:$<\alpha , bool>$)}{
% 	\State $res.\pi_2 \larr false$
%	\State $min \larr 0$
%	\State $max \larr |ar|$
%    \While {$max-min>1$} \complejidad{O(log($|ar|$))}
%       \State $med \larr (max-min)/2$
%       \If {$ar[med].val \leq sanc$}
%       		\State $min \larr med$
%       \Else
%       		\State $max \larr med$
%       	\EndIf
%    \EndWhile
%    \If {$ar[min].val = sanc$}
%    	\State $res \larr <ar[min].otr, true>$
%    \EndIf
% }{O(log($|ar|$)}